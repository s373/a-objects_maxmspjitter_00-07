// 242.eclipse -- does meta-imaging on an input image.//		by r. luke dubois (luke@music.columbia.edu),//			computer music center, columbia university, 2001.////	objects and source are provided without warranty of any kind, express or implied.//#include "Movies.h"#include "ext_common.h"#include "ext.h"#include "ext_user.h"#include "n2.basicstrings.c"#include "n2.0000.h"     // n2.inkludestypedef struct zttz {	Object   n_ob;     // required max 	void     *n2hdr;   // required nato - position = signifikant _ must b 2nd		void             *dataout;      // n2data outlet	 	n2imgptr         gvelt;         // img buffer    short            red, green, blue, rows, columns,x,y;       // var!ablz    Boolean          on,bypass,freeze,think,quarrel;  // nato.objstate flagz} NNato;void *nnato_new(short rows, short columns);void nnato_assist(NNato *x, void *b, long msg, long nr, char *s);void nnato_info(NNato *x, void *p, void *b);void nnato_free(NNato *x);void nnato_processimage(NNato *x, n2atom *data);void nnato_processimage2(NNato *x, n2atom *data);void nnato_processimage3(NNato *x, n2atom *data);void nnato_processimage4(NNato *x, n2atom *data);void nnato_processimage5(NNato *x, n2atom *data);void nnato_processimage6(NNato *x, n2atom *data);void nnato_processimage7(NNato *x, n2atom *data);void nnato_on(NNato *x, long flag);void nnato_bypass(NNato *x, long flag);void nnato_freeze(NNato *x, long flag);void nnato_int(NNato *x, long n);void nnato_bang(NNato *x);void nnato_think(NNato *x, short val);void nnato_quarrel(NNato *x, short val);void nnato_variant(NNato *x, short variant);void nnato_weight(NNato *x, short weight);void nnato_red(NNato *x, short red);void nnato_green(NNato *x, short green);void nnato_blue(NNato *x, short blue);void nnato_rows(NNato *x, short rows);void nnato_columns(NNato *x, short columns);void nnato_x(NNato *x, short val);void nnato_y(NNato *x, short val);void     *nnato_class;main(void){	setup(&nnato_class, nnato_new, (method)nnato_free, (short)sizeof(NNato), 0L, 	      A_DEFLONG, A_DEFLONG, 0);    n2objaddimagecmd();    n2addstatecmd((method)nnato_int,(method)nnato_bang,                  (method)nnato_on,(method)nnato_freeze,(method)nnato_bypass,                  (method)nnato_think,(method)nnato_quarrel,(method)nnato_variant,0); 	addmess((method)nnato_assist,	                   "assist",    	A_CANT,0); 	addmess((method)nnato_info,	                       "info",		    A_CANT,0);    addmess((method)nnato_weight,                        "rgb",           A_DEFLONG,0);    addmess((method)nnato_red,                        "red",           A_DEFLONG,0);    addmess((method)nnato_green,                        "green",           A_DEFLONG,0);    addmess((method)nnato_blue,                        "blue",           A_DEFLONG,0);    addmess((method)nnato_rows,                        "rows",           A_DEFLONG,0);    addmess((method)nnato_columns,                        "columns",           A_DEFLONG,0);    addmess((method)nnato_x,                        "x+",           A_DEFLONG,0);    addmess((method)nnato_y,                        "y+",           A_DEFLONG,0);    n2addfklass("242.row");	post("");  	post("     .");	post(" . ");	post(" row,242.");}void nnato_assist(NNato *x, void *b, long msg, long nr, char *s){	if (msg == 1)      // inlet			sprintf(s, "(Nato) Image Input: Size %ld by %ld", x->columns, x->rows);    else       {	   if (msg == 2)   // outlet	      if (nr == 0)			sprintf(s, "(Nato) Image Output");       }}void nnato_info(NNato *x, void *p, void *b){      n2info();}void *nnato_new(short rows, short columns){	NNato      *x;    short      err;  		x = (NNato *)newobject(nnato_class);    n2addoutlet(x,&x->dataout);        if (err = n2objinit(x))       { post("242.row  :  n2objinit err = %ld",err); return;}            if ((err = n2inewimage(&x->gvelt,n2idefwidth,n2idefheight)))       { post("242.row  :  n2inewimage err = %ld",err); goto ikk;}      n2objsetimagefun(x,(method)nnato_processimage);	x->red = x->green = x->blue = 0;	       n2objsetimagefun(x,(method)nnato_processimage); //	if (rows<1) rows=1;//	if (columns<1) columns=1;//	if (rows>64) rows=64; // maximum of 64//	if (columns>64) columns=64; // maximum of 64	x->rows = 1;	x->columns = 1; 	x->x = x->y = 0;  	x->on = true;    x->bypass = x->freeze = x->think = x->quarrel = false;         return (x);ikk:	nnato_free(x);}void nnato_free(NNato *x){    if (x->gvelt) { n2idisposeimage(x->gvelt); x->gvelt = 0;}    n2objfree(x);}void nnato_on(NNato *x, long flag){        x->on = flag;}    void nnato_bypass(NNato *x, long flag){        x->bypass = flag;}      void nnato_freeze(NNato *x, long flag){        x->freeze = flag;} void nnato_int(NNato *x, long n){   n2defintstatefun(x,n);}void nnato_bang(NNato *x){   n2registerimage(x,n2objtype,x->dataout,0,x->gvelt);}void nnato_think(NNato *x, short val){   x->think = val;}void nnato_quarrel(NNato *x, short val){   x->quarrel = val;}void nnato_variant(NNato *x, short variant){   if (!variant)       n2objsetimagefun(x,(method)nnato_processimage);    else if (variant == 1)       n2objsetimagefun(x,(method)nnato_processimage2);   else if (variant == 2)       n2objsetimagefun(x,(method)nnato_processimage3);   else if (variant == 3)       n2objsetimagefun(x,(method)nnato_processimage4);}void nnato_weight(NNato *x, short weight){   x->green = x->blue = x->red = weight;}void nnato_red(NNato *x, short red){   x->red = red;}void nnato_green(NNato *x, short green){   x->green = green;}void nnato_blue(NNato *x, short blue){   x->blue = blue;}void nnato_rows(NNato *x, short rows){	if (rows<1) rows=1;//	if (rows>64) rows=64;	x->rows = rows;}void nnato_columns(NNato *x, short columns){	if (columns<1) columns=1;//	if (columns>64) columns=64;	x->columns = columns;   }void nnato_x(NNato *x, short val){	x->x=(val % 3) - 1;			//cycle values through  -2, 2}void nnato_y(NNato *x, short val){	x->y=(val % 3) - 1;}// the process image routines work like this:// // two pointers (src and src2) access the pixels in the input image// src controls the output of the smaller grids, src2 controls the tinting from// the upper-left corner of the point in the image that the grid is supposed to represent.//// the grid dimensions are computed by the size of the input image and are used to define // the size of each pixel in the grid (which is why some row and columns combinations// leave orphaned pixels on the edges).// the loop goes like this://// do each row {//    do each column {//       get the 'tint pixel' for that frame;////       do the height within each meta-frame {//          do the width within each meta-frame {//             output the pixels for each frame, tinting it;//          }//       }//    }// }// register the output image////void nnato_processimage(NNato *x, n2atom *data) {                       long           i, j, c, r, roubitez,     pix,  redpix, greenpix, bluepix;           //removed pix2                   short          red   = x->red, green = x->green, blue= x->blue, r2, g2, b2,                   width, height, err, rows=x->rows, columns=x->columns,                    colstep, rowstep,  colstep2, rowstep2;     Ptr            src2, src  ,   dst, srcadresz, dstadresz;    				  //     - src    n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate, dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);        if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.row  : n2iensureimagedimeq err = %ld", err);             return;           }           if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;                         dstpixmap   = n2igetpixmap(dstgvelt);         srcpixztate = n2igetpixstate(srcpixmap);                dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;               if (!n2ilockpix(dstpixmap)) goto ikk;                      srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);		rowstep = height/rows;		colstep = width/columns;		rowstep2 = rowstep + x->y;		//  adding offset		colstep2 = colstep + x->x;		for(r=0;r<rows;r++) {	        for(c=0;c<columns;c++) {	        src2 = srcadresz + (roubitez * r * rowstep) + (c*colstep*4);/*	        pix2 = n2get32(src2);			r2 = n2get32red(pix2);			g2 = n2get32green(pix2);			b2 = n2get32blue(pix2);    */    		for(i = 0; i < rowstep; i++)         		 {        		    src = srcadresz + i * roubitez * rows;                    		    dst = dstadresz + i * roubitez + (rowstep*r*roubitez) + (c*colstep*4);                              		    for(j = 0; j < colstep; j++)        		    {                pix = n2get32(src);  	            	redpix = n2get32red(pix) + red;                	greenpix = n2get32green(pix)+ green;                	bluepix = n2get32blue(pix) + blue;					n2set32m(dst,				         n2get32alpha(pix),				         n2klamp255((redpix)),				         n2klamp255((greenpix)),				         n2klamp255((bluepix)));					src+=4*columns;					dst+=4;					            		}				}			}		} 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}		void nnato_processimage2(NNato *x, n2atom *data) {                       long           i, j, c, r, roubitez,     pix,  redpix, greenpix, bluepix;           //removed pix2                   short          red   = x->red, green = x->green, blue= x->blue, r2, g2, b2,                   width, height, err, rows=x->rows, columns=x->columns,                    colstep, rowstep,  colstep2, rowstep2;     Ptr            src2, src  ,   dst, srcadresz, dstadresz;    				  //     - src    n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate, dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);        if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.row  : n2iensureimagedimeq err = %ld", err);             return;           }           if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;                         dstpixmap   = n2igetpixmap(dstgvelt);         srcpixztate = n2igetpixstate(srcpixmap);                dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;               if (!n2ilockpix(dstpixmap)) goto ikk;                      srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);		rowstep = height/rows;		colstep = width/columns;		rowstep2 = rowstep + x->y;		//  adding offset		colstep2 = colstep + x->x;		for(r=0;r<rows;r++) {	        for(c=0;c<columns;c++) {	        src2 = srcadresz + (roubitez * r * rowstep) + (c*colstep*4);/*	        pix2 = n2get32(src2);			r2 = n2get32red(pix2);			g2 = n2get32green(pix2);			b2 = n2get32blue(pix2);    */    		for(i = 0; i < rowstep; i++)         		 {        		    src = srcadresz + i * roubitez * rows +x->x;                    		    dst = dstadresz + i * roubitez + (rowstep*r*roubitez) + (c*colstep*4) +x->y;                              		    for(j = 0; j < colstep; j++)        		    {                pix = n2get32(src);  	            	redpix = n2get32red(pix) + red;                	greenpix = n2get32green(pix)+ green;                	bluepix = n2get32blue(pix) + blue;					n2set32m(dst,				         n2get32alpha(pix),				         n2klamp255((redpix)),				         n2klamp255((greenpix)),				         n2klamp255((bluepix)));					src+=4*columns;					dst+=4;					            		}				}			}		} 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}void nnato_processimage3(NNato *x, n2atom *data) {                       long           i, j, c, r, roubitez,     pix,  redpix, greenpix, bluepix;           //removed pix2                   short          red   = x->red, green = x->green, blue= x->blue, r2, g2, b2,                   width, height, err, rows=x->rows, columns=x->columns,                    colstep, rowstep,  colstep2, rowstep2;     Ptr            src2, src  ,   dst, srcadresz, dstadresz;    				  //     - src    n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate, dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);        if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.row  : n2iensureimagedimeq err = %ld", err);             return;           }           if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;                         dstpixmap   = n2igetpixmap(dstgvelt);         srcpixztate = n2igetpixstate(srcpixmap);                dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;               if (!n2ilockpix(dstpixmap)) goto ikk;                      srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);		rowstep = height/rows;		colstep = width/columns;		rowstep2 = rowstep + x->y;		//  adding offset		colstep2 = colstep + x->x;		for(r=0;r<rows;r++) {	        for(c=0;c<columns;c++) {	        src2 = srcadresz + (roubitez * r * rowstep) + (c*colstep*4);/*	        pix2 = n2get32(src2);			r2 = n2get32red(pix2);			g2 = n2get32green(pix2);			b2 = n2get32blue(pix2);    */    		for(i = 0; i < rowstep; i++)         		 {        		    src = srcadresz + i * roubitez * rows;                    		    dst = dstadresz + i * roubitez + (rowstep*r*roubitez) + (c*colstep*4);                              		    for(j = 0; j < colstep; j++)        		    {                pix = n2get32(src);  	            	redpix = n2get32red(pix) + red;                	greenpix = n2get32green(pix)+ green;                	bluepix = n2get32blue(pix) + blue;					n2set32m(dst,				         n2get32alpha(pix),				         n2klamp255((redpix)),				         n2klamp255((greenpix)),				         n2klamp255((bluepix)));					src+=4*columns + x->x;					dst+=4 + x->y ;					            		}				}			}		} 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}	void nnato_processimage4(NNato *x, n2atom *data) {                       long           i, j, c, r, roubitez,     pix,  redpix, greenpix, bluepix;           //removed pix2                   short          red   = x->red, green = x->green, blue= x->blue, r2, g2, b2,                   width, height, err, rows=x->rows, columns=x->columns,                    colstep, rowstep,  colstep2, rowstep2;     Ptr            src2, src  ,   dst, srcadresz, dstadresz;    				  //     - src    n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate, dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);        if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.row  : n2iensureimagedimeq err = %ld", err);             return;           }           if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;                         dstpixmap   = n2igetpixmap(dstgvelt);         srcpixztate = n2igetpixstate(srcpixmap);                dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;               if (!n2ilockpix(dstpixmap)) goto ikk;                      srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);		rowstep = height/rows;		colstep = width/columns;		rowstep2 = rowstep + x->y;		//  adding offset		colstep2 = colstep + x->x;		for(r=0;r<rows;r++) {	        for(c=0;c<columns;c++) {	        src2 = srcadresz + (roubitez * r * rowstep) + (c*colstep*4);/*	        pix2 = n2get32(src2);			r2 = n2get32red(pix2);			g2 = n2get32green(pix2);			b2 = n2get32blue(pix2);    */    		for(i = 0; i < rowstep; i++)         		 {        		    src = srcadresz + i * roubitez * rows;                    		    dst = dstadresz + i * roubitez + (rowstep*r*roubitez) + (c*colstep*4);                              		    for(j = 0; j < colstep; j++)        		    {                pix = n2get32(src);  	            	redpix = n2get32red(pix) + red;                	greenpix = n2get32green(pix)+ green;                	bluepix = n2get32blue(pix) + blue;					n2set32m(dst,				         n2get32alpha(pix),				         n2klamp255((redpix)),				         n2klamp255((greenpix)),				         n2klamp255((bluepix)));					src+=4*columns + x->x;					dst+=4 + x->y;					            		}				}			}		} 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}		void nnato_processimage5(NNato *x, n2atom *data) {                       long           i, j, c, r, roubitez,  pix2,   pix,  redpix, greenpix, bluepix;           //removed pix2                   short          red   = x->red, green = x->green, blue= x->blue, r2, g2, b2,                   width, height, err, rows=x->rows, columns=x->columns,                    colstep, rowstep,  colstep2, rowstep2;     Ptr            src2, src  ,   dst, srcadresz, dstadresz;    				  //     - src    n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate, dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);        if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.row  : n2iensureimagedimeq err = %ld", err);             return;           }           if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;                         dstpixmap   = n2igetpixmap(dstgvelt);         srcpixztate = n2igetpixstate(srcpixmap);                dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;               if (!n2ilockpix(dstpixmap)) goto ikk;                      srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);		rowstep = height/rows;		colstep = width/columns;		rowstep2 = rowstep + x->y;		//  adding offset		colstep2 = colstep + x->x;		for(r=0;r<rows;r++) {	        for(c=0;c<columns;c++) {	        src2 = srcadresz + (roubitez * r * rowstep) + (c*colstep*4);	        pix2 = n2get32(src2);			r2 = n2get32red(pix2);			g2 = n2get32green(pix2);			b2 = n2get32blue(pix2);    			    			for(i = 0; i < rowstep; i++)         		 {        		    src = srcadresz + i * roubitez * rows;                    		    dst = dstadresz + i * roubitez + (rowstep*r*roubitez) + (c*colstep*4);                              		    for(j = 0; j < colstep; j++)        		    {                pix = n2get32(src);  	            	redpix = n2get32red(pix) / r2 + red;                	greenpix = n2get32green(pix) / g2 + green;                	bluepix = n2get32blue(pix) /b2 + blue;					n2set32m(dst,				         n2get32alpha(pix),				         n2klamp255((redpix)),				         n2klamp255((greenpix)),				         n2klamp255((bluepix)));					src+=4*columns + x->x;					dst+=4 + x->y;					            		}				}			}		} 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}		void nnato_processimage6(NNato *x, n2atom *data) {                       long           i, j, c, r, roubitez, pix2,    pix,  redpix, greenpix, bluepix;           //removed pix2                   short          red   = x->red, green = x->green, blue= x->blue, r2, g2, b2,                   width, height, err, rows=x->rows, columns=x->columns,                    colstep, rowstep,  colstep2, rowstep2;     Ptr            src2, src  ,   dst, srcadresz, dstadresz;    				  //     - src    n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate, dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);        if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.row  : n2iensureimagedimeq err = %ld", err);             return;           }           if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;                         dstpixmap   = n2igetpixmap(dstgvelt);         srcpixztate = n2igetpixstate(srcpixmap);                dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;               if (!n2ilockpix(dstpixmap)) goto ikk;                      srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);		rowstep = height/rows;		colstep = width/columns;		rowstep2 = rowstep + x->y;		//  adding offset		colstep2 = colstep + x->x;		for(r=0;r<rows;r++) {	        for(c=0;c<columns;c++) {	        src2 = srcadresz + (roubitez * r * rowstep) + (c*colstep*4);	        pix2 = n2get32(src2);			r2 = n2get32red(pix2);			g2 = n2get32green(pix2);			b2 = n2get32blue(pix2);    		    			for(i = 0; i < rowstep; i++)         		 {        		    src = srcadresz + i * roubitez * rows;                    		    dst = dstadresz + i * roubitez + (rowstep*r*roubitez) + (c*colstep*4);                              		    for(j = 0; j < colstep; j++)        		    {                pix = n2get32(src);  	            	redpix = n2get32red(pix) /r2 +(n2get32red(pix)%r2) + red;                	greenpix = n2get32green(pix)/ g2 +(n2get32green(pix)%g2) + green;                	bluepix = n2get32blue(pix)/b2 +(n2get32blue(pix)%b2)  + blue;					n2set32m(dst,				         n2get32alpha(pix),				         n2klamp255((redpix)),				         n2klamp255((greenpix)),				         n2klamp255((bluepix)));					src+=4*columns + x->x;					dst+=4 + x->y;					            		}				}			}		} 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}		void nnato_processimage7(NNato *x, n2atom *data) {                       long           i, j, c, r, roubitez, pix2,    pix,  redpix, greenpix, bluepix;           //removed pix2                   short          red   = x->red, green = x->green, blue= x->blue, r2, g2, b2,                   width, height, err, rows=x->rows, columns=x->columns,                    colstep, rowstep,  colstep2, rowstep2;     Ptr            src2, src  ,   dst, srcadresz, dstadresz;    				  //     - src    n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate, dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);        if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.row  : n2iensureimagedimeq err = %ld", err);             return;           }           if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;                         dstpixmap   = n2igetpixmap(dstgvelt);         srcpixztate = n2igetpixstate(srcpixmap);                dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;               if (!n2ilockpix(dstpixmap)) goto ikk;                      srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);		rowstep = height/rows;		colstep = width/columns;		rowstep2 = rowstep + x->y;		//  adding offset		colstep2 = colstep + x->x;		for(r=0;r<rows;r++) {	        for(c=0;c<columns;c++) {	        src2 = srcadresz + (roubitez * r * rowstep) + (c*colstep*4);	        pix2 = n2get32(src2);			r2 = n2get32red(pix2);			g2 = n2get32green(pix2);			b2 = n2get32blue(pix2);    		    			for(i = 0; i < rowstep; i++)         		 {        		    src = srcadresz + i * roubitez * rows;                    		    dst = dstadresz + i * roubitez + (rowstep*r*roubitez) + (c*colstep*4);                              		    for(j = 0; j < colstep; j++)        		    {                pix = n2get32(src);  	            	redpix = (n2get32red(pix) /r2 + red)/j;                	greenpix = (n2get32green(pix)/ g2 + green)/j;                	bluepix = (n2get32blue(pix)/b2 + blue)/j;					n2set32m(dst,				         n2get32alpha(pix),				         n2klamp255((redpix)),				         n2klamp255((greenpix)),				         n2klamp255((bluepix)));					src+=4*columns + x->x;					dst+=4 + x->y;					            		}				}			}		} 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}		