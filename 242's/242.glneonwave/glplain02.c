#include "Movies.h"#include "ext_common.h"#include "ext.h"#include "ext_user.h"#include "n2.basicstrings.c"#include "n2.0000.h"#include "agl.h"#include "GL/glut.h"#define MAXVECTOR 128typedef struct zttz {	Object    n_ob; 	void     *n2hdr;    // required nato - position = important _ must b 2nd	    void   	 *glout;    short     type;    GLfloat   vertex,vertex2,red,green,blue,              normalx,normaly,normalz;      GLboolean texture;                  long      shademodel,i;    Boolean        on, ignt;  //	float		vector[MAXVECTOR][MAXVECTOR];//	float		vectorpos[MAXVECTOR][MAXVECTOR];	float		vector[MAXVECTOR];	short		vauto, vcurr, vsize;	//is oscilating & current acitv vect node	float		z, factor;	} NNato;void *nnato_new(void);void nnato_assist(NNato *x, void *b, long msg, long nr, char *s);void nnato_info(NNato *x, void *p, void *b);void nnato_free(NNato *x);void nnato_on(NNato *x, long flag);void nnato_bang(NNato *x);void nnato_int(NNato *x, long n);   void nnato_variant(NNato *x, short variant);void nnato_type(NNato *x, short type);void nnato_vertex(NNato *x, long vertex, long vertex2);void nnato_shademodel(NNato *x, long type);void nnato_klr(NNato *x, long red, long green, long blue);void nnato_normalz(NNato *x, long koordx, long koordy, long koordz);void nnato_texture(NNato *x, long flag);void nnato_revertgeo(NNato *x);void nnato_revert(NNato *x);void nnato_vectinit(NNato *x);void nnato_vectset(NNato *x, short index, float z);void nnato_vectauti(NNato *x, short flag);void nnato_vectsize(NNato *x, short size);void nnato_factor(NNato *x, float flag);void nnato_glfun(n2glatom glatom);void nnato_glfun2(n2glatom glatom);void nnato_glfun3(n2glatom glatom);void nnato_glregister(NNato *x, void *klientz);void    *nnato_class;main(){	setup(&nnato_class, nnato_new, (method)nnato_free, (short)sizeof(NNato), 0L, 0L, 0); 	addmess((method)nnato_assist,	                  "assist",          	A_CANT,0); 	addmess((method)nnato_info,	                      "info",		        A_CANT,0);    n2objaddglcmd();    n2addstatecmd((method)nnato_int,(method)nnato_bang,                  (method)nnato_on,-1,-1,-1,-1,(method)nnato_variant,0);    addmess((method)nnato_type,                       "drau.type",          A_DEFLONG,0);    addmess((method)nnato_shademodel,                 "normal.type",        A_DEFLONG,0);    addmess((method)nnato_normalz,                    "normal",             A_DEFLONG,A_DEFLONG,A_DEFLONG,0);    addmess((method)nnato_klr,                        "color",              A_DEFLONG,A_DEFLONG,A_DEFLONG,0);    addmess((method)nnato_texture,                    "texture",            A_DEFLONG,0);    addmess((method)nnato_vertex,                     "geo",                A_DEFLONG,A_DEFLONG,0);    addmess((method)nnato_revertgeo,                  "revert.geo",         0);    addmess((method)nnato_revert,                     "revert",             0);    addmess((method)nnato_vectset,                     "vect",                A_DEFLONG,A_DEFFLOAT,0);    addmess((method)nnato_factor,                     "factor",               A_DEFFLOAT,0);    addmess((method)nnato_vectsize,                     "vsize",               A_DEFLONG,0);    n2reklama();    n2addfklass("242.glplain");	}void nnato_assist(NNato *x, void *b, long msg, long nr, char *s){	if (msg == 1)      // !nlet	   strcpy( s, m9ndfukcpropaganda00);       {	   if (msg == 2)   // outlet	      if (nr == 0)	         strcpy( s, n2gltypestr);  // default `gl data type` outlet de[a]ss!zt--	   }}void nnato_info(NNato *x, void *p, void *b){      n2info();}void *nnato_new(){    NNato      *x;	short      err;	x = (NNato *)newobject(nnato_class);    n2addoutlet(x,&x->glout);        if (err = n2objinit(x))       { post("242.glplain :  n2initobjekt err = %ld",err); return;}     n2objsetglregister(x,(method)nnato_glregister);   // zpecify gl regizter routine    n2objsetglfun(x,(method)nnato_glfun);             // zpecify gl drau routine    nnato_revert(x);    post("revert bypassed",0);    nnato_vectinit(x);    post("vectinited",0);			x->on = true;	return (x);   ikk:	nnato_free(x);}void nnato_free(NNato *x){       n2objfree(x);}void nnato_on(NNato *x, long flag){        x->on = flag;}  void nnato_int(NNato *x, long n)    {								       if (!n) x->on = false;   else x->on = true;}void nnato_bang(NNato *x){   n2gldraw(x, n2objtype);}void nnato_variant(NNato *x, short variant){   if (!variant) n2objsetglfun(x,(method)nnato_glfun);   else if (variant==1) n2objsetglfun(x,(method)nnato_glfun2);   else if (variant==2) n2objsetglfun(x,(method)nnato_glfun3);}void nnato_type(NNato *x, short type){   if (type >= 0 && type <= 9) x->type = type;}void nnato_klr(NNato *x, long red, long green, long blue){   x->red   = (float)red   * 0.01;   x->green = (float)green * 0.01;   x->blue  = (float)blue  * 0.01;      }  void nnato_normalz(NNato *x, long koordx, long koordy, long koordz){   x->normalx  = (float)koordx * 0.01;   x->normaly  = (float)koordy * 0.01;   x->normalz  = (float)koordz * 0.01;      }  void nnato_shademodel(NNato *x, long type){   if (type == 0) x->shademodel = GLU_SMOOTH;   else if (type == 1) x->shademodel = GLU_FLAT;   else if (type == 2) x->shademodel = GLU_NONE;}void nnato_vertex(NNato *x, long vertex, long vertex2){    x->vertex   = (float)vertex  * .01;    x->vertex2  = (float)vertex2 * .01;}			void nnato_texture(NNato *x, long flag){    x->texture = flag;}void nnato_revertgeo(NNato *x){	    x->vertex = x->vertex2 = .5;   }		void nnato_revert(NNato *x){		x->type = 6;	    x->vertex = x->vertex2 = .5;    x->shademodel = GLU_SMOOTH;     x->normalx = x->normaly = 0.0;    x->normalz = 1.0;        x->texture = true;    nnato_klr(x,50,50,50);        x->vsize=64;    x->factor=0.1;    x->ignt=false;    x->i=0;}void nnato_vectinit(NNato *x){	register short i;		if (!(x->vsize>MAXVECTOR))	{		for(i=0;i < MAXVECTOR; i++)		{			x->vector[i]=0.; 			post("vect-%ld = 0.",i);		}	}}void nnato_vectset(NNato *x, short index, float z){int i;if (!x->ignt)   {	for (i =0; i<MAXVECTOR, i++;) {	x->vector[i]=z;	}	x->ignt=true;	post("xignitd",0);   }		x->vector[index]=z;//	post("setting vector[%ld]=[%4f]", index, z);//	x->i += 1;}void nnato_vectauti(NNato *x, short flag){}void nnato_factor(NNato *x, float flag){	x->factor=flag;	post("setting factor=[%4f]", flag);}void nnato_vectsize(NNato *x, short flag){	x->vsize=flag;	post("setting vsize=[%ld]", flag);}void nnato_glfun(n2glatom glatom){    NNato *x = (NNato *)n2getglatomobj(glatom);	int		i, COLS = x->vsize;    float  a  = x->vertex,           b  = x->vertex2,           TILE_COLS = 1.0/COLS,           temp, factor=x->factor;                               if (!x->on) return;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);//    glTranslatef(-COLS / 2.0 + .5, 0., 0.);    for (i = 0; i < COLS; i++)     {		temp = x->vector[i];		        glPushMatrix();        glTranslatef(i*factor, 0, 0);        glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);	 	if (x->texture)	 	   {		        glTexCoord2f(0.0f, 0.0f);	                glVertex3f(-a, -b, temp);		        glTexCoord2f(1.0f, 0.0f);	                glVertex3f( a, -b, temp);		        glTexCoord2f(1.0f, 1.0f);	                glVertex3f( a, b, temp);		        glTexCoord2f(0.0f, 1.0f);	                glVertex3f(-a, b, temp);	 	   }	 	else	 	   {	                glVertex3f(-a, -b, temp);	                glVertex3f( a, -b, temp);	                glVertex3f( a, b, temp);	                glVertex3f(-a, b, temp);	       }		glEnd();        glPopMatrix();	}}     void nnato_glfun2(n2glatom glatom){    NNato *x = (NNato *)n2getglatomobj(glatom);	int		i, COLS = x->vsize;    float  a  = x->vertex,           b  = x->vertex2,           TILE_COLS = 1.0/COLS,           temp, factor=x->factor,           temp1;                               if (!x->on) return;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);//    glTranslatef(-COLS / 2.0 + .5, 0., 0.);        glPushMatrix();//        glTranslatef(i*factor, 0, 0);        glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);    for (i = 0; i < COLS; i++)     {		temp = x->vector[i];		if (!i==COLS-1)		temp1 = x->vector[i+1];			 	if (x->texture)	 	   {		        glTexCoord2f(0.0f, 0.0f);	                glVertex3f(-a, -b, temp);		        glTexCoord2f(1.0f, 0.0f);	                glVertex3f( a, -b, temp);		        glTexCoord2f(1.0f, 1.0f);	                glVertex3f( a, b, temp);		        glTexCoord2f(0.0f, 1.0f);	                glVertex3f(-a, b, temp);	 	   }	 	else	 	   {	                glVertex3f(-a, -b, temp);	                glVertex3f( a, -b, temp);	                glVertex3f( a, b, temp);	                glVertex3f(-a, b, temp);	       }		glEnd();        glPopMatrix();	}}     void nnato_glfun3(n2glatom glatom){    NNato *x = (NNato *)n2getglatomobj(glatom);	int		i, COLS = x->vsize;    float  a  = x->vertex,           b  = x->vertex2,           TILE_COLS = 1.0/COLS,           temp, factor=x->factor,           temp1, atemp, btemp;                               if (!x->on) return;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);//    glTranslatef(-COLS / 2.0 + .5, 0., 0.);        glPushMatrix();        glTranslatef(i*factor, 0, 0);        glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);    for (i = 0; i < COLS; i++)     {		temp = x->vector[i];		if (!i==COLS-1)		temp1 = x->vector[i+1];			 	if (x->texture)	 	   {		        glTexCoord2f(0.0f, 0.0f);	                glVertex3f(-a, -b, temp);		        glTexCoord2f(1.0f, 0.0f);	                glVertex3f( a, -b, temp);		        glTexCoord2f(1.0f, 1.0f);	                glVertex3f( a, b, temp);		        glTexCoord2f(0.0f, 1.0f);	                glVertex3f(-a, b, temp);	 	   }	 	else	 	   {	                glVertex3f(-a, -b, temp);	                glVertex3f( a, -b, temp);	                glVertex3f( a, b, temp);	                glVertex3f(-a, b, temp);	       }		glEnd();        glPopMatrix();	}}     void nnato_glregister(NNato *x, void *klientz){    n2glregisterx(x,n2objtype,x->glout,klientz);  // bkom 01 klient ov gl alimentari data}			