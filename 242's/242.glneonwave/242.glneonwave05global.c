/*242.glneonwavea 3d multislider wannabe. algumas notas: passar vectores para globais*/#include "Movies.h"#include "ext_common.h"#include "ext.h"#include "ext_user.h"#include "n2.basicstrings.c"#include "n2.0000.h"#include "agl.h"#include "GL/glut.h" #include "math.h"#include <stdlib.h> #define SQRTOFTWOINV 1.0 / 1.414213562#ifndef M_PI//#define M_PI 3.14159265358979323846#define M_PI n2mathpi#endif/*	#if defined(GL_EXT_texture_object) && !defined(GL_VERSION_1_1)	#define glBindTexture(A,B)     glBindTextureEXT(A,B)	#define glGenTextures(A,B)     glGenTexturesEXT(A,B)	#endif	#if defined(GL_EXT_polygon_offset) && !defined(GL_VERSION_1_1)	#define glPolygonOffset(A,B)     glPolygonOffsetEXT(A,B)	/* OpenGL 1.1's polygon offset can be different for each	   polygon mode primitive type.  The EXT extension has	   only one offset. *//*	#define GL_POLYGON_OFFSET_FILL   GL_POLYGON_OFFSET_EXT	#endif*//* grid */#define MAXGRID 63enum {WIREFRAME, HIDDENLINE, FLATSHADED, SMOOTHSHADED, TEXTURED};enum {FULLSCREEN, FACENORMALS, ANTIALIAS, ENVMAP};enum {WEAK, NORMAL, STRONG};enum {SMALL, MEDIUM, LARGE, XLARGE};enum {CURRENT, FLAT, SPIKE, DIAGONALWALL, SIDEWALL, HOLE,       MIDDLEBLOCK, DIAGONALBLOCK, CORNERBLOCK, HILL, HILLFOUR};typedef struct zttz {	Object    n_ob; 	void     *n2hdr;    	    void   	 *glout;    short     type;    long      variant;    Boolean        on,  waving, editing, 		\	     			drawFaceNorms, antialias, envMap;	int displayMode, resetMode;	int grid;	float dt;	float sphi, stheta;	float sdepth;	float zNear, zFar;	float aspect;	long xsize, ysize;	int downX, downY;											// 2 dim plane	float 		force[MAXGRID][MAXGRID],			//our force	      		veloc[MAXGRID][MAXGRID],			//our velocity	      		posit[MAXGRID][MAXGRID],			//position	      		vertNorms[MAXGRID][MAXGRID][3],		//normals	      		faceNorms[2][MAXGRID][MAXGRID][3],  //facenormals	      		faceNormSegs[2][2][MAXGRID][MAXGRID][3];//facenormal segments	      					/*	bool waving = false, editing = false, 				     drawFaceNorms = false, antialias = false,				     envMap = false;			*/		float texCoords[MAXGRID][MAXGRID][2];//texture coordinates			/*			float sphi=90.0, stheta=45.0;			float sdepth = 5.0/4.0 * MAXGRID;			float zNear=15.0, zFar=100.0;			float aspect = 5.0/4.0;			long xsize, ysize;			int downX, downY;			*/} NNato;void *nnato_new(void);void nnato_assist(NNato *x, void *b, long msg, long nr, char *s);void nnato_info(NNato *x, void *p, void *b);void nnato_free(NNato *x);void nnato_on(NNato *x, long flag);void nnato_bang(NNato *x);void nnato_int(NNato *x, long n);   void nnato_variant(NNato *x, short variant);void nnato_ignit(NNato *x);	// bootvoid nnato_boot_vectors(NNato *x);void nnato_revert(NNato *x);//vector void copy(float vec0[3], float vec1[3]);void sub(float vec0[3], float vec1[3], float vec2[3]);void add(float vec0[3], float vec1[3], float vec2[3]);void scalDiv(float vec[3], float c);void cross(float vec0[3], float vec1[3], float vec2[3]);void norm(float vec[3]);void set(float vec[3], float x, float y, float z);//gl funcsvoid getforce(NNato *x);void getvelocity(NNato *x);void getposition(NNato *x);void getFaceNorms(NNato *x);void getVertNorms(NNato *x);void getFaceNormSegs(NNato *x);void getFaceNormSegs(NNato *x);void getTexCoords(NNato *x);void wave(NNato *x);void go(NNato *x);void stop(NNato *x);void reverse(NNato *x);void reset(NNato *x,int value);void setSize(NNato *x, int value);void setSpeed(NNato *x,int value);void setDisplay(NNato *x, int value);//void setMain(NNato *x, int value);void drawFaceNormals(NNato *x);void drawSmoothShaded(NNato *x);void drawWireframe(NNato *x);void drawFlatShaded(NNato *x);void drawHiddenLine(NNato *x);void drawTextured(NNato *x);void nnato_drawFaceNorms(NNato *x, long flag);void nnato_displayMode(NNato *x, long flag);void nnato_waving(NNato *x, long flag);void nnato_sdepth(NNato *x, float flag);void nnato_dt(NNato *x, float flag);void nnato_glfun(n2glatom glatom);void nnato_glregister(NNato *x, void *klientz);double ran(void);double alea(double min, double max);//globaisfloat 		force[MAXGRID][MAXGRID];			        //our forcefloat	    veloc[MAXGRID][MAXGRID];			        //our velocityfloat	    posit[MAXGRID][MAXGRID];			        //positionfloat	    vertNorms[MAXGRID][MAXGRID][3];				//normalsfloat	    faceNorms[2][MAXGRID][MAXGRID][3];  		//facenormalsfloat	    faceNormSegs[2][2][MAXGRID][MAXGRID][3];	//facenormal segmentsfloat 		texCoords[MAXGRID][MAXGRID][2];				//texture coordinatesvoid    *nnato_class;main(){	setup(&nnato_class, nnato_new, (method)nnato_free, (short)sizeof(NNato), 0L, 0L, 0); 	addmess((method)nnato_assist,	                  "assist",          	A_CANT,0); 	addmess((method)nnato_info,	                      "info",		        A_CANT,0);    n2objaddglcmd();    n2addstatecmd((method)nnato_int,(method)nnato_bang,                  (method)nnato_on,-1,-1,-1,-1,(method)nnato_variant,0);    addmess((method)nnato_revert,                     "revert",             0);    addmess((method)nnato_drawFaceNorms,              "face_norms",        A_DEFLONG,0);    addmess((method)nnato_displayMode,                "displayMode",       A_DEFLONG,0);    addmess((method)nnato_waving,                	  "wave",              A_DEFLONG,0);    addmess((method)nnato_sdepth,                	  "sdepth",            A_DEFFLOAT,0);    addmess((method)nnato_dt,                	      "dt",            A_DEFFLOAT,0);    post ("    242.glneonwave - sier02 - ported from Erik Larsen", 0);    n2addfklass("242.glneonwave");	//    post (" Newave - Ported from the original IrisGL SGI demo \n//          (see https://www.sgi.com/toolbox/src/) \n//\n// I've ported an old IrisGL demo, newave, to OpenGL and GLUT.  \n// This port has a couple of new features compared to the  \n// \"ancient\" GL demo: \n//\n//     * environment mapping (very cool!)\n//     * texture mapping\n//     * line antialiasing (needs some work)\n//     * better wave propagation\n// \n// I haven't implemented the mesh editing found in the old demo. \n//\n// By default the program loads \"texmap.rgb\" and \"spheremap.rgb\"\n// if no filenames are given as command line arguments.  \n// Specify the texture map as the first argument and the sphere\n// map as the second argument.\n//\n// Left mouse rotates the scene, middle mouse or +/- keys zoom, \n// right mouse for menu. \n//\n// Erik Larsen\n// cayman@sprintmail.com\n",0)}void nnato_assist(NNato *x, void *b, long msg, long nr, char *s){	if (msg == 1)      // !nlet	   strcpy( s,m9ndfukcpropaganda00);       {	   if (msg == 2)   // outlet	      if (nr == 0)	         strcpy( s, n2gltypestr);  // default `gl data type` outlet de[a]ss!zt--	   }}void nnato_info(NNato *x, void *p, void *b){	n2info(); }void *nnato_new(){    NNato      *x;	short      err;	x = (NNato *)newobject(nnato_class);    n2addoutlet(x,&x->glout);        if (err = n2objinit(x))       { post("242.glneonwave :  n2initobjekt err = %ld",err); return;} //no boot//	nnato_boot_vectors(x);    n2objsetglregister(x,(method)nnato_glregister);   // zpecify gl regizter routine    n2objsetglfun(x,(method)nnato_glfun);             // zpecify gl drau routine	post("glneonwave:zpecified gl regizter routine, gl drau routine",0);	nnato_ignit(x);	// boot    nnato_revert(x);			x->on = true;	return (x);   ikk:	nnato_free(x);}void nnato_free(NNato *x){       n2objfree(x);}void nnato_ignit(NNato *x){   	x->displayMode = WIREFRAME;	x->resetMode = DIAGONALBLOCK;	x->grid = 17;	x->dt = 0.004;	x->sphi=90.0;	x->stheta=45.0;	x->sdepth= 5.0/4.0 * MAXGRID;	x->zNear=15.0;	x->zFar=100.0;	x->aspect=5.0/4.0;    setSize(x,MEDIUM);    setSpeed(x,NORMAL);    setDisplay(x,TEXTURED);//    setOther(x,ENVMAP);    reset(x,HILLFOUR);//	x->type = 6;	//    x->shademodel = GLU_SMOOTH;     //    x->texture = true; //   nnato_klr(x,50,50,50);	x->waving = 0;	}void nnato_boot_vectors(NNato *x){	register short i,j,k,l,m;	int a=0;	for (i=0; i<MAXGRID;i++)	for (j=0; j<MAXGRID;j++)  {		 x->force[i][j]=0.0f;a++;	}	post("force[%ld][%ld]=[%f]", i, j, x->force[i][j],0);		for (i=0; i<MAXGRID;i++)	for (j=0; j<MAXGRID;j++)  {		 x->veloc[i][j]=0.0f;a++;	}	post("veloc[%ld][%ld]=[%f]", i, j, x->veloc[i][j],0);		for (i=0; i<MAXGRID;i++)	for (j=0; j<MAXGRID;j++)  {		 x->posit[i][j]=0.0f;a++;	}	post("posit[%ld][%ld]=[%f]", i, j, x->posit[i][j],0);	for (i=0; i<MAXGRID;i++)	for (j=0; j<MAXGRID;j++) 		for (k=0; k<3;      k++) {	 x->vertNorms[i][j][k]=0.0f;a++;	}	post("x->vertNorms[%ld][%ld][0,1,2]=[%f]", i, j, x->vertNorms[i][j][0],0);		for (i=0; i<2;      i++)	for (j=0; j<MAXGRID;j++)	for (k=0; k<MAXGRID;k++)	for (l=0; l<3;      l++)  {		 x->faceNorms[i][j][k][l]=0.0f;a++;	}	post("x->faceNorms[0,1][%ld][%ld][0,1,2]=[%f]", i, j, x->faceNorms[0][i][j][0],0);		for (k=0; i<2;      k++)	for (l=0; i<2;      l++)	for (i=0; i<MAXGRID;i++)	for (j=0; j<MAXGRID;j++)	for (m=0; m<3;      m++)  {		 x->faceNormSegs[k][l][i][j][m]=0.0f;a++;	}	post("x->faceNormSegs[0,1][0,1][%ld][%ld][0,1,2]=[%f]", i, j, x->faceNormSegs[0][0][i][j][0],0);	for (i=0; i<MAXGRID;i++)	for (j=0; j<MAXGRID;j++)	for (m=0; m<3;      m++)  {		 x->texCoords[i][j][m]=0.0f;a++;	}	post("x->texCoords[%ld][%ld][0,1,2]=[%f]", i, j, x->texCoords[i][j][0],0);	post("x->bigvectors ignited to %ld zeroes!",a,0);}void getforce(NNato *x)	//force, posit globais{    float d;     int i, j;    for(i=0;i < x->grid; i++)         for(j=0; j < x->grid; j++)         {            force[i][j]=0.0;        }    for(i=2;i<x->grid-2;i++)        for(j=2;j<x->grid-2;j++)         {            d=posit[i][j]-posit[i][j-1];            force[i][j] -= d;            force[i][j-1] += d;            d=posit[i][j]-posit[i-1][j];            force[i][j] -= d;            force[i-1][j] += d;            d= (posit[i][j]-posit[i][j+1]);             force[i][j] -= d ;            force[i][j+1] += d;            d= (posit[i][j]-posit[i+1][j]);             force[i][j] -= d ;            force[i+1][j] += d;            d= (posit[i][j]-posit[i+1][j+1])*SQRTOFTWOINV;             force[i][j] -= d ;            force[i+1][j+1] += d;            d= (posit[i][j]-posit[i-1][j-1])*SQRTOFTWOINV;             force[i][j] -= d ;            force[i-1][j-1] += d;            d= (posit[i][j]-posit[i+1][j-1])*SQRTOFTWOINV;             force[i][j] -= d ;            force[i+1][j-1] += d;            d= (posit[i][j]-posit[i-1][j+1])*SQRTOFTWOINV;             force[i][j] -= d ;            force[i- 1][j+1] += d;        }}void getvelocity(NNato *x) //velocity, force global{	int i,j;    for(i=0;i<x->grid;i++)        for(j=0;j<x->grid;j++)            veloc[i][j] += force[i][j] * x->dt;}void getposition(NNato *x) //posit, veloc{  	int i,j;    for(i=0;i<x->grid;i++)        for(j=0;j<x->grid;j++)            posit[i][j] += veloc[i][j];}/* face normals - for flat shading */void getFaceNorms(NNato *x){	int i,j;    float vec0[3], vec1[3], vec2[3], norm0[3], norm1[3];    float geom0[3], geom1[3], geom2[3], geom3[3];    for (i = 0; i < x->grid-1; ++i)    {        for (j = 0; j < x->grid-1; ++j)        {            /* get vectors from geometry points */            geom0[0] = i; geom0[1] = j; geom0[2] = posit[i][j];            geom1[0] = i; geom1[1] = j+1; geom1[2] = posit[i][j+1];            geom2[0] = i+1; geom2[1] = j; geom2[2] = posit[i+1][j];            geom3[0] = i+1; geom3[1] = j+1; geom3[2] = posit[i+1][j+1];            sub( vec0, geom1, geom0 );            sub( vec1, geom1, geom2 );            sub( vec2, geom1, geom3 );            /* get triangle face normals from vectors & normalize them */            cross( norm0, vec0, vec1 );            norm( norm0 );            cross( norm1, vec1, vec2 );             norm( norm1 );            copy( faceNorms[0][i][j], norm0 );            copy( faceNorms[1][i][j], norm1 );        }    }}/* vertex normals - average of face normals for smooth shading */void getVertNorms(NNato *x){	int i,j;    float avg[3];    for (i = 0; i < x->grid; ++i)    {        for (j = 0; j < x->grid; ++j)        {            /* For each vertex, average normals from all faces sharing */            /* vertex.  Check each quadrant in turn */            set(avg, 0.0, 0.0, 0.0);            /* Right & above */            if (j < x->grid-1 && i < x->grid-1)            {                add( avg, avg, faceNorms[0][i][j] );            }            /* Right & below */            if (j < x->grid-1 && i > 0)            {                add( avg, avg, faceNorms[0][i-1][j] );                add( avg, avg, faceNorms[1][i-1][j] );            }            /* Left & above */            if (j > 0 && i < x->grid-1)            {                add( avg, avg, faceNorms[0][i][j-1] );                add( avg, avg, faceNorms[1][i][j-1] );            }            /* Left & below */            if (j > 0 && i > 0)            {                add( avg, avg, faceNorms[1][i-1][j-1] );            }            /* Normalize */            norm( avg );            copy( vertNorms[i][j], avg );        }    }}void getFaceNormSegs(NNato *x){	int i,j;    float center0[3], center1[3], normSeg0[3], normSeg1[3];    float geom0[3], geom1[3], geom2[3], geom3[3];     for (i = 0; i < x->grid - 1; ++i)    {        for (j = 0; j < x->grid - 1; ++j)        {            geom0[0] = i; geom0[1] = j; geom0[2] = posit[i][j];            geom1[0] = i; geom1[1] = j+1; geom1[2] = posit[i][j+1];            geom2[0] = i+1; geom2[1] = j; geom2[2] = posit[i+1][j];            geom3[0] = i+1; geom3[1] = j+1; geom3[2] = posit[i+1][j+1];            /* find center of triangle face by averaging three vertices */            add( center0, geom2, geom0 );            add( center0, center0, geom1 );            scalDiv( center0, 3.0 );            add( center1, geom2, geom1 );            add( center1, center1, geom3 );            scalDiv( center1, 3.0 );            /* translate normal to center of triangle face to get normal segment */            add( normSeg0, center0, faceNorms[0][i][j] );            add( normSeg1, center1, faceNorms[1][i][j] );            copy( faceNormSegs[0][0][i][j], center0 );            copy( faceNormSegs[1][0][i][j], center1 );            copy( faceNormSegs[0][1][i][j], normSeg0 );            copy( faceNormSegs[1][1][i][j], normSeg1 );        }    }}void getTexCoords(NNato *x){	int i,j;    for (i = 0; i < x->grid; ++i)    {        for (j = 0; j < x->grid; ++j)        {            texCoords[i][j][0] = (float)j/(float)(x->grid-1);            texCoords[i][j][1] = (float)i/(float)(x->grid-1);        }    }}void wave(NNato *x){/* *   if (x->waving) *   { *       getforce(x); *       getvelocity(x); *       getposition(x); *       glutPostRedisplay(); *   } */ }void go(NNato *x){    x->waving = true;    x->editing = false;//    glutIdleFunc(wave);}void stop(NNato *x){    x->waving = false;//    glutIdleFunc(NULL);}/*void edit(void){    stop();    editing = true;}*/void reverse(NNato *x){	int i,j;    for(i=1;i<(x->grid-1);i++)        for(j=1;j<(x->grid-1);j++)            veloc[i][j]= -veloc[i][j];    if (!x->waving)        go(x);}void reset(NNato *x,int value){	int i,j;    if (x->waving)        stop(x);    if (value != CURRENT)        x->resetMode = value;            for(i=0;i<x->grid;i++)        for(j=0;j<x->grid;j++)        {            force[i][j]=0.0;            veloc[i][j]=0.0;            switch(x->resetMode)            {            case FLAT:                posit[i][j] = 0.0;                break;            case SPIKE:                 posit[i][j]= (i==j && i == x->grid/2) ? x->grid*1.5 : 0.0;                break;            case HOLE:                posit[i][j]= (!((i > x->grid/3 && j > x->grid/3)&&(i < x->grid*2/3 && j < x->grid*2/3))) ? x->grid/4 : 0.0;                break;            case DIAGONALWALL:                posit[i][j]= (((x->grid-i)-j<3) && ((x->grid-i)-j>0)) ? x->grid/6 : 0.0;                break;            case SIDEWALL:                posit[i][j]= (i==1) ? x->grid/4 : 0.0;                break;            case DIAGONALBLOCK:                posit[i][j]= ((x->grid-i)-j<3) ? x->grid/6 : 0.0;                break;            case MIDDLEBLOCK:                posit[i][j]= ((i > x->grid/3 && j > x->grid/3)&&(i < x->grid*2/3 && j < x->grid*2/3)) ? x->grid/4 : 0.0;                break;            case CORNERBLOCK:                posit[i][j]= ((i > x->grid*3/4 && j > x->grid*3/4)) ? x->grid/4 : 0.0;                break;            case HILL:                posit[i][j]=                     (sin(M_PI * ((float)i/(float)x->grid)) +                     sin(M_PI * ((float)j/(float)x->grid)))* x->grid/6.0;            break;                    case HILLFOUR:                posit[i][j]=                     (sin(M_PI*2 * ((float)i/(float)x->grid)) +                     sin(M_PI*2 * ((float)j/(float)x->grid)))* x->grid/6.0;            break;                    }            if (i==0||j==0||i==x->grid-1||j==x->grid-1) posit[i][j]=0.0;        }//    glutPostRedisplay();}void setSize(NNato *x, int value){    int prevGrid = x->grid;    switch(value)     {        case SMALL : x->grid = MAXGRID/4; break;        case MEDIUM: x->grid = MAXGRID/2; break;        case LARGE : x->grid = MAXGRID/1.5; break;        case XLARGE : x->grid = MAXGRID; break;    }    if (prevGrid > x->grid)    {        reset(x,x->resetMode);    }    x->zNear= x->grid/10.0;    x->zFar= x->grid*3.0;    x->sdepth = 5.0/4.0 * x->grid;    getTexCoords(x);//    glutPostRedisplay();}void setSpeed(NNato *x,int value){    switch(value)     {        case WEAK  : x->dt = 0.001; break;        case NORMAL: x->dt = 0.004; break;        case STRONG: x->dt = 0.008; break;    }}void setDisplay(NNato *x, int value){    x->displayMode = value;    switch(value)     {        case WIREFRAME   :             glShadeModel(GL_FLAT);             glDisable(GL_LIGHTING);            break;        case HIDDENLINE:             glShadeModel(GL_FLAT);             glDisable(GL_LIGHTING);            break;        case FLATSHADED  :             glShadeModel(GL_FLAT);             glEnable(GL_LIGHTING);            break;        case SMOOTHSHADED:             glShadeModel(GL_SMOOTH);             glEnable(GL_LIGHTING);            break;        case TEXTURED:             glShadeModel(GL_SMOOTH);             glEnable(GL_LIGHTING);            break;    }//    glutPostRedisplay();}/*void setOther(int value){    switch (value)    {        case FULLSCREEN:             glutFullScreen();            break;        case FACENORMALS:             drawFaceNorms = !drawFaceNorms;            break;        case ANTIALIAS:             antialias = !antialias;            if (antialias)            {                glEnable(GL_BLEND);                glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);                glEnable(GL_LINE_SMOOTH);                glLineWidth(1.5);            }            else            {                glDisable(GL_BLEND);                glDisable(GL_LINE_SMOOTH);                glLineWidth(1.0);            }            break;        case ENVMAP:             envMap = !envMap;            if (envMap)            {                glBindTexture(GL_TEXTURE_2D, texId2);                glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);                glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);                glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);                glEnable(GL_TEXTURE_GEN_S);                glEnable(GL_TEXTURE_GEN_T);            }            else            {                glBindTexture(GL_TEXTURE_2D, texId1);                glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);                glDisable(GL_TEXTURE_GEN_S);                glDisable(GL_TEXTURE_GEN_T);            }            break;    }    glutPostRedisplay();}*//*void setMain(NNato *x, int value){    switch(value)     { //       case 1: edit(x);    break;        case 2:    go(x);      break; /* set idle func to something *//*        case 3: stop(x);    break; /* set idle func to null *//*        case 4:    reverse(x); break;        case 5:    exit(0);   break;    }}*/void drawFaceNormals(NNato *x){	int i,j;    glColor3f(1.0,1.0,1.0);    for (i = 0; i < x->grid - 1; ++i)    {        for (j = 0; j < x->grid - 1; ++j)        {            glBegin(GL_LINES);            glVertex3fv(faceNormSegs[0][0][i][j]);            glVertex3fv(faceNormSegs[0][1][i][j]);            glEnd();            glBegin(GL_LINES);            glVertex3fv(faceNormSegs[1][0][i][j]);            glVertex3fv(faceNormSegs[1][1][i][j]);            glEnd();        }    }}void drawSmoothShaded(NNato *x){	int i,j;    glColor3f(0.8f, 0.2f, 0.8f);    for (i = 0; i < x->grid - 1; ++i)    {        glBegin(GL_TRIANGLE_STRIP);        for (j = 0; j < x->grid; ++j)        {            glNormal3fv( vertNorms[i][j] );            glVertex3f( i, j, posit[i][j] );            glNormal3fv( vertNorms[i+1][j] );            glVertex3f( i+1, j, posit[i+1][j] );        }        glEnd();    }}void drawWireframe(NNato *x){	int i,j;    glColor3f(1.0, 1.0, 1.0);    for(i=0;i<x->grid;i++)    {        glBegin(GL_LINE_STRIP);        for(j=0;j<x->grid;j++)            glVertex3f( (float) i, (float) j, (float) posit[i][j]);        glEnd();    }        for(i=0;i<x->grid;i++)    {        glBegin(GL_LINE_STRIP);        for(j=0;j<x->grid;j++)            glVertex3f( (float) j, (float) i, (float) posit[j][i]);        glEnd();    }}void drawFlatShaded(NNato *x){	int i,j;    glEnable(GL_POLYGON_OFFSET_FILL);    glColor3f(0.8f, 0.2f, 0.8f);    for (i = 0; i < x->grid - 1; ++i)    {        glBegin(GL_TRIANGLE_STRIP);        glVertex3f( (float) i, (float) 0, (float) posit[i][0]);        glVertex3f( (float) i+1, (float) 0, (float) posit[i+1][0]);        for (j = 1; j < x->grid; ++j)        {            glNormal3fv( faceNorms[0][i][j-1] );            glVertex3f( (float) i, (float) j, (float) posit[i][j]);              glNormal3fv( faceNorms[1][i][j-1] );            glVertex3f( (float) i+1, (float) j, (float) posit[i+1][j]);        }        glEnd();    }    glDisable(GL_POLYGON_OFFSET_FILL);}void drawHiddenLine(NNato *x){	int i,j;    glEnable(GL_POLYGON_OFFSET_FILL);    glColor3f(0.8f, 0.2f, 0.8f);    for (i = 0; i < x->grid - 1; ++i)    {        glBegin(GL_TRIANGLE_STRIP);        glVertex3f( (float) i, (float) 0, (float) posit[i][0]);        glVertex3f( (float) i+1, (float) 0, (float) posit[i+1][0]);        for (j = 1; j < x->grid; ++j)        {            glVertex3f( (float) i, (float) j, (float) posit[i][j]);            glVertex3f( (float) i+1, (float) j, (float) posit[i+1][j]);        }        glEnd();    }        glDisable(GL_POLYGON_OFFSET_FILL);        glColor3f(1.0,1.0,1.0);    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);    for (i = 0; i < x->grid - 1; ++i)    {        glBegin(GL_TRIANGLE_STRIP);        glVertex3f( (float) i, (float) 0, (float) posit[i][0]);        glVertex3f( (float) i+1, (float) 0, (float) posit[i+1][0]);        for (j = 1; j < x->grid; ++j)        {            glVertex3f( (float) i, (float) j, (float) posit[i][j]);            glVertex3f( (float) i+1, (float) j, (float) posit[i+1][j]);        }        glEnd();    }        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);}void drawTextured(NNato *x){	int i,j;    glColor3f(1.0f, 1.0f, 1.0f);    glEnable(GL_TEXTURE_2D);    for (i = 0; i < x->grid - 1; ++i)    {        glBegin(GL_TRIANGLE_STRIP);        for (j = 0; j < x->grid; ++j)        {            glNormal3fv( vertNorms[i][j] );            glTexCoord2fv( texCoords[i][j] );            glVertex3f( i, j, posit[i][j] );            glNormal3fv( vertNorms[i+1][j] );            glTexCoord2fv( texCoords[i+1][j] );            glVertex3f( i+1, j, posit[i+1][j] );        }        glEnd();    }    glDisable(GL_TEXTURE_2D);} void nnato_on(NNato *x, long flag){        x->on = flag;}  void nnato_int(NNato *x, long n)    {								       if (!n) x->on = false;   else x->on = true;}void nnato_bang(NNato *x){   n2gldraw(x, n2objtype);}void nnato_variant(NNato *x, short variant){   if (!variant) n2objsetglfun(x,(method)nnato_glfun);}void nnato_revert(NNato *x){	//    nnato_klr(x,50,50,50);}void nnato_drawFaceNorms(NNato *x, long flag){        x->drawFaceNorms = flag;}  void nnato_displayMode(NNato *x, long flag){        x->displayMode = flag;}  void nnato_waving(NNato *x, long flag){        x->waving = flag;}  void nnato_sdepth(NNato *x, float flag){        x->sdepth = flag;}  void nnato_dt(NNato *x, float flag){        x->dt = 0.01*flag;}  void nnato_glfun(n2glatom glatom)				//{    NNato *x = (NNato *)n2getglatomobj(glatom);            int	   i, j;    float  aspect  = x->aspect,           zNear  = x->zNear,		   zFar = x->zFar,           sdepth = x->sdepth,           stheta = x->stheta,           sphi = x->sphi;    	int	   grid = x->grid;    if (!x->on) return; //    glShadeModel(x->shademodel);/*    glEnable(GL_DEPTH_TEST); *   glDepthFunc(GL_LEQUAL); *   glClearColor(0.0, 0.0, 0.0, 0.0); *   glPolygonOffset(1.0, 1.0); *   glEnable(GL_CULL_FACE); *   glHint(GL_LINE_SMOOTH_HINT, GL_NICEST); *   glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST); *   glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); *   glEnable(GL_COLOR_MATERIAL); *   glColorMaterial(GL_FRONT, GL_DIFFUSE); *    glLightfv (GL_LIGHT0, GL_POSITION, lightPosition); *   glEnable(GL_LIGHT0); */       glMatrixMode(GL_PROJECTION);    glLoadIdentity();    gluPerspective(64.0, aspect, zNear, zFar);    glMatrixMode(GL_MODELVIEW);    glLoadIdentity();     glTranslatef(0.0,0.0,-sdepth);    glRotatef(-stheta, 1.0, 0.0, 0.0);    glRotatef(sphi, 0.0, 0.0, 1.0);    glTranslatef(-(float)((grid+1)/2-1), -(float)((grid+1)/2-1), 0.0);    getFaceNorms(x);    getVertNorms(x);/* *   switch (x->displayMode)  *   { *       case WIREFRAME: drawWireframe(x); break; *       case HIDDENLINE: drawHiddenLine(x); break; *       case FLATSHADED: drawFlatShaded(x); break; *       case SMOOTHSHADED: drawSmoothShaded(x); break; *       case TEXTURED: drawTextured(x); break; *   } *///    if (!x->displayMode)//    	{ drawWireframe(x); }//    else if (x->displayMode ==1)//    	{ drawHiddenLine(x); }//    else if (x->displayMode ==2)//    	{ drawFlatShaded(x); }//    else if (x->displayMode ==3)//    	{ drawSmoothShaded(x); }//    else if (x->displayMode ==4)//    	{ drawTextured(x); }// to test, draw wireframe first and only    glColor3f(1.0, 1.0, 1.0);    for(i=0;i<x->grid;i++)    {        glBegin(GL_LINE_STRIP);        for(j=0;j<x->grid;j++)            glVertex3f( (float) i, (float) j, (float) posit[i][j]);        glEnd();    }        for(i=0;i<x->grid;i++)    {        glBegin(GL_LINE_STRIP);        for(j=0;j<x->grid;j++)            glVertex3f( (float) j, (float) i, (float) posit[j][i]);        glEnd();    }    if (x->drawFaceNorms)        {        getFaceNormSegs(x);        drawFaceNormals(x);    }    if (x->waving)    {        getforce(x);        getvelocity(x);        getposition(x);//        glutPostRedisplay();    } //   glutSwapBuffers(); //   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);}/*void nnato_glfun2(n2glatom glatom)		//random at gl rate & mod{    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS,           nr ;        if (!x->on) return;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {        glPushMatrix();        glTranslatef(i, j, 0);		if(j%x->step==x->result)        nr = ran() * x->dev + x->offset;        glRotatef(anglx, 1, 0, 0);        glRotatef(angly, 0, 1, 0);        glRotatef(anglz, 0, 0, 1);                glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        glTexCoord2f(i * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(-a, -b, nr);        glTexCoord2f((i + 1) * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(a, -b, nr);        glTexCoord2f((i + 1) * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(a, b, nr);        glTexCoord2f(i * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(-a, b, nr);        glEnd();        glPopMatrix();      }    }}*///void nnato_glfun(n2glatom glatom)				////{//    NNato *x = (NNato *)n2getglatomobj(glatom);//    //    //    int	   i, j;//    float  aspect  = x->aspect,//           zNear  = x->zNear,//		   zFar = x->zFar,//           sdepth = x->sdepth,//           stheta = x->stheta,//           sphi = x->sphi;// //   	int	   grid = x->grid;//////    if (!x->on) return;// ////    glShadeModel(x->shademodel);/////*    glEnable(GL_DEPTH_TEST);// *   glDepthFunc(GL_LEQUAL);// *   glClearColor(0.0, 0.0, 0.0, 0.0);// *   glPolygonOffset(1.0, 1.0);// *   glEnable(GL_CULL_FACE);// *   glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);// *   glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);// *   glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);// *   glEnable(GL_COLOR_MATERIAL);// *   glColorMaterial(GL_FRONT, GL_DIFFUSE);// *    glLightfv (GL_LIGHT0, GL_POSITION, lightPosition);// *   glEnable(GL_LIGHT0);// */   //    glMatrixMode(GL_PROJECTION);//    glLoadIdentity();//    gluPerspective(64.0, aspect, zNear, zFar);//    glMatrixMode(GL_MODELVIEW);//    glLoadIdentity(); ////    glTranslatef(0.0,0.0,-sdepth);//    glRotatef(-stheta, 1.0, 0.0, 0.0);//    glRotatef(sphi, 0.0, 0.0, 1.0);//    glTranslatef(-(float)((grid+1)/2-1), -(float)((grid+1)/2-1), 0.0);////    getFaceNorms(x);//    getVertNorms(x);/////*// *   switch (x->displayMode) // *   {// *       case WIREFRAME: drawWireframe(x); break;// *       case HIDDENLINE: drawHiddenLine(x); break;// *       case FLATSHADED: drawFlatShaded(x); break;// *       case SMOOTHSHADED: drawSmoothShaded(x); break;// *       case TEXTURED: drawTextured(x); break;// *   }// */////    if (!x->displayMode)//    	{ drawWireframe(x); }//    else if (x->displayMode ==1)//    	{ drawHiddenLine(x); }//    else if (x->displayMode ==2)//    	{ drawFlatShaded(x); }//    else if (x->displayMode ==3)//    	{ drawSmoothShaded(x); }//    else if (x->displayMode ==4)//    	{ drawTextured(x); }//////////    if (x->drawFaceNorms)    //    {//        getFaceNormSegs(x);//        drawFaceNormals(x);//    }//    if (x->waving)//    {//        getforce(x);//        getvelocity(x);//        getposition(x);////        glutPostRedisplay();//    }////// //   glutSwapBuffers();// //   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);//}void nnato_glregister(NNato *x, void *klientz){    n2glregisterx(x,n2objtype,x->glout,klientz);  // bkom 01 klient ov gl alimentari data}			double ran(void){		return(alea(0.0, 1.0));}double alea(double min, double max){	if (max >= min)		return ((max-min)*((double)rand()/RAND_MAX) + min);	else		return ((min-max)*((double)rand()/RAND_MAX) + max);	}// mathvoid copy(float vec0[3], float vec1[3]){    vec0[0] = vec1[0];    vec0[1] = vec1[1];    vec0[2] = vec1[2];}void sub(float vec0[3], float vec1[3], float vec2[3]){    vec0[0] = vec1[0] - vec2[0];    vec0[1] = vec1[1] - vec2[1];    vec0[2] = vec1[2] - vec2[2];}void add(float vec0[3], float vec1[3], float vec2[3]){    vec0[0] = vec1[0] + vec2[0];    vec0[1] = vec1[1] + vec2[1];    vec0[2] = vec1[2] + vec2[2];}void scalDiv(float vec[3], float c){    vec[0] /= c; vec[1] /= c; vec[2] /= c;}void cross(float vec0[3], float vec1[3], float vec2[3]){    vec0[0] = vec1[1] * vec2[2] - vec1[2] * vec2[1];    vec0[1] = vec1[2] * vec2[0] - vec1[0] * vec2[2];    vec0[2] = vec1[0] * vec2[1] - vec1[1] * vec2[0];}void norm(float vec[3]){    float c = sqrt(vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2]);    scalDiv(vec, c); }void set(float vec[3], float x, float y, float z){    vec[0] = x;    vec[1] = y;    vec[2] = z;}/*----------------------------------------------------------	EOF----------------------------------------------------------*/