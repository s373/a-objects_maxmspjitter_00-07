/*242.glneonwavea 3d multislider wannabe. algumas notas: passar vectores para globais Ã				remover zNear, zFar, aspect				passar a verdadeira rede 3ED	mexer no algoritmo da forca*/#include "Movies.h"#include "ext_common.h"#include "ext.h"#include "ext_user.h"#include "n2.basicstrings.c"#include "n2.0000.h"#include "agl.h"#include "GL/glut.h" #include "math.h"#include <stdlib.h> #define SQRTOFTWOINV 1.0 / 1.414213562#ifndef M_PI#define M_PI n2mathpi#endif#define MAXSIZE 256/* grid */#define MAXGRID 63enum {WIREFRAME, HIDDENLINE, FLATSHADED, SMOOTHSHADED, TEXTURED};enum {FULLSCREEN, FACENORMALS, ANTIALIAS, ENVMAP};enum {WEAK, NORMAL, STRONG};enum {SMALL, MEDIUM, LARGE, XLARGE};enum {CURRENT, FLAT, SPIKE, DIAGONALWALL, SIDEWALL, HOLE,       MIDDLEBLOCK, DIAGONALBLOCK, CORNERBLOCK, HILL, HILLFOUR};typedef struct zttz {	Object    n_ob; 	void     *n2hdr;    	    void   	 *glout;    short     type;    long      variant;    Boolean        on,  waving, editing, 		\	     			drawFaceNorms, antialias, envMap;	int displayMode, resetMode;	int grid;	float dt;	float sphi, stheta;	float sdepth;	float zNear, zFar;	float aspect;	int forcedepthcount, forcedepthamount;//counter forcas	long xsize, ysize;	int downX, downY;	Atom inlist[MAXSIZE];//desenhar posicoes centrais interpoladas	short drawsize, drawpositionx, drawpositiony;} NNato;void *nnato_new(void);void nnato_assist(NNato *x, void *b, long msg, long nr, char *s);void nnato_info(NNato *x, void *p, void *b);void nnato_free(NNato *x);void nnato_on(NNato *x, long flag);void nnato_bang(NNato *x);void nnato_int(NNato *x, long n);   void nnato_variant(NNato *x, short variant);void nnato_ignit(NNato *x);	// bootvoid nnato_revert(NNato *x);void nnato_drawFaceNorms(NNato *x, long flag);void nnato_displayMode(NNato *x, long flag);void nnato_waving(NNato *x, long flag);void nnato_sdepth(NNato *x, float flag);void nnato_stheta(NNato *x, float flag);void nnato_sphi(NNato *x, float flag);void nnato_dt(NNato *x, float flag);//void nnato_forzereset(NNato *x, float flag);//void nnato_toggleforze(NNato *x, int flag);void nnato_forzeamount(NNato *x, int flag);//gl funcsvoid getforce(NNato *x);void getvelocity(NNato *x);void getposition(NNato *x);void getFaceNorms(NNato *x);void getVertNorms(NNato *x);void getFaceNormSegs(NNato *x);//void getFaceNormSegs(NNato *x);void getTexCoords(NNato *x);void wave(NNato *x);void go(NNato *x);void stop(NNato *x);void reverse(NNato *x);void reset(NNato *x,int value);void setSize(NNato *x, int value);void setSpeed(NNato *x,int value);void setDisplay(NNato *x, int value);void drawFaceNormals(NNato *x);//void setMain(NNato *x, int value);void nnato_forzemess(NNato *x,Symbol *s, short argc, Atom *argv); //draw stuffvoid nnato_forzedrawsize(NNato *x, long flag);void nnato_forzedrawpositionx(NNato *x, long flag);void nnato_forzedrawpositiony(NNato *x, long flag);void nnato_forzefinger(NNato *x, long xx, long yy, float amount);void nnato_glfun(n2glatom glatom); 		//wireframevoid nnato_glfun2(n2glatom glatom);		//drawHiddenLinevoid nnato_glfun3(n2glatom glatom);		//drawFlatShadedvoid nnato_glfun4(n2glatom glatom);		//drawSmoothShadedvoid nnato_glfun5(n2glatom glatom);		//drawTexturedvoid nnato_glregister(NNato *x, void *klientz);//vector void copy(float vec0[3], float vec1[3]);void sub(float vec0[3], float vec1[3], float vec2[3]);void add(float vec0[3], float vec1[3], float vec2[3]);void scalDiv(float vec[3], float c);void cross(float vec0[3], float vec1[3], float vec2[3]);void norm(float vec[3]);void set(float vec[3], float x, float y, float z);//globaisfloat 		force[MAXGRID][MAXGRID];			        //our forcefloat	    veloc[MAXGRID][MAXGRID];			        //our velocityfloat	    posit[MAXGRID][MAXGRID];			        //positionfloat	    vertNorms[MAXGRID][MAXGRID][3];				//normalsfloat	    faceNorms[2][MAXGRID][MAXGRID][3];  		//facenormalsfloat	    faceNormSegs[2][2][MAXGRID][MAXGRID][3];	//facenormal segmentsfloat 		texCoords[MAXGRID][MAXGRID][2];				//texture coordinatesvoid    *nnato_class;void main (void){	setup(&nnato_class, nnato_new, (method)nnato_free, (short)sizeof(NNato), 0L, 0L, 0); 	addmess((method)nnato_assist,	                  "assist",          	A_CANT,0); 	addmess((method)nnato_info,	                      "info",		        A_CANT,0);    n2objaddglcmd();    n2addstatecmd((method)nnato_int,(method)nnato_bang,                  (method)nnato_on,-1,-1,-1,-1,(method)nnato_variant,0);    addmess((method)nnato_revert,                     "revert",             0);    addmess((method)nnato_drawFaceNorms,              "face_norms",        A_DEFLONG,0);    addmess((method)nnato_displayMode,                "displayMode",       A_DEFLONG,0);    addmess((method)nnato_waving,                	  "wave",              A_DEFLONG,0);    addmess((method)nnato_sdepth,                	  "sdepth",            A_DEFFLOAT,0);    addmess((method)nnato_stheta,                 "stheta",            A_DEFFLOAT,0);    addmess((method)nnato_sphi,                	  "sphi",            A_DEFFLOAT,0);    addmess((method)nnato_dt,                	      "dt",            A_DEFFLOAT,0);    addmess((method)reset,                			  "draw",       A_DEFLONG,0);    addmess((method)setSize,                		"size",       A_DEFLONG,0);    addmess((method)nnato_forzeamount,    "force_amount",   A_DEFLONG,0);    addmess((method)nnato_forzemess,    "list",   A_GIMME,0);    addmess((method)nnato_forzedrawpositionx,"x",A_DEFLONG,0);    addmess((method)nnato_forzedrawpositiony,"y",A_DEFLONG,0);    addmess((method)nnato_forzedrawsize,"drawsize",A_DEFLONG,0);    addmess((method)nnato_forzefinger,"finger",A_DEFLONG,A_DEFLONG,A_DEFFLOAT,0);//    addmess((method)nnato_toggleforze,   "toggleforce",   A_DEFLONG,0);    post ("    242.glneonwav3 - sier02 - ported from Erik Larsen port", 0);    post ("    of \"Ancient\" IrisGL SGI demo ", 0);    n2addfklass("242.glneonwav3");	}void nnato_assist(NNato *x, void *b, long msg, long nr, char *s){	if (msg == 1)      // !nlet	   strcpy( s,m9ndfukcpropaganda00);       {	   if (msg == 2)   // outlet	      if (nr == 0)	         strcpy( s, n2gltypestr);  // default `gl data type` outlet de[a]ss!zt--	   }}void nnato_info(NNato *x, void *p, void *b){	n2info(); }void *nnato_new(){    NNato      *x;	short      err;	x = (NNato *)newobject(nnato_class);    n2addoutlet(x,&x->glout);        if (err = n2objinit(x))       { post("242.glneonwave :  n2initobjekt err = %ld",err); return;} //no boot//	nnato_boot_vectors(x);    n2objsetglregister(x,(method)nnato_glregister);   // zpecify gl regizter routine    n2objsetglfun(x,(method)nnato_glfun);             // zpecify gl drau routine	post("glneonwave:zpecified gl regizter routine, gl drau routine",0);	nnato_ignit(x);	// boot    nnato_revert(x);			x->on = true;	return (x);   ikk:	nnato_free(x);}void nnato_free(NNato *x){       n2objfree(x);}void nnato_ignit(NNato *x){   	x->displayMode = WIREFRAME;	x->resetMode = DIAGONALBLOCK;	x->grid = 17;	x->dt = 0.004;	x->sphi=90.0;	x->stheta=45.0;//	x->sdepth= 5.0/4.0 * MAXGRID; //hard set to 1. or else scaling problems	x->sdepth= -12.0;	x->zNear=15.0;	x->zFar=100.0;	x->aspect=5.0/4.0;    setSize(x,MEDIUM);    setSpeed(x,NORMAL);    setDisplay(x,TEXTURED);//    setOther(x,ENVMAP);    reset(x,HILLFOUR);//	x->type = 6;	//    x->shademodel = GLU_SMOOTH;     //    x->texture = true; //   nnato_klr(x,50,50,50);	x->waving = 0;	x->variant = 4;//	x->forcerest = 0.0f;//	x->resetforce = 1;	x->forcedepthcount = 1;	x->forcedepthamount = 1;	x->drawsize = 4;	x->drawpositionx = 0;	x->drawpositiony = 0;}void getforce(NNato *x)	//force, posit globais{    float d;     int i, j, resetforce;		if(!x->forcedepthcount) resetforce=1; // clear force vectors	else resetforce=0;					// continue expanding		if(resetforce){   //verifica-se qd o forcedepthcount chegou a zero	 x->forcedepthcount = x->forcedepthamount;// passa ao valor maximo      for(i=0;i < x->grid; i++) //ciclo activado quando force.depth==0        for(j=0; j < x->grid; j++)         {            force[i][j]=0.0f;        }	}	    for(i=2;i<x->grid-2;i++)        for(j=2;j<x->grid-2;j++)         {            d=posit[i][j]-posit[i][j-1];            force[i][j] -= d;            force[i][j-1] += d;            d=posit[i][j]-posit[i-1][j];            force[i][j] -= d;            force[i-1][j] += d;            d= (posit[i][j]-posit[i][j+1]);             force[i][j] -= d ;            force[i][j+1] += d;            d= (posit[i][j]-posit[i+1][j]);             force[i][j] -= d ;            force[i+1][j] += d;            d= (posit[i][j]-posit[i+1][j+1])*SQRTOFTWOINV;             force[i][j] -= d ;            force[i+1][j+1] += d;            d= (posit[i][j]-posit[i-1][j-1])*SQRTOFTWOINV;             force[i][j] -= d ;            force[i-1][j-1] += d;            d= (posit[i][j]-posit[i+1][j-1])*SQRTOFTWOINV;             force[i][j] -= d ;            force[i+1][j-1] += d;            d= (posit[i][j]-posit[i-1][j+1])*SQRTOFTWOINV;             force[i][j] -= d ;            force[i- 1][j+1] += d;        }	x->forcedepthcount--;//depois de calculados decrementa-se o counter						 //das forcas para ter }void getvelocity(NNato *x) //velocity, force global{	int i,j;    for(i=0;i<x->grid;i++)        for(j=0;j<x->grid;j++)            veloc[i][j] += force[i][j] * x->dt;}void getposition(NNato *x) //posit, veloc{  	int i,j;    for(i=0;i<x->grid;i++)        for(j=0;j<x->grid;j++)            posit[i][j] += veloc[i][j];}/* face normals - for flat shading */void getFaceNorms(NNato *x){	int i,j;    float vec0[3], vec1[3], vec2[3], norm0[3], norm1[3];    float geom0[3], geom1[3], geom2[3], geom3[3];    for (i = 0; i < x->grid-1; ++i)    {        for (j = 0; j < x->grid-1; ++j)        {            /* get vectors from geometry points */            geom0[0] = i; geom0[1] = j; geom0[2] = posit[i][j];            geom1[0] = i; geom1[1] = j+1; geom1[2] = posit[i][j+1];            geom2[0] = i+1; geom2[1] = j; geom2[2] = posit[i+1][j];            geom3[0] = i+1; geom3[1] = j+1; geom3[2] = posit[i+1][j+1];            sub( vec0, geom1, geom0 );            sub( vec1, geom1, geom2 );            sub( vec2, geom1, geom3 );            /* get triangle face normals from vectors & normalize them */            cross( norm0, vec0, vec1 );            norm( norm0 );            cross( norm1, vec1, vec2 );             norm( norm1 );            copy( faceNorms[0][i][j], norm0 );            copy( faceNorms[1][i][j], norm1 );        }    }}/* vertex normals - average of face normals for smooth shading */void getVertNorms(NNato *x){	int i,j;    float avg[3];    for (i = 0; i < x->grid; ++i)    {        for (j = 0; j < x->grid; ++j)        {            /* For each vertex, average normals from all faces sharing */            /* vertex.  Check each quadrant in turn */            set(avg, 0.0, 0.0, 0.0);            /* Right & above */            if (j < x->grid-1 && i < x->grid-1)            {                add( avg, avg, faceNorms[0][i][j] );            }            /* Right & below */            if (j < x->grid-1 && i > 0)            {                add( avg, avg, faceNorms[0][i-1][j] );                add( avg, avg, faceNorms[1][i-1][j] );            }            /* Left & above */            if (j > 0 && i < x->grid-1)            {                add( avg, avg, faceNorms[0][i][j-1] );                add( avg, avg, faceNorms[1][i][j-1] );            }            /* Left & below */            if (j > 0 && i > 0)            {                add( avg, avg, faceNorms[1][i-1][j-1] );            }            /* Normalize */            norm( avg );            copy( vertNorms[i][j], avg );        }    }}void getFaceNormSegs(NNato *x){	int i,j;    float center0[3], center1[3], normSeg0[3], normSeg1[3];    float geom0[3], geom1[3], geom2[3], geom3[3];     for (i = 0; i < x->grid - 1; ++i)    {        for (j = 0; j < x->grid - 1; ++j)        {            geom0[0] = i; geom0[1] = j; geom0[2] = posit[i][j];            geom1[0] = i; geom1[1] = j+1; geom1[2] = posit[i][j+1];            geom2[0] = i+1; geom2[1] = j; geom2[2] = posit[i+1][j];            geom3[0] = i+1; geom3[1] = j+1; geom3[2] = posit[i+1][j+1];            /* find center of triangle face by averaging three vertices */            add( center0, geom2, geom0 );            add( center0, center0, geom1 );            scalDiv( center0, 3.0 );            add( center1, geom2, geom1 );            add( center1, center1, geom3 );            scalDiv( center1, 3.0 );            /* translate normal to center of triangle face to get normal segment */            add( normSeg0, center0, faceNorms[0][i][j] );            add( normSeg1, center1, faceNorms[1][i][j] );            copy( faceNormSegs[0][0][i][j], center0 );            copy( faceNormSegs[1][0][i][j], center1 );            copy( faceNormSegs[0][1][i][j], normSeg0 );            copy( faceNormSegs[1][1][i][j], normSeg1 );        }    }}void getTexCoords(NNato *x){	int i,j;    for (i = 0; i < x->grid; ++i)    {        for (j = 0; j < x->grid; ++j)        {            texCoords[i][j][0] = (float)j/(float)(x->grid-1);            texCoords[i][j][1] = (float)i/(float)(x->grid-1);        }    }}void drawFaceNormals(NNato *x){    int i,j;    glColor3f(1.0,1.0,1.0);    for (i = 0; i < x->grid - 1; ++i)    {        for (j = 0; j < x->grid - 1; ++j)        {            glBegin(GL_LINES);            glVertex3fv(faceNormSegs[0][0][i][j]);            glVertex3fv(faceNormSegs[0][1][i][j]);            glEnd();            glBegin(GL_LINES);            glVertex3fv(faceNormSegs[1][0][i][j]);            glVertex3fv(faceNormSegs[1][1][i][j]);            glEnd();        }    }}void nnato_forzeamount(NNato *x, int flag){	if(flag<=0) x->forcedepthamount = 1;	else x->forcedepthamount = flag;}void nnato_forzedrawsize(NNato *x, long flag){	x->drawsize = flag;}void nnato_forzedrawpositionx(NNato *x, long flag){	x->drawpositionx = flag;}void nnato_forzedrawpositiony(NNato *x, long flag){	x->drawpositiony = flag;}void nnato_forzefinger(NNato *x, long xx, long yy, float amount){	int px = xx, py = yy, wavingstate = x->waving;	float amt = amount;		if (px < 0 || px > x->grid || py < 0 || py>x->grid) return;		if (x->waving) stop(x);		posit[px][py] = amt;		x->waving = wavingstate;}void nnato_forzemess(NNato *x,Symbol *s, short argc, Atom *argv){	int i,j,k,wavingstate, drawsize = x->drawsize;	int cx = x->drawpositionx, cy = x->drawpositiony;//	Atom inlist;		wavingstate = x->waving;//    inlist = x->inlist;    	for (i=0; i < argc; i++) {		if (argv[i].a_type==A_LONG) {			x->inlist[i].a_w.w_float = (float)argv[i].a_w.w_long;		}		else if (argv[i].a_type==A_FLOAT) {			x->inlist[i].a_w.w_float = argv[i].a_w.w_float;		}		else if (argv[i].a_type==A_SYM) {			error("wrong argument type for n3on.gliding");		}	 }    if (x->waving)        stop(x);    k = 0;    for(i=0;i<x->grid;i++)        for(j=0;j<x->grid;j++)        {            force[i][j]=0.0;            veloc[i][j]=0.0;			if ((i>=cx) && ((j>=(cy+drawsize)) || (j>=(cy-drawsize))))			{					posit[i][j] = x->inlist[k].a_w.w_float;				k++; if (k>=argc) k=0;			}            if (i==0||j==0||i==x->grid-1||j==x->grid-1) posit[i][j]=0.0;        }		x->waving = wavingstate; //re.assign waving valu3 to g3t thingz roking}void wave(NNato *x){/* *   if (x->waving) *   { *       getforce(x); *       getvelocity(x); *       getposition(x); *       glutPostRedisplay(); *   } */ }void go(NNato *x){    x->waving = true;    x->editing = false;//    glutIdleFunc(wave);}void stop(NNato *x){    x->waving = false;//    glutIdleFunc(NULL);}/*void edit(void){    stop();    editing = true;}*/void reverse(NNato *x){	int i,j;    for(i=1;i<(x->grid-1);i++)        for(j=1;j<(x->grid-1);j++)            veloc[i][j]= -veloc[i][j];    if (!x->waving)        go(x);}void reset(NNato *x,int value){	int i,j,wavingstate;	wavingstate = x->waving;    if (x->waving)        stop(x);    if (value != CURRENT)        x->resetMode = value;            for(i=0;i<x->grid;i++)        for(j=0;j<x->grid;j++)        {            force[i][j]=0.0;            veloc[i][j]=0.0;            switch(x->resetMode)            {            case FLAT:                posit[i][j] = 0.0;                break;            case SPIKE:                 posit[i][j]= (i==j && i == x->grid/2) ? x->grid*1.5 : 0.0;                break;            case HOLE:                posit[i][j]= (!((i > x->grid/3 && j > x->grid/3)&&(i < x->grid*2/3 && j < x->grid*2/3))) ? x->grid/4 : 0.0;                break;            case DIAGONALWALL:                posit[i][j]= (((x->grid-i)-j<3) && ((x->grid-i)-j>0)) ? x->grid/6 : 0.0;                break;            case SIDEWALL:                posit[i][j]= (i==1) ? x->grid/4 : 0.0;                break;            case DIAGONALBLOCK:                posit[i][j]= ((x->grid-i)-j<3) ? x->grid/6 : 0.0;                break;            case MIDDLEBLOCK:                posit[i][j]= ((i > x->grid/3 && j > x->grid/3)&&(i < x->grid*2/3 && j < x->grid*2/3)) ? x->grid/4 : 0.0;                break;            case CORNERBLOCK:                posit[i][j]= ((i > x->grid*3/4 && j > x->grid*3/4)) ? x->grid/4 : 0.0;                break;            case HILL:                posit[i][j]=                     (sin(M_PI * ((float)i/(float)x->grid)) +                     sin(M_PI * ((float)j/(float)x->grid)))* x->grid/6.0;            break;                    case HILLFOUR:                posit[i][j]=                     (sin(M_PI*2 * ((float)i/(float)x->grid)) +                     sin(M_PI*2 * ((float)j/(float)x->grid)))* x->grid/6.0;            break;                    }            if (i==0||j==0||i==x->grid-1||j==x->grid-1) posit[i][j]=0.0;        }		x->waving = wavingstate; //re.assign waving valu3 to g3t thingz roking}void setSize(NNato *x, int value){    int prevGrid = x->grid;    switch(value)     {        case SMALL : x->grid = MAXGRID/4; break;        case MEDIUM: x->grid = MAXGRID/2; break;        case LARGE : x->grid = MAXGRID/1.5; break;        case XLARGE : x->grid = MAXGRID; break;    }    if (prevGrid > x->grid)    {        reset(x,x->resetMode);    }    x->zNear= x->grid/10.0;    x->zFar= x->grid*3.0;//    x->sdepth = 5.0/4.0 * x->grid; //i believe i can fly    getTexCoords(x);//    glutPostRedisplay();}void setSpeed(NNato *x,int value){    switch(value)     {        case WEAK  : x->dt = 0.001; break;        case NORMAL: x->dt = 0.004; break;        case STRONG: x->dt = 0.008; break;    }}void setDisplay(NNato *x, int value){    x->displayMode = value;    switch(value)     {        case WIREFRAME   :             glShadeModel(GL_FLAT);             glDisable(GL_LIGHTING);            break;        case HIDDENLINE:             glShadeModel(GL_FLAT);             glDisable(GL_LIGHTING);            break;        case FLATSHADED  :             glShadeModel(GL_FLAT);             glEnable(GL_LIGHTING);            break;        case SMOOTHSHADED:             glShadeModel(GL_SMOOTH);             glEnable(GL_LIGHTING);            break;        case TEXTURED:             glShadeModel(GL_SMOOTH);             glEnable(GL_LIGHTING);            break;    }//    glutPostRedisplay();}/*void setOther(int value){    switch (value)    {        case FULLSCREEN:             glutFullScreen();            break;        case FACENORMALS:             drawFaceNorms = !drawFaceNorms;            break;        case ANTIALIAS:             antialias = !antialias;            if (antialias)            {                glEnable(GL_BLEND);                glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);                glEnable(GL_LINE_SMOOTH);                glLineWidth(1.5);            }            else            {                glDisable(GL_BLEND);                glDisable(GL_LINE_SMOOTH);                glLineWidth(1.0);            }            break;        case ENVMAP:             envMap = !envMap;            if (envMap)            {                glBindTexture(GL_TEXTURE_2D, texId2);                glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);                glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);                glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);                glEnable(GL_TEXTURE_GEN_S);                glEnable(GL_TEXTURE_GEN_T);            }            else            {                glBindTexture(GL_TEXTURE_2D, texId1);                glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);                glDisable(GL_TEXTURE_GEN_S);                glDisable(GL_TEXTURE_GEN_T);            }            break;    }    glutPostRedisplay();}*//*void setMain(NNato *x, int value){    switch(value)     { //       case 1: edit(x);    break;        case 2:    go(x);      break; /* set idle func to something *//*        case 3: stop(x);    break; /* set idle func to null *//*        case 4:    reverse(x); break;        case 5:    exit(0);   break;    }}*/void nnato_on(NNato *x, long flag){        x->on = flag;}  void nnato_int(NNato *x, long n)    {								       if (!n) x->on = false;   else x->on = true;}void nnato_bang(NNato *x){   n2gldraw(x, n2objtype);}void nnato_variant(NNato *x, short variant){   if (!variant) n2objsetglfun(x,(method)nnato_glfun);   if (variant==1) n2objsetglfun(x,(method)nnato_glfun2);   if (variant==2) n2objsetglfun(x,(method)nnato_glfun3);   if (variant==3) n2objsetglfun(x,(method)nnato_glfun4);   if (variant==4) n2objsetglfun(x,(method)nnato_glfun5);}void nnato_revert(NNato *x){	//    nnato_klr(x,50,50,50);}void nnato_drawFaceNorms(NNato *x, long flag){        x->drawFaceNorms = flag;}  void nnato_displayMode(NNato *x, long flag){        x->displayMode = flag;}  void nnato_waving(NNato *x, long flag){        x->waving = flag;}  void nnato_sdepth(NNato *x, float flag){        x->sdepth = flag;}  void nnato_stheta(NNato *x, float flag){        x->stheta = flag;}  void nnato_sphi(NNato *x, float flag){        x->sphi = flag;}  void nnato_dt(NNato *x, float flag){        x->dt = 0.01*flag;}  void nnato_glfun(n2glatom glatom)				//{    NNato *x = (NNato *)n2getglatomobj(glatom);            int	   i, j;    float  aspect  = x->aspect,           zNear  = x->zNear,		   zFar = x->zFar,           sdepth = x->sdepth,           stheta = x->stheta,           sphi = x->sphi;    	int	   grid = x->grid;    if (!x->on) return; //    glShadeModel(x->shademodel);/*    glEnable(GL_DEPTH_TEST); *   glDepthFunc(GL_LEQUAL); *   glClearColor(0.0, 0.0, 0.0, 0.0); *   glPolygonOffset(1.0, 1.0); *   glEnable(GL_CULL_FACE); *   glHint(GL_LINE_SMOOTH_HINT, GL_NICEST); *   glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST); *   glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); *   glEnable(GL_COLOR_MATERIAL); *   glColorMaterial(GL_FRONT, GL_DIFFUSE); *    glLightfv (GL_LIGHT0, GL_POSITION, lightPosition); *   glEnable(GL_LIGHT0); */   //    glMatrixMode(GL_PROJECTION);//    glLoadIdentity();//    gluPerspective(64.0, aspect, zNear, zFar);//    glMatrixMode(GL_MODELVIEW);//    glLoadIdentity();     glTranslatef(0.0,0.0,-sdepth);    glRotatef(-stheta, 1.0, 0.0, 0.0);    glRotatef(sphi, 0.0, 0.0, 1.0);    glTranslatef(-(float)((grid+1)/2-1), -(float)((grid+1)/2-1), 0.0);    getFaceNorms(x);    getVertNorms(x);/* *   switch (x->displayMode)  *   { *       case WIREFRAME: drawWireframe(x); break; *       case HIDDENLINE: drawHiddenLine(x); break; *       case FLATSHADED: drawFlatShaded(x); break; *       case SMOOTHSHADED: drawSmoothShaded(x); break; *       case TEXTURED: drawTextured(x); break; *   } *///    if (!x->displayMode)//    	{ drawWireframe(x); }//    else if (x->displayMode ==1)//    	{ drawHiddenLine(x); }//    else if (x->displayMode ==2)//    	{ drawFlatShaded(x); }//    else if (x->displayMode ==3)//    	{ drawSmoothShaded(x); }//    else if (x->displayMode ==4)//    	{ drawTextured(x); }// to test, draw wireframe first and only    glColor3f(1.0, 1.0, 1.0);    for(i=0;i<x->grid;i++)    {        glBegin(GL_LINE_STRIP);        for(j=0;j<x->grid;j++)            glVertex3f( (float) i, (float) j, (float) posit[i][j]);        glEnd();    }        for(i=0;i<x->grid;i++)    {        glBegin(GL_LINE_STRIP);        for(j=0;j<x->grid;j++)            glVertex3f( (float) j, (float) i, (float) posit[j][i]);        glEnd();    }    if (x->drawFaceNorms)        {        getFaceNormSegs(x);        drawFaceNormals(x);    }    if (x->waving)    {        getforce(x);        getvelocity(x);        getposition(x);//        glutPostRedisplay();    } //   glutSwapBuffers(); //   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);}void nnato_glfun2(n2glatom glatom)		//     { drawHiddenLine(x); }{    NNato *x = (NNato *)n2getglatomobj(glatom);            int	   i, j;    float  aspect  = x->aspect,           zNear  = x->zNear,		   zFar = x->zFar,           sdepth = x->sdepth,           stheta = x->stheta,           sphi = x->sphi;    	int	   grid = x->grid;    if (!x->on) return; //    glMatrixMode(GL_PROJECTION);//    glLoadIdentity();//    gluPerspective(64.0, aspect, zNear, zFar);//    glMatrixMode(GL_MODELVIEW);//    glLoadIdentity();     glTranslatef(0.0,0.0,-sdepth);    glRotatef(-stheta, 1.0, 0.0, 0.0);    glRotatef(sphi, 0.0, 0.0, 1.0);    glTranslatef(-(float)((grid+1)/2-1), -(float)((grid+1)/2-1), 0.0);    getFaceNorms(x);    getVertNorms(x);//    	{ drawHiddenLine(x); }    glEnable(GL_POLYGON_OFFSET_FILL);    glColor3f(0.8f, 0.2f, 0.8f);    for (i = 0; i < x->grid - 1; ++i)    {        glBegin(GL_TRIANGLE_STRIP);        glVertex3f( (float) i, (float) 0, (float) posit[i][0]);        glVertex3f( (float) i+1, (float) 0, (float) posit[i+1][0]);        for (j = 1; j < x->grid; ++j)        {            glVertex3f( (float) i, (float) j, (float) posit[i][j]);            glVertex3f( (float) i+1, (float) j, (float) posit[i+1][j]);        }        glEnd();    }        glDisable(GL_POLYGON_OFFSET_FILL);        glColor3f(1.0,1.0,1.0);    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);    for (i = 0; i < x->grid - 1; ++i)    {        glBegin(GL_TRIANGLE_STRIP);        glVertex3f( (float) i, (float) 0, (float) posit[i][0]);        glVertex3f( (float) i+1, (float) 0, (float) posit[i+1][0]);        for (j = 1; j < x->grid; ++j)        {            glVertex3f( (float) i, (float) j, (float) posit[i][j]);            glVertex3f( (float) i+1, (float) j, (float) posit[i+1][j]);        }        glEnd();    }        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);    if (x->drawFaceNorms)        {        getFaceNormSegs(x);        drawFaceNormals(x);    }    if (x->waving)    {        getforce(x);        getvelocity(x);        getposition(x);    }}void nnato_glfun3(n2glatom glatom)		//    drawFlatShaded(x); }{    NNato *x = (NNato *)n2getglatomobj(glatom);            int	   i, j;    float  aspect  = x->aspect,           zNear  = x->zNear,		   zFar = x->zFar,           sdepth = x->sdepth,           stheta = x->stheta,           sphi = x->sphi;    	int	   grid = x->grid;    if (!x->on) return; //    glMatrixMode(GL_PROJECTION);//    glLoadIdentity();//    gluPerspective(64.0, aspect, zNear, zFar);//    glMatrixMode(GL_MODELVIEW);//    glLoadIdentity();     glTranslatef(0.0,0.0,-sdepth);    glRotatef(-stheta, 1.0, 0.0, 0.0);    glRotatef(sphi, 0.0, 0.0, 1.0);    glTranslatef(-(float)((grid+1)/2-1), -(float)((grid+1)/2-1), 0.0);    getFaceNorms(x);    getVertNorms(x);//    	{ drawFlatShaded(x); }    glEnable(GL_POLYGON_OFFSET_FILL);    glColor3f(0.8f, 0.2f, 0.8f);    for (i = 0; i < x->grid - 1; ++i)    {        glBegin(GL_TRIANGLE_STRIP);        glVertex3f( (float) i, (float) 0, (float) posit[i][0]);        glVertex3f( (float) i+1, (float) 0, (float) posit[i+1][0]);        for (j = 1; j < x->grid; ++j)        {            glNormal3fv( faceNorms[0][i][j-1] );            glVertex3f( (float) i, (float) j, (float) posit[i][j]);              glNormal3fv( faceNorms[1][i][j-1] );            glVertex3f( (float) i+1, (float) j, (float) posit[i+1][j]);        }        glEnd();    }    glDisable(GL_POLYGON_OFFSET_FILL);    if (x->drawFaceNorms)        {        getFaceNormSegs(x);        drawFaceNormals(x);    }    if (x->waving)    {        getforce(x);        getvelocity(x);        getposition(x);    }}void nnato_glfun4(n2glatom glatom)		//      { drawSmoothShaded(x); }{    NNato *x = (NNato *)n2getglatomobj(glatom);            int	   i, j;    float  aspect  = x->aspect,           zNear  = x->zNear,		   zFar = x->zFar,           sdepth = x->sdepth,           stheta = x->stheta,           sphi = x->sphi;    	int	   grid = x->grid;    if (!x->on) return; //    glMatrixMode(GL_PROJECTION);//    glLoadIdentity();//    gluPerspective(64.0, aspect, zNear, zFar);//    glMatrixMode(GL_MODELVIEW);//    glLoadIdentity();     glTranslatef(0.0,0.0,-sdepth);    glRotatef(-stheta, 1.0, 0.0, 0.0);    glRotatef(sphi, 0.0, 0.0, 1.0);    glTranslatef(-(float)((grid+1)/2-1), -(float)((grid+1)/2-1), 0.0);    getFaceNorms(x);    getVertNorms(x);//    	{ drawSmoothShaded(x); }    glColor3f(0.8f, 0.2f, 0.8f);    for (i = 0; i < x->grid - 1; ++i)    {        glBegin(GL_TRIANGLE_STRIP);        for (j = 0; j < x->grid; ++j)        {            glNormal3fv( vertNorms[i][j] );            glVertex3f( i, j, posit[i][j] );            glNormal3fv( vertNorms[i+1][j] );            glVertex3f( i+1, j, posit[i+1][j] );        }        glEnd();    }    if (x->drawFaceNorms)        {        getFaceNormSegs(x);        drawFaceNormals(x);    }    if (x->waving)    {        getforce(x);        getvelocity(x);        getposition(x);    }}void nnato_glfun5(n2glatom glatom)		//      { drawTextured(x); }{    NNato *x = (NNato *)n2getglatomobj(glatom);            int	   i, j;    float  aspect  = x->aspect,           zNear  = x->zNear,		   zFar = x->zFar,           sdepth = x->sdepth,           stheta = x->stheta,           sphi = x->sphi;    	int	   grid = x->grid;    if (!x->on) return; //    glMatrixMode(GL_PROJECTION);//    glLoadIdentity();//    gluPerspective(64.0, aspect, zNear, zFar);//    glMatrixMode(GL_MODELVIEW);//    glLoadIdentity();     glTranslatef(0.0,0.0,-sdepth);    glRotatef(-stheta, 1.0, 0.0, 0.0);    glRotatef(sphi, 0.0, 0.0, 1.0);    glTranslatef(-(float)((grid+1)/2-1), -(float)((grid+1)/2-1), 0.0);    getFaceNorms(x);    getVertNorms(x);//    	{ drawTextured(x); }    glColor3f(1.0f, 1.0f, 1.0f);    glEnable(GL_TEXTURE_2D);    for (i = 0; i < x->grid - 1; ++i)    {        glBegin(GL_TRIANGLE_STRIP);        for (j = 0; j < x->grid; ++j)        {            glNormal3fv( vertNorms[i][j] );            glTexCoord2fv( texCoords[i][j] );            glVertex3f( i, j, posit[i][j] );            glNormal3fv( vertNorms[i+1][j] );            glTexCoord2fv( texCoords[i+1][j] );            glVertex3f( i+1, j, posit[i+1][j] );        }        glEnd();    }    glDisable(GL_TEXTURE_2D);    if (x->drawFaceNorms)        {        getFaceNormSegs(x);        drawFaceNormals(x);    }    if (x->waving)    {        getforce(x);        getvelocity(x);        getposition(x);    }}/*void nnato_glfun2(n2glatom glatom)		//random at gl rate & mod{    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS,           nr ;        if (!x->on) return;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {        glPushMatrix();        glTranslatef(i, j, 0);		if(j%x->step==x->result)        nr = ran() * x->dev + x->offset;        glRotatef(anglx, 1, 0, 0);        glRotatef(angly, 0, 1, 0);        glRotatef(anglz, 0, 0, 1);                glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        glTexCoord2f(i * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(-a, -b, nr);        glTexCoord2f((i + 1) * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(a, -b, nr);        glTexCoord2f((i + 1) * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(a, b, nr);        glTexCoord2f(i * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(-a, b, nr);        glEnd();        glPopMatrix();      }    }}*///void nnato_glfun(n2glatom glatom)				////{//    NNato *x = (NNato *)n2getglatomobj(glatom);//    //    //    int	   i, j;//    float  aspect  = x->aspect,//           zNear  = x->zNear,//		   zFar = x->zFar,//           sdepth = x->sdepth,//           stheta = x->stheta,//           sphi = x->sphi;// //   	int	   grid = x->grid;//////    if (!x->on) return;// ////    glShadeModel(x->shademodel);/////*    glEnable(GL_DEPTH_TEST);// *   glDepthFunc(GL_LEQUAL);// *   glClearColor(0.0, 0.0, 0.0, 0.0);// *   glPolygonOffset(1.0, 1.0);// *   glEnable(GL_CULL_FACE);// *   glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);// *   glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);// *   glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);// *   glEnable(GL_COLOR_MATERIAL);// *   glColorMaterial(GL_FRONT, GL_DIFFUSE);// *    glLightfv (GL_LIGHT0, GL_POSITION, lightPosition);// *   glEnable(GL_LIGHT0);// */   //    glMatrixMode(GL_PROJECTION);//    glLoadIdentity();//    gluPerspective(64.0, aspect, zNear, zFar);//    glMatrixMode(GL_MODELVIEW);//    glLoadIdentity(); ////    glTranslatef(0.0,0.0,-sdepth);//    glRotatef(-stheta, 1.0, 0.0, 0.0);//    glRotatef(sphi, 0.0, 0.0, 1.0);//    glTranslatef(-(float)((grid+1)/2-1), -(float)((grid+1)/2-1), 0.0);////    getFaceNorms(x);//    getVertNorms(x);/////*// *   switch (x->displayMode) // *   {// *       case WIREFRAME: drawWireframe(x); break;// *       case HIDDENLINE: drawHiddenLine(x); break;// *       case FLATSHADED: drawFlatShaded(x); break;// *       case SMOOTHSHADED: drawSmoothShaded(x); break;// *       case TEXTURED: drawTextured(x); break;// *   }// */////    if (!x->displayMode)//    	{ drawWireframe(x); }//    else if (x->displayMode ==1)//    	{ drawHiddenLine(x); }//    else if (x->displayMode ==2)//    	{ drawFlatShaded(x); }//    else if (x->displayMode ==3)//    	{ drawSmoothShaded(x); }//    else if (x->displayMode ==4)//    	{ drawTextured(x); }//////////    if (x->drawFaceNorms)    //    {//        getFaceNormSegs(x);//        drawFaceNormals(x);//    }//    if (x->waving)//    {//        getforce(x);//        getvelocity(x);//        getposition(x);////        glutPostRedisplay();//    }////// //   glutSwapBuffers();// //   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);//}void nnato_glregister(NNato *x, void *klientz){    n2glregisterx(x,n2objtype,x->glout,klientz);  // bkom 01 klient ov gl alimentari data}			// mathvoid copy(float vec0[3], float vec1[3]){    vec0[0] = vec1[0];    vec0[1] = vec1[1];    vec0[2] = vec1[2];}void sub(float vec0[3], float vec1[3], float vec2[3]){    vec0[0] = vec1[0] - vec2[0];    vec0[1] = vec1[1] - vec2[1];    vec0[2] = vec1[2] - vec2[2];}void add(float vec0[3], float vec1[3], float vec2[3]){    vec0[0] = vec1[0] + vec2[0];    vec0[1] = vec1[1] + vec2[1];    vec0[2] = vec1[2] + vec2[2];}void scalDiv(float vec[3], float c){    vec[0] /= c; vec[1] /= c; vec[2] /= c;}void cross(float vec0[3], float vec1[3], float vec2[3]){    vec0[0] = vec1[1] * vec2[2] - vec1[2] * vec2[1];    vec0[1] = vec1[2] * vec2[0] - vec1[0] * vec2[2];    vec0[2] = vec1[0] * vec2[1] - vec1[1] * vec2[0];}void norm(float vec[3]){    float c = sqrt(vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2]);    scalDiv(vec, c); }void set(float vec[3], float x, float y, float z){    vec[0] = x;    vec[1] = y;    vec[2] = z;}/*----------------------------------------------------------	EOF----------------------------------------------------------*/