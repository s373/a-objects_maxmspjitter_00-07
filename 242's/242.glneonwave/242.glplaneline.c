/*242.glplanelinea 3d multislider wannabe. */#include "Movies.h"#include "ext_common.h"#include "ext.h"#include "ext_user.h"#include "n2.basicstrings.c"#include "n2.0000.h"#include "agl.h"#include "GL/glut.h" #include <stdlib.h> #define MAXGRID 63#define SQRTOFTWOINV 1.0 / 1.414213562#ifndef M_PI#define M_PI 3.14159265358979323846#endifenum {WIREFRAME, HIDDENLINE, FLATSHADED, SMOOTHSHADED, TEXTURED};enum {FULLSCREEN, FACENORMALS, ANTIALIAS, ENVMAP};enum {WEAK, NORMAL, STRONG};enum {SMALL, MEDIUM, LARGE, XLARGE};enum {CURRENT, FLAT, SPIKE, DIAGONALWALL, SIDEWALL, HOLE,       MIDDLEBLOCK, DIAGONALBLOCK, CORNERBLOCK, HILL, HILLFOUR};typedef struct zttz {	Object    n_ob; 	void     *n2hdr;    	    void   	 *glout;    short     type;/*    GLfloat   vertex,vertex2,red,green,blue,              normalx,normaly,normalz, 		// normals & vertex coords              anglx, angly, anglz,			//  rotation angle              dev, offset,					// dev & offset of              nr, nr1, nr2, nr3,			// final z coords              rate, actionx, actiony;  		//deform rate & action zone    GLint	  r, c;							// row&columns of quad-vertex field (rects field)*/ 	GLint	  current;						// current solide    GLboolean texture;                  long      shademodel, variant, step, result,  bmode;        GLfloat count, counttop, countamount;    Boolean        on,  waving, editing, 		\	     			drawFaceNorms, antialias, envMap;	int displayMode, resetMode;	int grid;	float dt;											// 1 dim plane	float 		force[MAXGRID][1],			//our force	      		veloc[MAXGRID][1],			//our velocity	      		posit[MAXGRID][1],			//	      		vertNorms[MAXGRID][1][3],	//	      		faceNorms[2][MAXGRID][1][3],//	      		faceNormSegs[2][2][MAXGRID][1][3];	      		/*	bool waving = false, editing = false, 	     drawFaceNorms = false, antialias = false,	     envMap = false;*/	float texCoords[MAXGRID][MAXGRID][2];/*float sphi=90.0, stheta=45.0;float sdepth = 5.0/4.0 * MAXGRID;float zNear=15.0, zFar=100.0;float aspect = 5.0/4.0;long xsize, ysize;int downX, downY;*/	float sphi, stheta;	float sdepth;	float zNear, zFar;	float aspect;	long xsize, ysize;	int downX, downY;} NNato;void *nnato_new(void);void nnato_assist(NNato *x, void *b, long msg, long nr, char *s);void nnato_info(NNato *x, void *p, void *b);void nnato_free(NNato *x);void nnato_on(NNato *x, long flag);void nnato_bang(NNato *x);void nnato_int(NNato *x, long n);   void nnato_variant(NNato *x, short variant);void	nnato_ignit(NNato *x);	// bootvoid nnato_type(NNato *x, short type);void nnato_vertex(NNato *x, long vertex, long vertex2);void nnato_shademodel(NNato *x, long type);void nnato_klr(NNato *x, long red, long green, long blue);void nnato_normalz(NNato *x, long koordx, long koordy, long koordz);void nnato_texture(NNato *x, long flag);void nnato_revertgeo(NNato *x);void nnato_revert(NNato *x);void nnato_angl(NNato *x, float val, float val1, float val2);void nnato_O(NNato *x, float val, float val1);void nnato_row(NNato *x, long n);   void nnato_column(NNato *x, long n);   void nnato_stgo(NNato *x, long n, long n1);void nnato_rate(NNato *x, float n);void nnato_bing(NNato *x);										//method to change valuesvoid nnato_setcounttop(NNato *x, float n);   void nnato_bmode(NNato *x, long n);   void nnato_countammount(NNato *x, float n);																//currently, variant 6++void nnato_action(NNato *x, float val, float val1);	//actionzonevoid nnato_glfun(n2glatom glatom);		// only alphavoid nnato_glfun2(n2glatom glatom);		//void nnato_glfun3(n2glatom glatom);void nnato_glfun4(n2glatom glatom);void nnato_glfun5(n2glatom glatom);void nnato_glfun6(n2glatom glatom);void nnato_glfun7(n2glatom glatom);void nnato_glfun8(n2glatom glatom);void nnato_glfun9(n2glatom glatom);void nnato_glfun10(n2glatom glatom);void nnato_glfun11(n2glatom glatom);void nnato_glfun12(n2glatom glatom);void nnato_glfun13(n2glatom glatom);void nnato_glregister(NNato *x, void *klientz);double ran(void);double alea(double min, double max);void    *nnato_class;main(){	setup(&nnato_class, nnato_new, (method)nnato_free, (short)sizeof(NNato), 0L, 0L, 0); 	addmess((method)nnato_assist,	                  "assist",          	A_CANT,0); 	addmess((method)nnato_info,	                      "info",		        A_CANT,0);    n2objaddglcmd();    n2addstatecmd((method)nnato_int,(method)nnato_bang,                  (method)nnato_on,-1,-1,-1,-1,(method)nnato_variant,0);    addmess((method)nnato_type,                       "drau.type",          A_DEFLONG,0);    addmess((method)nnato_shademodel,                 "normal.type",        A_DEFLONG,0);    addmess((method)nnato_normalz,                    "normal",             A_DEFLONG,A_DEFLONG,A_DEFLONG,0);    addmess((method)nnato_klr,                        "color",              A_DEFLONG,A_DEFLONG,A_DEFLONG,0);    addmess((method)nnato_texture,                    "texture",            A_DEFLONG,0);    addmess((method)nnato_vertex,                     "geo",                A_DEFLONG,A_DEFLONG,0);    addmess((method)nnato_revertgeo,                  "revert.geo",         0);    addmess((method)nnato_revert,                     "revert",             0);    addmess((method)nnato_angl,                        "alpha",              A_DEFFLOAT, A_DEFFLOAT, A_DEFFLOAT,0);    addmess((method)nnato_row,                       "r",            A_DEFLONG,0);    addmess((method)nnato_column,                    "c",            A_DEFLONG,0);    addmess((method)nnato_row,                       "row",            A_DEFLONG,0);    addmess((method)nnato_column,                    "col",            A_DEFLONG,0);    addmess((method)nnato_O,                        "do",              A_DEFFLOAT, A_DEFFLOAT,0);    addmess((method)nnato_stgo,                     "step",            A_DEFLONG,A_DEFLONG,0);    addmess((method)nnato_stgo,                     "%",               A_DEFLONG,A_DEFLONG,0);    addmess((method)nnato_bing,                    "bing",             0);    addmess((method)nnato_rate,                    "d.rate",            A_DEFFLOAT,0);    addmess((method)nnato_action,                  "zone",              A_DEFLONG, A_DEFLONG,0);    addmess((method)nnato_setcounttop,             "bmax",            A_DEFFLOAT,0);    addmess((method)nnato_bmode,             	"bmode",            A_DEFLONG,0);    addmess((method)nnato_countammount,           "bamount",            A_DEFFLOAT,0);    post ("242.glplanefield", 0);    n2addfklass("242.glplanefield");	}void nnato_assist(NNato *x, void *b, long msg, long nr, char *s){	if (msg == 1)      // !nlet	   strcpy( s,m9ndfukcpropaganda00);       {	   if (msg == 2)   // outlet	      if (nr == 0)	         strcpy( s, n2gltypestr);  // default `gl data type` outlet de[a]ss!zt--	   }}void nnato_info(NNato *x, void *p, void *b){	n2info(x,p,b); }void *nnato_new(){    NNato      *x;	short      err;	x = (NNato *)newobject(nnato_class);    n2addoutlet(x,&x->glout);        if (err = n2objinit(x))       { post("242.glk7 :  n2initobjekt err = %ld",err); return;}     n2objsetglregister(x,(method)nnato_glregister);   // zpecify gl regizter routine    n2objsetglfun(x,(method)nnato_glfun);             // zpecify gl drau routine	nnato_ignit(x);	// boot    nnato_revert(x);			x->on = true;	return (x);   ikk:	nnato_free(x);}void nnato_free(NNato *x){       n2objfree(x);}void nnato_ignit(NNato *x){   	int displayMode = WIREFRAME;	int resetMode = DIAGONALBLOCK;	int grid = 17;	float dt = 0.004;    setSize(MEDIUM);    setSpeed(NORMAL);    setDisplay(TEXTURED);    setOther(ENVMAP);    reset(HILLFOUR);	x->type = 6;	    x->vertex = x->vertex2 = .5;    x->shademodel = GLU_SMOOTH;     x->normalx = x->normaly = 0.0;    x->normalz = 1.0;        x->texture = true;    x->r = x->c = 6;    x->anglx =     x->angly =     x->anglz = 0.;    x->step =    x->result = 0 ;    x->dev = 2.;    x->offset = -1.;    x->nr = x->nr1 = x->nr2 = 0.;    nnato_klr(x,50,50,50);    x->current = 0;    x->actionx = 1;    x->actiony = 1;    x->count = 0.; //no frame    x->counttop = 1.; //0-100 init    x->bmode = 0;}void getforce(void){    float d;    for(i=0;i<grid;i++)         for(j=0;j<grid;j++)         {            force[i][j]=0.0;        }    for(i=2;i<grid-2;i++)        for(j=2;j<grid-2;j++)         {            d=posit[i][j]-posit[i][j-1];            force[i][j] -= d;            force[i][j-1] += d;            d=posit[i][j]-posit[i-1][j];            force[i][j] -= d;            force[i-1][j] += d;            d= (posit[i][j]-posit[i][j+1]);             force[i][j] -= d ;            force[i][j+1] += d;            d= (posit[i][j]-posit[i+1][j]);             force[i][j] -= d ;            force[i+1][j] += d;            d= (posit[i][j]-posit[i+1][j+1])*SQRTOFTWOINV;             force[i][j] -= d ;            force[i+1][j+1] += d;            d= (posit[i][j]-posit[i-1][j-1])*SQRTOFTWOINV;             force[i][j] -= d ;            force[i-1][j-1] += d;            d= (posit[i][j]-posit[i+1][j-1])*SQRTOFTWOINV;             force[i][j] -= d ;            force[i+1][j-1] += d;            d= (posit[i][j]-posit[i-1][j+1])*SQRTOFTWOINV;             force[i][j] -= d ;            force[i- 1][j+1] += d;        }}void getvelocity(void){    for(i=0;i<grid;i++)        for(j=0;j<grid;j++)            veloc[i][j]+=force[i][j] * dt;}void getposition(void){    for(i=0;i<grid;i++)        for(j=0;j<grid;j++)            posit[i][j]+=veloc[i][j];}void copy(float vec0[3], float vec1[3]){    vec0[0] = vec1[0];    vec0[1] = vec1[1];    vec0[2] = vec1[2];}void sub(float vec0[3], float vec1[3], float vec2[3]){    vec0[0] = vec1[0] - vec2[0];    vec0[1] = vec1[1] - vec2[1];    vec0[2] = vec1[2] - vec2[2];}void add(float vec0[3], float vec1[3], float vec2[3]){    vec0[0] = vec1[0] + vec2[0];    vec0[1] = vec1[1] + vec2[1];    vec0[2] = vec1[2] + vec2[2];}void scalDiv(float vec[3], float c){    vec[0] /= c; vec[1] /= c; vec[2] /= c;}void cross(float vec0[3], float vec1[3], float vec2[3]){    vec0[0] = vec1[1] * vec2[2] - vec1[2] * vec2[1];    vec0[1] = vec1[2] * vec2[0] - vec1[0] * vec2[2];    vec0[2] = vec1[0] * vec2[1] - vec1[1] * vec2[0];}void norm(float vec[3]){    float c = sqrt(vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2]);    scalDiv(vec, c); }void set(float vec[3], float x, float y, float z){    vec[0] = x;    vec[1] = y;    vec[2] = z;}/* face normals - for flat shading */void getFaceNorms(void){    float vec0[3], vec1[3], vec2[3], norm0[3], norm1[3];    float geom0[3], geom1[3], geom2[3], geom3[3];    for (i = 0; i < grid-1; ++i)    {        for (j = 0; j < grid-1; ++j)        {            /* get vectors from geometry points */            geom0[0] = i; geom0[1] = j; geom0[2] = posit[i][j];            geom1[0] = i; geom1[1] = j+1; geom1[2] = posit[i][j+1];            geom2[0] = i+1; geom2[1] = j; geom2[2] = posit[i+1][j];            geom3[0] = i+1; geom3[1] = j+1; geom3[2] = posit[i+1][j+1];            sub( vec0, geom1, geom0 );            sub( vec1, geom1, geom2 );            sub( vec2, geom1, geom3 );            /* get triangle face normals from vectors & normalize them */            cross( norm0, vec0, vec1 );            norm( norm0 );            cross( norm1, vec1, vec2 );             norm( norm1 );            copy( faceNorms[0][i][j], norm0 );            copy( faceNorms[1][i][j], norm1 );        }    }}/* vertex normals - average of face normals for smooth shading */void getVertNorms(void){    float avg[3];    for (i = 0; i < grid; ++i)    {        for (j = 0; j < grid; ++j)        {            /* For each vertex, average normals from all faces sharing */            /* vertex.  Check each quadrant in turn */            set(avg, 0.0, 0.0, 0.0);            /* Right & above */            if (j < grid-1 && i < grid-1)            {                add( avg, avg, faceNorms[0][i][j] );            }            /* Right & below */            if (j < grid-1 && i > 0)            {                add( avg, avg, faceNorms[0][i-1][j] );                add( avg, avg, faceNorms[1][i-1][j] );            }            /* Left & above */            if (j > 0 && i < grid-1)            {                add( avg, avg, faceNorms[0][i][j-1] );                add( avg, avg, faceNorms[1][i][j-1] );            }            /* Left & below */            if (j > 0 && i > 0)            {                add( avg, avg, faceNorms[1][i-1][j-1] );            }            /* Normalize */            norm( avg );            copy( vertNorms[i][j], avg );        }    }}void getFaceNormSegs(void){    float center0[3], center1[3], normSeg0[3], normSeg1[3];    float geom0[3], geom1[3], geom2[3], geom3[3];    for (i = 0; i < grid - 1; ++i)    {        for (j = 0; j < grid - 1; ++j)        {            geom0[0] = i; geom0[1] = j; geom0[2] = posit[i][j];            geom1[0] = i; geom1[1] = j+1; geom1[2] = posit[i][j+1];            geom2[0] = i+1; geom2[1] = j; geom2[2] = posit[i+1][j];            geom3[0] = i+1; geom3[1] = j+1; geom3[2] = posit[i+1][j+1];            /* find center of triangle face by averaging three vertices */            add( center0, geom2, geom0 );            add( center0, center0, geom1 );            scalDiv( center0, 3.0 );            add( center1, geom2, geom1 );            add( center1, center1, geom3 );            scalDiv( center1, 3.0 );            /* translate normal to center of triangle face to get normal segment */            add( normSeg0, center0, faceNorms[0][i][j] );            add( normSeg1, center1, faceNorms[1][i][j] );            copy( faceNormSegs[0][0][i][j], center0 );            copy( faceNormSegs[1][0][i][j], center1 );            copy( faceNormSegs[0][1][i][j], normSeg0 );            copy( faceNormSegs[1][1][i][j], normSeg1 );        }    }}void getTexCoords(void){    for (i = 0; i < grid; ++i)    {        for (j = 0; j < grid; ++j)        {            texCoords[i][j][0] = (float)j/(float)(grid-1);            texCoords[i][j][1] = (float)i/(float)(grid-1);        }    }}void wave(void){    if (waving)    {        getforce();        getvelocity();        getposition();        glutPostRedisplay();    }}void go(void){    waving = true;    editing = false;    glutIdleFunc(wave);}void stop(void){    waving = false;    glutIdleFunc(NULL);}void edit(void){    stop();    editing = true;}void reverse(void){    for(i=1;i<(grid-1);i++)        for(j=1;j<(grid-1);j++)            veloc[i][j]= -veloc[i][j];    if (!waving)        go();}void reset(int value){    if (waving)        stop();    if (value != CURRENT)        resetMode = value;    for(i=0;i<grid;i++)        for(j=0;j<grid;j++)        {            force[i][j]=0.0;            veloc[i][j]=0.0;            switch(resetMode)            {            case FLAT:                posit[i][j] = 0.0;                break;            case SPIKE:                 posit[i][j]= (i==j && i == grid/2) ? grid*1.5 : 0.0;                break;            case HOLE:                posit[i][j]= (!((i > grid/3 && j > grid/3)&&(i < grid*2/3 && j < grid*2/3))) ? grid/4 : 0.0;                break;            case DIAGONALWALL:                posit[i][j]= (((grid-i)-j<3) && ((grid-i)-j>0)) ? grid/6 : 0.0;                break;            case SIDEWALL:                posit[i][j]= (i==1) ? grid/4 : 0.0;                break;            case DIAGONALBLOCK:                posit[i][j]= ((grid-i)-j<3) ? grid/6 : 0.0;                break;            case MIDDLEBLOCK:                posit[i][j]= ((i > grid/3 && j > grid/3)&&(i < grid*2/3 && j < grid*2/3)) ? grid/4 : 0.0;                break;            case CORNERBLOCK:                posit[i][j]= ((i > grid*3/4 && j > grid*3/4)) ? grid/4 : 0.0;                break;            case HILL:                posit[i][j]=                     (sin(M_PI * ((float)i/(float)grid)) +                     sin(M_PI * ((float)j/(float)grid)))* grid/6.0;            break;                    case HILLFOUR:                posit[i][j]=                     (sin(M_PI*2 * ((float)i/(float)grid)) +                     sin(M_PI*2 * ((float)j/(float)grid)))* grid/6.0;            break;                    }            if (i==0||j==0||i==grid-1||j==grid-1) posit[i][j]=0.0;        }    glutPostRedisplay();}void setSize(int value){    int prevGrid = grid;    switch(value)     {        case SMALL : grid = MAXGRID/4; break;        case MEDIUM: grid = MAXGRID/2; break;        case LARGE : grid = MAXGRID/1.5; break;        case XLARGE : grid = MAXGRID; break;    }    if (prevGrid > grid)    {        reset(resetMode);    }    zNear= grid/10.0;    zFar= grid*3.0;    sdepth = 5.0/4.0 * grid;    getTexCoords();    glutPostRedisplay();}void setSpeed(int value){    switch(value)     {        case WEAK  : dt = 0.001; break;        case NORMAL: dt = 0.004; break;        case STRONG: dt = 0.008; break;    }}void setDisplay(int value){    displayMode = value;    switch(value)     {        case WIREFRAME   :             glShadeModel(GL_FLAT);             glDisable(GL_LIGHTING);            break;        case HIDDENLINE:             glShadeModel(GL_FLAT);             glDisable(GL_LIGHTING);            break;        case FLATSHADED  :             glShadeModel(GL_FLAT);             glEnable(GL_LIGHTING);            break;        case SMOOTHSHADED:             glShadeModel(GL_SMOOTH);             glEnable(GL_LIGHTING);            break;        case TEXTURED:             glShadeModel(GL_SMOOTH);             glEnable(GL_LIGHTING);            break;    }    glutPostRedisplay();}void setOther(int value){    switch (value)    {        case FULLSCREEN:             glutFullScreen();            break;        case FACENORMALS:             drawFaceNorms = !drawFaceNorms;            break;        case ANTIALIAS:             antialias = !antialias;            if (antialias)            {                glEnable(GL_BLEND);                glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);                glEnable(GL_LINE_SMOOTH);                glLineWidth(1.5);            }            else            {                glDisable(GL_BLEND);                glDisable(GL_LINE_SMOOTH);                glLineWidth(1.0);            }            break;        case ENVMAP:             envMap = !envMap;            if (envMap)            {                glBindTexture(GL_TEXTURE_2D, texId2);                glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);                glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);                glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);                glEnable(GL_TEXTURE_GEN_S);                glEnable(GL_TEXTURE_GEN_T);            }            else            {                glBindTexture(GL_TEXTURE_2D, texId1);                glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);                glDisable(GL_TEXTURE_GEN_S);                glDisable(GL_TEXTURE_GEN_T);            }            break;    }    glutPostRedisplay();}void setMain(int value){    switch(value)     {        case 1: edit();    break;        case 2:    go();      break; /* set idle func to something */        case 3: stop();    break; /* set idle func to null */        case 4:    reverse(); break;        case 5:    exit(0);   break;    }}void drawFaceNormals(void){    glColor3f(1.0,1.0,1.0);    for (i = 0; i < grid - 1; ++i)    {        for (j = 0; j < grid - 1; ++j)        {            glBegin(GL_LINES);            glVertex3fv(faceNormSegs[0][0][i][j]);            glVertex3fv(faceNormSegs[0][1][i][j]);            glEnd();            glBegin(GL_LINES);            glVertex3fv(faceNormSegs[1][0][i][j]);            glVertex3fv(faceNormSegs[1][1][i][j]);            glEnd();        }    }}void drawSmoothShaded(void){    glColor3f(0.8f, 0.2f, 0.8f);    for (i = 0; i < grid - 1; ++i)    {        glBegin(GL_TRIANGLE_STRIP);        for (j = 0; j < grid; ++j)        {            glNormal3fv( vertNorms[i][j] );            glVertex3f( i, j, posit[i][j] );            glNormal3fv( vertNorms[i+1][j] );            glVertex3f( i+1, j, posit[i+1][j] );        }        glEnd();    }}void drawWireframe(void){    glColor3f(1.0, 1.0, 1.0);    for(i=0;i<grid;i++)    {        glBegin(GL_LINE_STRIP);        for(j=0;j<grid;j++)            glVertex3f( (float) i, (float) j, (float) posit[i][j]);        glEnd();    }        for(i=0;i<grid;i++)    {        glBegin(GL_LINE_STRIP);        for(j=0;j<grid;j++)            glVertex3f( (float) j, (float) i, (float) posit[j][i]);        glEnd();    }}void drawFlatShaded(void){    glEnable(GL_POLYGON_OFFSET_FILL);    glColor3f(0.8f, 0.2f, 0.8f);    for (i = 0; i < grid - 1; ++i)    {        glBegin(GL_TRIANGLE_STRIP);        glVertex3f( (float) i, (float) 0, (float) posit[i][0]);        glVertex3f( (float) i+1, (float) 0, (float) posit[i+1][0]);        for (j = 1; j < grid; ++j)        {            glNormal3fv( faceNorms[0][i][j-1] );            glVertex3f( (float) i, (float) j, (float) posit[i][j]);              glNormal3fv( faceNorms[1][i][j-1] );            glVertex3f( (float) i+1, (float) j, (float) posit[i+1][j]);        }        glEnd();    }    glDisable(GL_POLYGON_OFFSET_FILL);}void drawHiddenLine(void){    glEnable(GL_POLYGON_OFFSET_FILL);    glColor3f(0.8f, 0.2f, 0.8f);    for (i = 0; i < grid - 1; ++i)    {        glBegin(GL_TRIANGLE_STRIP);        glVertex3f( (float) i, (float) 0, (float) posit[i][0]);        glVertex3f( (float) i+1, (float) 0, (float) posit[i+1][0]);        for (j = 1; j < grid; ++j)        {            glVertex3f( (float) i, (float) j, (float) posit[i][j]);            glVertex3f( (float) i+1, (float) j, (float) posit[i+1][j]);        }        glEnd();    }        glDisable(GL_POLYGON_OFFSET_FILL);        glColor3f(1.0,1.0,1.0);    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);    for (i = 0; i < grid - 1; ++i)    {        glBegin(GL_TRIANGLE_STRIP);        glVertex3f( (float) i, (float) 0, (float) posit[i][0]);        glVertex3f( (float) i+1, (float) 0, (float) posit[i+1][0]);        for (j = 1; j < grid; ++j)        {            glVertex3f( (float) i, (float) j, (float) posit[i][j]);            glVertex3f( (float) i+1, (float) j, (float) posit[i+1][j]);        }        glEnd();    }        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);} void nnato_on(NNato *x, long flag){        x->on = flag;}  void nnato_int(NNato *x, long n)    {								       if (!n) x->on = false;   else x->on = true;}void nnato_bang(NNato *x){   n2gldraw(x, n2objtype);}void nnato_variant(NNato *x, short variant){   if (!variant) n2objsetglfun(x,(method)nnato_glfun);   else if (variant==1) n2objsetglfun(x,(method)nnato_glfun2);   else if (variant==2) n2objsetglfun(x,(method)nnato_glfun3);   else if (variant==3) n2objsetglfun(x,(method)nnato_glfun4);   else if (variant==4) n2objsetglfun(x,(method)nnato_glfun5);   else if (variant==5) n2objsetglfun(x,(method)nnato_glfun6);   else if (variant==6) n2objsetglfun(x,(method)nnato_glfun7);   else if (variant==7) n2objsetglfun(x,(method)nnato_glfun8);   else if (variant==8) n2objsetglfun(x,(method)nnato_glfun9);   else if (variant==9) n2objsetglfun(x,(method)nnato_glfun10);   else if (variant==10) n2objsetglfun(x,(method)nnato_glfun11);   else if (variant==11) n2objsetglfun(x,(method)nnato_glfun12);   else if (variant==12) n2objsetglfun(x,(method)nnato_glfun13);}void nnato_type(NNato *x, short type){   if (type >= 0 && type <= 9) x->type = type;}void nnato_klr(NNato *x, long red, long green, long blue){   x->red   = (float)red   * 0.01;   x->green = (float)green * 0.01;   x->blue  = (float)blue  * 0.01;      }  void nnato_normalz(NNato *x, long koordx, long koordy, long koordz){   x->normalx  = (float)koordx * 0.01;   x->normaly  = (float)koordy * 0.01;   x->normalz  = (float)koordz * 0.01;      }  void nnato_shademodel(NNato *x, long type){   if (type == 0) x->shademodel = GLU_SMOOTH;   else if (type == 1) x->shademodel = GLU_FLAT;   else if (type == 2) x->shademodel = GLU_NONE;}void nnato_vertex(NNato *x, long vertex, long vertex2){    x->vertex   = (float)vertex  * .01;    x->vertex2  = (float)vertex2 * .01;}			void nnato_texture(NNato *x, long flag){    x->texture = flag;}void nnato_revertgeo(NNato *x){	    x->vertex = x->vertex2 = .5;   }		void nnato_revert(NNato *x){		x->type = 6;	    x->vertex = x->vertex2 = .5;    x->shademodel = GLU_SMOOTH;     x->normalx = x->normaly = 0.0;    x->normalz = 1.0;        x->texture = true;    x->r = x->c = 6;    x->anglx =     x->angly =     x->anglz = 0.;    x->step =    x->result = 0 ;    x->dev = 2.;    x->offset = -1.;    x->nr = x->nr1 = x->nr2 = 0.;    nnato_klr(x,50,50,50);    x->current = 0;    x->actionx = 1;    x->actiony = 1;    x->count = 0.; //no frame    x->counttop = 1.; //0-100 init    x->bmode = 0;}void nnato_angl(NNato *x, float val, float val1, float val2){    x->anglx = val;    x->angly = val1;    x->anglz = val2;}void nnato_O(NNato *x, float val, float val1){    x->dev = val;    x->offset = val1;//    nnato_bing(x);}void nnato_row(NNato *x, long n){        x->r = n;}  void nnato_column(NNato *x, long n){        x->c = n;	//was x->r... that's why...}  void nnato_rate(NNato *x, float n){        x->rate = n * 0.01;}  void nnato_setcounttop(NNato *x, float n){        x->counttop = n;	}  void nnato_countammount(NNato *x, float n){        x->countamount = n;	}  void nnato_stgo(NNato *x, long n, long n1){        x->step = n;    x->result = n1;}  void nnato_bmode(NNato *x, long n){        x->bmode = n;	}  void nnato_bing(NNato *x)	//method to change values{								// change this really soon	float c = x->count; //copy value	if (c > x->counttop) c = 0. ;		if (!x->bmode)	{		x->nr = c * x->dev + x->offset;		x->nr1 = (c+.1) * x->dev + x->offset;		x->nr2 = (c+.2) * x->dev + x->offset;		x->nr3 = (c+.3) * x->dev + x->offset;				c += x->countamount;		x->count = c;	} else if (x->bmode==1)	{	    x->nr = ran() * x->dev + x->offset;	    x->nr1 = ran() * x->dev + x->offset;	    x->nr2 = ran() * x->dev + x->offset;	    x->nr3 = ran() * x->dev + x->offset;		c += x->countamount;		x->count = c;	} else if (x->bmode==2)	{	    x->nr = c*ran() * x->dev + x->offset;	    x->nr1 = c*ran() * x->dev + x->offset;	    x->nr2 = c*ran() * x->dev + x->offset;	    x->nr3 = c*ran() * x->dev + x->offset;		c += x->countamount;		x->count = c;	} else if (x->bmode==3)	{	    x->nr = c*ran() * x->dev + x->offset;	    x->nr1 = (c+.1)*ran() * x->dev + x->offset;	    x->nr2 = (c+.2)*ran() * x->dev + x->offset;	    x->nr3 = (c+.3)*ran() * x->dev + x->offset;		c += x->countamount;		x->count = c;	}         }void nnato_action(NNato *x, float val, float val1){    x->actionx = val;    x->actiony = val1;}void nnato_glfun(n2glatom glatom)				//only segment{    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r;                           float  aspect  = x->aspect,           znear  = x->znear,		   zFar = x->zFar,           sdepth = x->sdepth,           stheta = x->stheta,           TILE_TEX_W = 1.0/COLS,	//text stride           TILE_TEX_H = 1.0/ROWS,           actx = x->actionx,           acty = x->actiony,           nr = x->nr ;    	int		grid = x->grid;    if (!x->on) return;        glMatrixMode(GL_PROJECTION);    glLoadIdentity();    gluPerspective(64.0, aspect, zNear, zFar);    glMatrixMode(GL_MODELVIEW);    glLoadIdentity();     glTranslatef(0.0,0.0,-sdepth);    glRotatef(-stheta, 1.0, 0.0, 0.0);    glRotatef(sphi, 0.0, 0.0, 1.0);    glTranslatef(-(float)((grid+1)/2-1), -(float)((grid+1)/2-1), 0.0);    getFaceNorms();    getVertNorms();    switch (displayMode)     {        case WIREFRAME: drawWireframe(); break;        case HIDDENLINE: drawHiddenLine(); break;        case FLATSHADED: drawFlatShaded(); break;        case SMOOTHSHADED: drawSmoothShaded(); break;        case TEXTURED: drawTextured(); break;    }    if (drawFaceNorms)        {        getFaceNormSegs();        drawFaceNormals();    }    glutSwapBuffers();    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);}void drawFaceNormals(void){    glColor3f(1.0,1.0,1.0);    for (i = 0; i < grid - 1; ++i)    {        for (j = 0; j < grid - 1; ++j)        {            glBegin(GL_LINES);            glVertex3fv(faceNormSegs[0][0][i][j]);            glVertex3fv(faceNormSegs[0][1][i][j]);            glEnd();            glBegin(GL_LINES);            glVertex3fv(faceNormSegs[1][0][i][j]);            glVertex3fv(faceNormSegs[1][1][i][j]);            glEnd();        }    }}void drawSmoothShaded(void){    glColor3f(0.8f, 0.2f, 0.8f);    for (i = 0; i < grid - 1; ++i)    {        glBegin(GL_TRIANGLE_STRIP);        for (j = 0; j < grid; ++j)        {            glNormal3fv( vertNorms[i][j] );            glVertex3f( i, j, posit[i][j] );            glNormal3fv( vertNorms[i+1][j] );            glVertex3f( i+1, j, posit[i+1][j] );        }        glEnd();    }}void drawWireframe(void){    glColor3f(1.0, 1.0, 1.0);    for(i=0;i<grid;i++)    {        glBegin(GL_LINE_STRIP);        for(j=0;j<grid;j++)            glVertex3f( (float) i, (float) j, (float) posit[i][j]);        glEnd();    }        for(i=0;i<grid;i++)    {        glBegin(GL_LINE_STRIP);        for(j=0;j<grid;j++)            glVertex3f( (float) j, (float) i, (float) posit[j][i]);        glEnd();    }}void drawFlatShaded(void){    glEnable(GL_POLYGON_OFFSET_FILL);    glColor3f(0.8f, 0.2f, 0.8f);    for (i = 0; i < grid - 1; ++i)    {        glBegin(GL_TRIANGLE_STRIP);        glVertex3f( (float) i, (float) 0, (float) posit[i][0]);        glVertex3f( (float) i+1, (float) 0, (float) posit[i+1][0]);        for (j = 1; j < grid; ++j)        {            glNormal3fv( faceNorms[0][i][j-1] );            glVertex3f( (float) i, (float) j, (float) posit[i][j]);              glNormal3fv( faceNorms[1][i][j-1] );            glVertex3f( (float) i+1, (float) j, (float) posit[i+1][j]);        }        glEnd();    }    glDisable(GL_POLYGON_OFFSET_FILL);}void drawHiddenLine(void){    glEnable(GL_POLYGON_OFFSET_FILL);    glColor3f(0.8f, 0.2f, 0.8f);    for (i = 0; i < grid - 1; ++i)    {        glBegin(GL_TRIANGLE_STRIP);        glVertex3f( (float) i, (float) 0, (float) posit[i][0]);        glVertex3f( (float) i+1, (float) 0, (float) posit[i+1][0]);        for (j = 1; j < grid; ++j)        {            glVertex3f( (float) i, (float) j, (float) posit[i][j]);            glVertex3f( (float) i+1, (float) j, (float) posit[i+1][j]);        }        glEnd();    }        glDisable(GL_POLYGON_OFFSET_FILL);        glColor3f(1.0,1.0,1.0);    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);    for (i = 0; i < grid - 1; ++i)    {        glBegin(GL_TRIANGLE_STRIP);        glVertex3f( (float) i, (float) 0, (float) posit[i][0]);        glVertex3f( (float) i+1, (float) 0, (float) posit[i+1][0]);        for (j = 1; j < grid; ++j)        {            glVertex3f( (float) i, (float) j, (float) posit[i][j]);            glVertex3f( (float) i+1, (float) j, (float) posit[i+1][j]);        }        glEnd();    }        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);}void drawTextured(void){    glColor3f(1.0f, 1.0f, 1.0f);    glEnable(GL_TEXTURE_2D);    for (i = 0; i < grid - 1; ++i)    {        glBegin(GL_TRIANGLE_STRIP);        for (j = 0; j < grid; ++j)        {            glNormal3fv( vertNorms[i][j] );            glTexCoord2fv( texCoords[i][j] );            glVertex3f( i, j, posit[i][j] );            glNormal3fv( vertNorms[i+1][j] );            glTexCoord2fv( texCoords[i+1][j] );            glVertex3f( i+1, j, posit[i+1][j] );        }        glEnd();    }    glDisable(GL_TEXTURE_2D);}void nnato_glfun2(n2glatom glatom)		//random at gl rate & mod{    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS,           nr ;        if (!x->on) return;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {        glPushMatrix();        glTranslatef(i, j, 0);		if(j%x->step==x->result)        nr = ran() * x->dev + x->offset;        glRotatef(anglx, 1, 0, 0);        glRotatef(angly, 0, 1, 0);        glRotatef(anglz, 0, 0, 1);                glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        glTexCoord2f(i * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(-a, -b, nr);        glTexCoord2f((i + 1) * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(a, -b, nr);        glTexCoord2f((i + 1) * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(a, b, nr);        glTexCoord2f(i * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(-a, b, nr);        glEnd();        glPopMatrix();      }    }}void nnato_glfun3(n2glatom glatom)		//igual a 2 + angulo rnd{    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS,           nr ;        if (!x->on) return;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {        glPushMatrix();        glTranslatef(i, j, 0);		if(j%x->step==x->result)        nr = ran() * x->dev + x->offset;        glRotatef(anglx + nr, 1, 0, 0);        glRotatef(angly + nr, 0, 1, 0);        glRotatef(anglz + nr, 0, 0, 1);                glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        glTexCoord2f(i * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(-a, -b, nr);        glTexCoord2f((i + 1) * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(a, -b, nr);        glTexCoord2f((i + 1) * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(a, b, nr);        glTexCoord2f(i * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(-a, b, nr);        glEnd();        glPopMatrix();      }    }}void nnato_glfun4(n2glatom glatom)				//3 e geom com 3 pontos dif{    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS,           nr, nr1, nr2 ;        if (!x->on) return;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {        glPushMatrix();        glTranslatef(i, j, 0);		if(j%x->step==x->result){        nr = ran() * x->dev + x->offset;        nr1 = ran() * x->dev + x->offset;        nr2 = ran() * x->dev + x->offset;        }        glRotatef(anglx + nr, 1, 0, 0);        glRotatef(angly + nr1, 0, 1, 0);        glRotatef(anglz + nr2, 0, 0, 1);                glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        glTexCoord2f(i * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(-a, -b, nr);        glTexCoord2f((i + 1) * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(a, -b, nr1);        glTexCoord2f((i + 1) * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(a, b, nr2);        glTexCoord2f(i * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(-a, b, nr1);        glEnd();        glPopMatrix();      }    }}void nnato_glfun5(n2glatom glatom){    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS,           nr, nr1, nr2 ;        if (!x->on) return;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {        glPushMatrix();        glTranslatef(i, j, 0);		if(j%x->step==x->result){        nr = ran() * x->dev + x->offset;        nr1 = ran() * x->dev + x->offset;        nr2 = ran() * x->dev + x->offset;        }        glRotatef(anglx , 1, 0, 0);        glRotatef(angly , 0, 1, 0);        glRotatef(anglz , 0, 0, 1);                glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        glTexCoord2f(i * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(-a, -b, nr);        glTexCoord2f((i + 1) * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(a, -b, nr1);        glTexCoord2f((i + 1) * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(a, b, nr2);        glTexCoord2f(i * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(-a, b, nr1);        glEnd();        glPopMatrix();      }    }}void nnato_glfun6(n2glatom glatom){    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r,    		cmax = COLS + ROWS,    		curr;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS,           nr = x->nr,            nr1 = x->nr1,             nr2 = x->nr2 ;        if (!x->on) return;    if (!curr) curr = 0;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {				curr = i+j;	//current solid         glPushMatrix();        glTranslatef(i, j, 0);        glRotatef(anglx , 1, 0, 0);        glRotatef(angly , 0, 1, 0);        glRotatef(anglz , 0, 0, 1);        		if (curr == x->current) nnato_bing(x);		        glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        glTexCoord2f(i * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(-a, -b, nr);        glTexCoord2f((i + 1) * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(a, -b, nr);        glTexCoord2f((i + 1) * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(a, b, nr);        glTexCoord2f(i * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(-a, b, nr);        glEnd();        glPopMatrix();		x->current = (x->current + 1) % cmax;	//cycle from 0 to lastsolid      }    }}void nnato_glfun7(n2glatom glatom){    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r,    		cmax = COLS + ROWS,    		curr;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS,           nr = x->nr,            nr1 = x->nr1,             nr2 = x->nr2,              nr3 = x->nr3 ;        if (!x->on) return;    if (!curr) curr = 0;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {				curr = i+j;	//current solid         glPushMatrix();        glTranslatef(i, j, 0);        glRotatef(anglx , 1, 0, 0);        glRotatef(angly , 0, 1, 0);        glRotatef(anglz , 0, 0, 1);        		if (curr == x->current) nnato_bing(x);		        glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        glTexCoord2f(i * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(-a, -b, nr);        glTexCoord2f((i + 1) * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(a, -b, nr1);        glTexCoord2f((i + 1) * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(a, b, nr2);        glTexCoord2f(i * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(-a, b, nr3);        glEnd();        glPopMatrix();		x->current = (x->current + 1) % cmax;	//cycle from 0 to lastsolid      }    }}void nnato_glfun8(n2glatom glatom)							// with rate++{    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS,           nr = x->nr,            nr1 = x->nr1,             nr2 = x->nr2 ;        if (!x->on) return;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {        glPushMatrix();        glTranslatef(i, j, 0);        glRotatef(anglx , 1, 0, 0);        glRotatef(angly , 0, 1, 0);        glRotatef(anglz , 0, 0, 1);                glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        glTexCoord2f(i * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(-a, -b, nr2 += x->rate);        glTexCoord2f((i + 1) * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(a, -b, nr1 -= x->rate);        glTexCoord2f((i + 1) * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(a, b, nr2 += x->rate);        glTexCoord2f(i * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(-a, b, nr1 -= x->rate);        glEnd();        glPopMatrix();      }    }}void nnato_glfun9(n2glatom glatom)							// with rate++{    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS,           nr = x->nr,            nr1 = x->nr1,             nr2 = x->nr2 ;        if (!x->on) return;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {        glPushMatrix();        glTranslatef(i, j, 0);        glRotatef(anglx , 1, 0, 0);        glRotatef(angly , 0, 1, 0);        glRotatef(anglz , 0, 0, 1);                glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        glTexCoord2f(i * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(-a, -b, nr2 += x->rate);        glTexCoord2f((i + 1) * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(a, -b, nr1 -= x->rate);        glTexCoord2f((i + 1) * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(a, b, nr2 += x->rate);        glTexCoord2f(i * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(-a, b, nr1 -= x->rate);        glEnd();        glPopMatrix();      }    }}void nnato_glregister(NNato *x, void *klientz){    n2glregisterx(x,n2objtype,x->glout,klientz);  // bkom 01 klient ov gl alimentari data}			void nnato_glfun10(n2glatom glatom)				//segment & whole image there{    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS;        if (!x->on) return;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {        glPushMatrix();        glTranslatef(i, j, 0);                glRotatef(anglx, 1, 0, 0);        glRotatef(angly, 0, 1, 0);        glRotatef(anglz, 0, 0, 1);                glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        	glTexCoord2f(0.0f ,0.0f);        glVertex3f(-a, -b, 0);        	glTexCoord2f(1.0f , 0.0f);        glVertex3f(a, -b, 0);        	glTexCoord2f(1.0f , 1.0f);        glVertex3f(a, b, 0);        	glTexCoord2f(0.0f , 1.0f);        glVertex3f(-a, b, 0);        glEnd();        glPopMatrix();      }    }}void nnato_glfun11(n2glatom glatom)							// with rate++ & whole image there{    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS,           nr = x->nr   ,            nr1 = x->nr1 ,             nr2 = x->nr2 ,              nr3 = x->nr3 ;        if (!x->on) return;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {        glPushMatrix();        glTranslatef(i, j, 0);        glRotatef(anglx , 1, 0, 0);        glRotatef(angly , 0, 1, 0);        glRotatef(anglz , 0, 0, 1);                glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        glTexCoord2f(0.0f , 1.0f);        glVertex3f(-a, -b, nr += x->rate);        glTexCoord2f((i + 1) * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(a, -b, nr1 -= x->rate);        glTexCoord2f((i + 1) * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(a, b, nr2 += x->rate);        glTexCoord2f(i * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(-a, b, nr3 -= x->rate);        glEnd();        glPopMatrix();      }    }}void nnato_glfun12(n2glatom glatom)				//segment & whole image there &rand1 bing{    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS,            nr = x->nr   ,            nr1 = x->nr1 ,             nr2 = x->nr2 ,              nr3 = x->nr3 ;        if (!x->on) return;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {        glPushMatrix();        glTranslatef(i, j, 0);                glRotatef(anglx, 1, 0, 0);        glRotatef(angly, 0, 1, 0);        glRotatef(anglz, 0, 0, 1);                glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        	glTexCoord2f(0.0f ,0.0f);        glVertex3f(-a, -b, nr);        	glTexCoord2f(1.0f , 0.0f);        glVertex3f(a, -b, nr);        	glTexCoord2f(1.0f , 1.0f);        glVertex3f(a, b, nr);        	glTexCoord2f(0.0f , 1.0f);        glVertex3f(-a, b, nr);        glEnd();        glPopMatrix();      }    }}void nnato_glfun13(n2glatom glatom)				//segment & whole image there &rand4 bing{    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS,            nr = x->nr   ,            nr1 = x->nr1 ,             nr2 = x->nr2 ,              nr3 = x->nr3 ;        if (!x->on) return;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {        glPushMatrix();        glTranslatef(i, j, 0);                glRotatef(anglx, 1, 0, 0);        glRotatef(angly, 0, 1, 0);        glRotatef(anglz, 0, 0, 1);                glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        	glTexCoord2f(0.0f ,0.0f);        glVertex3f(-a, -b, nr);        	glTexCoord2f(1.0f , 0.0f);        glVertex3f(a, -b, nr1);        	glTexCoord2f(1.0f , 1.0f);        glVertex3f(a, b, nr2);        	glTexCoord2f(0.0f , 1.0f);        glVertex3f(-a, b, nr3);        glEnd();        glPopMatrix();      }    }}// // returns a random double between 0 and 1 //double ran(void){		return(alea(0.0, 1.0));}//// returns a random value as double between min and max value // ANSI says that RAND_MAX = 32767, pretty piss poor I say!//double alea(double min, double max){	if (max >= min)		return ((max-min)*((double)rand()/RAND_MAX) + min);	else		return ((min-max)*((double)rand()/RAND_MAX) + max);	}