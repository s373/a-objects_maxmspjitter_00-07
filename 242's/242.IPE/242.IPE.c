//////////////// /*   Main   News   Archive                       Synthesis                         Analysis                             Filters                           Effects                             Other                                Old   Newbie   Links   Submit                                            alias-free waveform generation with analog filtering                                               Name: alias-free waveform generation with analog filtering                                               Type: waveform generation                                               References: Posted by Magnus Jonsson                                               Notes: see text                                               Download: synthesis001.txt                                             Square Waves                                               Name: Square Waves                                               Type: waveform generation                                               References: Posted by Sean Costello                                               Notes:                                                One way to do a square wave:                                               You need two buzz generators (see Dodge & Jerse, or the Csound source code, for implementation details). One of the buzz generators runs at                                               the desired square wave frequency, while the second buzz generator is exactly one octave above this pitch. Subtract the higher octave buzz                                               generator's output from the lower buzz generator's output - the result should be a signal with all odd harmonics, all at equal amplitude. Filter the                                               resultant signal (maybe integrate it). Voila, a bandlimited square wave! Well, I think it should work...                                               The one question I have with the above technique is whether it produces a waveform that truly resembles a square wave in the time domain. Even                                               if the number of harmonics, and the relative ratio of the harmonics, is identical to an "ideal" bandwidth-limited square wave, it may have an entirely                                               different waveshape. No big deal, unless the signal is processed by a nonlinearity, in which case the results of the nonlinear processing will be far                                               different than the processing of a waveform that has a similar shape to a square wave.                                             Pulsewidth modulation                                               Name: Pulsewidth modulation                                               Type: waveform generation                                               References: Steffan Diedrichsen                                               Notes:                                               Take an upramping sawtooth and its inverse, a downramping sawtooth.                                               Adding these two waves with a well defined delay between 0 and period (1/f)                                               results in a square wave with a duty cycle ranging from 0 to 100%.                                            fast sine calculation                                               Name: fast sine calculation                                               Type:                                                References: James McCartney in Computer Music Journal (when???), allso the Julius O. Smith paper                                               Notes: (posted by Niels Gorisse)                                               if you change the frequency, the amplitude rises (pitch lower) or lowers (pitch rise) a LOT                                               I fixed the first problem by thinking about what actually goes wrong.                                               The answer was to recalculate the phase for that frequency and the last value, and then continue normally.                                         Variables:                                         ip = phase of the first output sample in radians                                         w = freq*pi / samplerate                                         b1 = 2.0 * cos(w)                                         Init:                                         y1=sin(ip-w)                                         y2=sin(ip-2*w)                                         Loop:                                         y0 = b1*y1 - y2                                         y2 = y1                                         y1 = y0                                         output is in y0 (y0 = sin(ip + n*freq*pi / samplerate), n= 0, 1, 2, ... I *think*)                                         Later note by James McCartney:                                         if you unroll such a loop by 3 you can even eliminate the assigns!!                                         y0 = b1*y1 - y2                                         y2 = b1*y0 - y1                                         y1 = b1*y2 - y0                                            fast sine and cosine calculation                                               Name: fast sine and cosine calculation                                               Type:                                                References: John Lazzaro's SAOL code (most probably not JL who invented it) and Smith, J. O. and Cook, P., "The Second Order Digital                                               Waveguide Oscillator" (http://www-ccrma.stanford.edu/~jos)                                               Notes: Posted by Eric Scheirer, rewritten by Bram de Jong in pseudo-code                                         init:                                         float hertz = 440.f; //the freq you want                                         float samplerate = 44100.f; //the samplingrate                                         float a = 2.f*(float)sin(3.14159265358979*hertz/samplerate);                                         float s[2];                                         s[0] = 0.5f;                                         s[1] = 0.f;                                         loop:                                         s[0] = s[0] - a*s[1];                                         s[1] = s[1] + a*s[0];                                         output_sine = s[0];                                         output_cosine = s[1]                                            weird synthesis                                               Name: weird synthesis                                               Type: waveform generation!                                               References: invented by Andy Mucho (Mooocho!)                                               Notes: (quoted from Andy's mail...)                                               What I've done in a soft-synth I've been working on is used what I've termed Fooglers, no reason, just liked the name :) Anyway all I've done is                                               use a *VERY* short delay line of 256 samples and then use 2 controllable taps into the delay with High Frequency Damping, and a feedback                                               parameter.                                               Using a tiny fixed delay size of approx. 4.8ms (really 256 samples/1k memory with floats) means this costs, in terms of cpu consumption                                               practically nothing, and the filter is a real simple 1 pole low-pass filter. Maybe not DSP'litically correct but all I wanted was to avoid the high                                               frequencies trashing the delay line when high feedbacks (99%->99.9%) are used (when the fun starts ;).                                               I've been getting some really sexy sounds out of this idea, and of course you can have the delay line tuneable if you choose to use fractional                                               taps, but I'm happy with it as it is.. 1 nice simple, yet powerful addition to the base oscillators.                                               In reality you don't need 2 taps, but I found that using 2 added that extra element of funkiness...                                            waveform generation method                                               Name: waveform generation method                                               Type:                                                References: Paul Kellett                                               Notes: (Quoted from Paul's mail)                                               Below is another waveform generation method based on a train of sinc functions (actually an alternating loop along a sinc between t=0 and                                               t=period/2).                                               The code integrates the pulse train with a dc offset to get a sawtooth, but other shapes can be made in the usual ways... Note that 'dc' and 'leak'                                               may need to be adjusted for very high or low frequencies.                                               I don't know how original it is (I ought to read more) but it is of usable quality, particularly at low frequencies. There's some scope for optimisation                                               by using a table for sinc, or maybe a a truncated/windowed sinc?                                               I think it should be possible to minimise the aliasing by fine tuning 'dp' to slightly less than 1 so the sincs join together neatly, but I haven't found                                               the best way to do it. Any comments gratefully received.                                         float p=0.0f;      //current position                                         float dp=1.0f;     //change in postion per sample                                         float pmax;        //maximum position                                         float x;           //position in sinc function                                         float leak=0.995f; //leaky integrator                                         float dc;          //dc offset                                         float saw;         //output                                         //set frequency...                                           pmax = 0.5f * getSampleRate() / freqHz;                                           dc = -0.498f/pmax;                                         //for each sample...                                           p += dp;                                           if(p < 0.0f)                                           {                                             p = -p;                                             dp = -dp;                                           }                                           else if(p > pmax)                                           {                                             p = pmax + pmax - p;                                             dp = -dp;                                           }                                           x= pi * p;                                           if(x < 0.00001f)                                              x=0.00001f; //don't divide by 0                                           saw = leak*saw + dc + (float)sin(x)/(x);                                            sine calculation                                               Name: fast sine calculation                                               Type:                                                References: Phil Burk (his "I'm leaving music.dsp" post :( )                                               Notes: (rewritten by bram de jong)                                               Code from JSyn for a sine wave generator based on a Taylor Expansion. It is not as efficient as the filter methods, but it has linear frequency                                               control and is, therefore, suitable for FM or other time varying applications where accurate frequency is needed. The sine generated is accurate to                                               at least 16 bits.                                          for(i=0; i < nSamples ; i++)                                         {                                           //Generate sawtooth phasor to provide phase for sine generation                                           IncrementWrapPhase(phase, freqPtr[i]);                                           //Wrap phase back into region where results are more accurate                                           if(phase > 0.5)                                             yp = 1.0 - phase;                                           else                                           {                                             if(phase < -0.5)                                                yp = -1.0 - phase;                                             else                                                 yp = phase;                                           }                                           x = yp * PI;                                           x2 = x*x;                                           //Taylor expansion out to x**9/9! factored  into multiply-adds                                           fastsin = x*(x2*(x2*(x2*(x2*(1.0/362880.0)                                                     - (1.0/5040.0))                                                     + (1.0/120.0))                                                     - (1.0/6.0))                                                     + 1.0);                                           outPtr[i] = fastsin * amplPtr[i];                                         }                                            inverted parabolic envelope                                               Name: inverted parabolic envelope                                               Type: fast envelope generation                                               References: James McCartney                                               Notes:                                          dur = duration in samples                                         midlevel = amplitude at midpoint                                         beglevel = beginning and ending level (typically zero)                                         amp = midlevel - beglevel;                                         rdur = 1.0 / dur;                                         rdur2 = rdur * rdur;                                         level = beglevel;                                         slope = 4.0 * amp * (rdur - rdur2);                                         curve = -8.0 * amp * rdur2;                                         ...                                         for (i=0; i<dur; ++i) {                                                 level += slope;                                                 slope += curve;*/                                         //////////modified/para poulyv.15.10.01-->3 channels akademie//  dial 			map_beta(x->low, x->high, x->a, x->b)		//   cauchy.  A * tan((rnd-.5)*pi)#define _VERSION_      18.10.2001#include "Movies.h"#include "ext_common.h"#include "ext.h"#include "ext_user.h"#include <math.h>#include <stdlib.h>#include "n2.basicstrings.c"#include "n2.0000.h"     // nato.inkludes//object data structuretypedef struct zttz {	Object   n_ob;     // required max 	void     *n2hdr;   // required nato - position = signifikant _ must b 2nd		void             *dataout;      // n2data outlet	n2imgptr         gvelt;         // img buffer//	long               v1, v2, divx, divy, plus,debug;	short		 mode, variant, axis;	double 		ra, rb;	    Boolean          on,bypass,freeze,think,quarrel;  // nato.objstate flagz} NNato;// prototypesvoid *nnato_new(short variant);void nnato_assist(NNato *x, void *b, long msg, long nr, char *s);void nnato_info(NNato *x, void *p, void *b);void nnato_free(NNato *x);void nnato_processimage(NNato *x, n2atom *data);		// x +void nnato_processimage2(NNato *x, n2atom *data);	 // y +void nnato_processimage3(NNato *x, n2atom *data);       // x /void nnato_processimage4(NNato *x, n2atom *data);	// y /void nnato_processimage5(NNato *x, n2atom *data);	// x / 655void nnato_processimage6(NNato *x, n2atom *data);	// x + 655void nnato_processimage7(NNato *x, n2atom *data);	// 3x + *655void nnato_processimage8(NNato *x, n2atom *data);	//vray controvoid nnato_processimage9(NNato *x, n2atom *data);void nnato_on(NNato *x, long flag);void nnato_bypass(NNato *x, long flag);void nnato_freeze(NNato *x, long flag);void nnato_think(NNato *x, short val);void nnato_quarrel(NNato *x, short val);void nnato_bang(NNato *x);void nnato_int(NNato *x, long n);   void nnato_axis(NNato *x, long n);  void nnato_mode(NNato *x,   short mode);void nnato_v1(NNato *x,long v1);void nnato_v2(NNato *x,  long v2);void nnato_ra(NNato *x, double ra);void nnato_rb(NNato *x, double rb);void nnato_plus(NNato *x, long plus);void nnato_divx(NNato *x, long val);void nnato_divy(NNato *x, long val);void nnato_div(NNato *x, long val);void nnato_variant(NNato *x, short variant);double map_alpha(NNato *x);double map_beta(double low, double high, double a, double b, double mu, double sigsqr) ;double beta_value(double a, double b);double non_zero_random(void);double ran(void);double alea(double min, double max);double mapvalue(double x, double a, double b, double c, double d);void nnato_debug(NNato *x, long val);void     *nnato_class;main(void){	setup(&nnato_class, nnato_new, (method)nnato_free, (short)sizeof(NNato), 0L, 	      A_DEFLONG, 0);    n2objaddimagecmd();    n2addstatecmd((method)nnato_int,(method)nnato_bang,                  (method)nnato_on,(method)nnato_freeze,(method)nnato_bypass,                  (method)nnato_think,(method)nnato_quarrel,(method)nnato_variant,0); 	addmess((method)nnato_assist,	                   "assist",    	A_CANT,0); 	addmess((method)nnato_info,	                       "info",		    A_CANT,0);    addmess((method)nnato_mode,                     "mode",           A_DEFLONG,0);    addmess((method)nnato_v1,                   "v1",         A_DEFLONG,0);    addmess((method)nnato_v2,                    "v2",          A_DEFLONG,0);    addmess((method)nnato_ra,                        "a",           A_DEFFLOAT,0);    addmess((method)nnato_rb,                        "b",           A_DEFFLOAT,0);    addmess((method)nnato_plus,                        "+",           A_DEFLONG,0);		// mode, v1, v2, ra, rb, divx, divy, plus, variant          addmess((method)nnato_divx,                   "/x",          A_DEFLONG,0);     addmess((method)nnato_divy,                   "/y",          A_DEFLONG,0);     addmess((method)nnato_div,                   "/",          A_DEFLONG,0);          addmess((method)nnato_debug,                   "debug",          A_DEFLONG,0);          addmess((method)nnato_axis,                   "axis",          A_DEFLONG,0);//    n2addfklass("242.\%dev");        post("242.\% dev   -  [revised:%ldsier",nnato_class, _VERSION_);}void nnato_assist(NNato *x, void *b, long msg, long nr, char *s){	if (msg == 1)      // inlet			sprintf(s, "nato.imag.var%ld", x->divx);    else       {	   if (msg == 2)   // outlet	      if (nr == 0)	      	if  (!x->quarrel)			      	sprintf(s, "no quarrel & high  %ld",x->divx);		        else  sprintf(s, "quarrelling & & high  %ld",x->variant);       }}void nnato_info(NNato *x, void *p, void *b){      n2info();}void *nnato_new(short variant){	NNato      *x;    short      err;  		x = (NNato *)newobject(nnato_class);    n2addoutlet(x,&x->dataout);        if (err = n2objinit(x))       { post("242.dev  :  n2objinit err = %ld",err); return;}            if ((err = n2inewimage(&x->gvelt,n2idefwidth,n2idefheight)))       { post("242.dev  :  n2inewimage err = %ld",err); goto ikk;}      n2objsetimagefun(x,(method)nnato_processimage);		// igniting...	if(variant) x->variant = variant; else  x->variant = 0;	x->mode = 0;     x->v1 = 1;	  x->v2 = 110;	  x->ra = 0.;	x->rb=1.;		x->plus=0;		x->debug=0;		x->axis=0;   	x->on = true;    x->bypass = x->freeze = x->think = x->quarrel = false;           return (x);ikk:	nnato_free(x);}void nnato_free(NNato *x){    if (x->gvelt) { n2idisposeimage(x->gvelt); x->gvelt = 0;}    n2objfree(x);}void nnato_on(NNato *x, long flag){        x->on = flag;}    void nnato_bypass(NNato *x, long flag){        x->bypass = flag;}      void nnato_freeze(NNato *x, long flag){        x->freeze = flag;} void nnato_int(NNato *x, long n)    {								       n2defintstatefun(x,n);}void nnato_bang(NNato *x){   n2registerimage(x,n2objtype,x->dataout,0,x->gvelt);			// &what!?          ,&data,}void nnato_mode(NNato *x,   short mode){   x->mode = mode;}void nnato_axis(NNato *x, long n);{   x->axis = n;}void nnato_v1(NNato *x, long v1){   x->v1 = v1;}void nnato_v2(NNato *x, long v2){   x->v2 = v2;}void nnato_ra(NNato *x, double ra){   x->ra  = ra; if (x->debug) post("242dev::a:%f",x->ra);}void nnato_rb(NNato *x, double rb){   x->rb = rb;}void nnato_plus(NNato *x, long plus){   x->plus = plus;}void nnato_divx(NNato *x, long val){        x->divx=val;}void nnato_divy(NNato *x, long val){        x->divy=val;}void nnato_div(NNato *x, long val){        x->divx=x->divy = val;}void nnato_debug(NNato *x, long val){        x->debug = val;}double map_alpha(NNato *x){	double a , b;	a=x->ra; b=x->rb;	if (x->debug) post("242dev::a:%f\n242dev::a:%f",x->ra,x->rb);	return (  alea(a, b)  );}double map_beta(double low, double high, double a, double b, double mu, double sigsqr) 			//			ŒcŒv  paul.d  randbeta.c{	return(mapvalue(beta_value(a, b), mu, sigsqr,low, high));}// // beta distribution algorithm derived from Dodge's FORTRAN example, some of // the same variable names are used a and b should be doubles 0-1 // value returned between 0 and 1 //double beta_value(double a, double b){		double y1, y2, sum, ainv, binv;		ainv = 1.0/a;	binv = 1.0/b;	do 	{	 	y1 = pow(non_zero_random(), ainv);	 	y2 = pow(non_zero_random(), binv);	 	sum = y1+y2;	}	while(sum  > 1.0);		return(y1 / sum);}// // returns a non-zero random number between 0 and 1 // double non_zero_random(void){	double value;	do 	{		value = ran();	}	   	while (value == 0.0);		return(value);}// // returns a random double between 0 and 1 //double ran(void){		return(alea(0.0, 1.0));}//// returns a random value as double between min and max value // ANSI says that RAND_MAX = 32767, pretty piss poor I say!//double alea(double min, double max){	if (max >= min)		return ((max-min)*((double)rand()/RAND_MAX) + min);	else		return ((min-max)*((double)rand()/RAND_MAX) + max);	}//// maps x in the range a-b to the range c-d  returns a double //	double mapvalue (double x, double a, double b, double c, double d) {		return((x - a) * (d-c)/(b-a) + c);}void nnato_variant(NNato *x, short variant){   if (!variant)       n2objsetimagefun(x,(method)nnato_processimage);    else if (variant==1)       n2objsetimagefun(x,(method)nnato_processimage2);   else if (variant==2)       n2objsetimagefun(x,(method)nnato_processimage3);   else if (variant==3)       n2objsetimagefun(x,(method)nnato_processimage4);   else if (variant==4)       n2objsetimagefun(x,(method)nnato_processimage5);   else if (variant==5)       n2objsetimagefun(x,(method)nnato_processimage6);          else if (variant==6)       n2objsetimagefun(x,(method)nnato_processimage7);          else if (variant==7)       n2objsetimagefun(x,(method)nnato_processimage8);          else if (variant==8)       n2objsetimagefun(x,(method)nnato_processimage9);}void nnato_think(NNato *x, short val){   x->think = val;}void nnato_quarrel(NNato *x, short val){   x->quarrel = val;}void nnato_processimage(NNato *x, n2atom *data){                       long           i, j, k, l, roubitez, pix, gout                      ;                              short          width, height, err, mode = x->mode, axis=x->axis; 	long r1,g1,b1;                       	double			z		,  vangh, vangw					;    Ptr            src, dst, srcadresz, dstadresz;          n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate, dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);        if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.dev   : n2iensureimagedimeq err = %ld", err);             return;           }                    if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;                         dstpixmap   = n2igetpixmap(dstgvelt);         srcpixztate = n2igetpixstate(srcpixmap);                dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;               if (!n2ilockpix(dstpixmap)) goto ikk;                      srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);        vangh = n2mathdblpi/height;        vangw= n2mathdblpi/width;   //			--	-	cauchy		||		cauchy = Ad13 * tan ( (z-.5) * pi//			--	-	logist		||		l = - (log ( (1-z)/z ) + Bd13 )  /  Ad13//			--	-	hyperbcos		||		hypc =  Ad13 * log ( tan (z*pi / 2))//			--	-	arcsine		||		arcs =  Ad13 * (.5 - .5 * sin( (.5-z) * pi )//			--	-	exponencial	||		expon = - (log (1-z)) / Ad13//			--	-	sinus			||		sinu = Ad13 * sin (SMP&  * vang  * Bd13 )                                          float p=0.0f;      //current position                                         float dp=1.0f;     //change in postion per sample                                         float pmax;        //maximum position                                         float x;           //position in sinc function                                         float leak=0.995f; //leaky integrator                                         float dc;          //dc offset                                         float saw;         //output                                         //set frequency...                                           pmax = 0.5f * getSampleRate() / freqHz;                                           dc = -0.498f/pmax;                                         //for each sample...                                           p += dp;                                           if(p < 0.0f)                                           {                                             p = -p;                                             dp = -dp;                                           }                                           else if(p > pmax)                                           {                                             p = pmax + pmax - p;                                             dp = -dp;                                           }                                           x= pi * p;                                           if(x < 0.00001f)                                              x=0.00001f; //don't divide by 0                                           saw = leak*saw + dc + (float)sin(x)/(x);//-- -starthere                             for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                if(!axis);                      }                                      for(j = 0; j < width; j++)                 {                    pix = n2get32(src);                    r1=n2get32red(pix);                    r2=n2get32green(pix);                    r3=n2get32blue(pix);                    					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   + gout),					         n2klamp255(n2get32green(pix) + gout),					         n2klamp255(n2get32blue(pix)  + gout));									    src+=4;				    dst+=4;					                 }		     }		 } 		         else if (mode == 1)	//logist         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;            k = i % dx;            if (k==0) {               z =  map_alpha(x)  ;                gout = plus  - (log(1-z)/z + v2) / v1 ;		}                                      for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   + gout),					         n2klamp255(n2get32green(pix) + gout),					         n2klamp255(n2get32blue(pix)  + gout));									    src+=4;				    dst+=4;					                 }		     }		 } 	 else if (mode == 2)	// hyperbcos	hypc =  Ad13 * log ( tan (z*pi / 2))         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;            k = i % dx;            if (k==0) {               z =  map_alpha(x)  ;                gout = plus +  v1 * log( tan(z*n2mathpi/2) ) ;                   }                  for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   + gout),					         n2klamp255(n2get32green(pix) + gout),					         n2klamp255(n2get32blue(pix)  + gout));									    src+=4;				    dst+=4;					                 }		     }		 } 	 else if (mode == 3)	// arcsine arcs =  Ad13 * (.5 - .5 * sin( (.5-z) * pi )         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;            k = i % dx;            if (k==0) {               z =  map_alpha(x)  ;                gout = plus +  v1 * (.5 - .5*sin((.5-z)*n2mathpi));                    }                  for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   + gout),					         n2klamp255(n2get32green(pix) + gout),					         n2klamp255(n2get32blue(pix)  + gout));									    src+=4;				    dst+=4;					                 }		     }		 }  	 else if (mode == 4)	//expon = - (log (1-z)) / Ad13         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;            k = i % dx;            if (k==0) {               z =  map_alpha(x)  ;                gout = plus +  - (log(1-z)) / v1;                      }                for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   + gout),					         n2klamp255(n2get32green(pix) + gout),					         n2klamp255(n2get32blue(pix)  + gout));									    src+=4;				    dst+=4;					                 }		     }		 }  	 else if (mode == 5)	//sinu = Ad13 * sin (SMP&  * vang  * Bd13 )         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;            k = i % dx;            if (k==0) {   //            z =  map_alpha(x)  ;                gout = plus + v1 * sin (i * vangh * v2);                      }                for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   + gout),					         n2klamp255(n2get32green(pix) + gout),					         n2klamp255(n2get32blue(pix)  + gout));									    src+=4;				    dst+=4;					                 }		     }		 }  	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}				void nnato_processimage2(NNato *x, n2atom *data){                       long           i, j, k, l, roubitez, pix, gout                      ;                              short          width, height, err, mode = x->mode;                        	long		  		v1 = x->v1,					v2 = x->v2,					plus = x->plus,					dx = x->divx,					dy = x->divy	;	double			z		,  vangh, vangw					;    Ptr            src, dst, srcadresz, dstadresz;          n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate, dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);        if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.dev   : n2iensureimagedimeq err = %ld", err);             return;           }                    if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;                         dstpixmap   = n2igetpixmap(dstgvelt);         srcpixztate = n2igetpixstate(srcpixmap);                dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;               if (!n2ilockpix(dstpixmap)) goto ikk;                      srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);        vangh = n2mathdblpi/height;        vangw= n2mathdblpi/width;   //			--	-	cauchy		||		cauchy = Ad13 * tan ( (z-.5) * pi//			--	-	logist		||		l = - (log ( (1-z)/z ) + Bd13 )  /  Ad13//			--	-	hyperbcos		||		hypc =  Ad13 * log ( tan (z*pi / 2))//			--	-	arcsine		||		arcs =  Ad13 * (.5 - .5 * sin( (.5-z) * pi )//			--	-	exponencial	||		expon = - (log (1-z)) / Ad13//			--	-	sinus			||		sinu = Ad13 * sin (SMP&  * vang  * Bd13 )              if (!mode)		//cauchy         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                                       for(j = 0; j < width; j++)                 { 	             k = i % dy;	            if (k==0) {	 	               z =  map_alpha(x)  ;		                gout = plus +  v1 * tan( (z - .5) * n2mathpi );	                      }                     pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   + gout),					         n2klamp255(n2get32green(pix) + gout),					         n2klamp255(n2get32blue(pix)  + gout));									    src+=4;				    dst+=4;					                 }		     }		 } 		         else if (mode == 1)	//logist         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dy;	            if (k==0) {	               z =  map_alpha(x)  ;	                gout = plus  - (log(1-z)/z + v2) / v1 ;			}                                          pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   + gout),					         n2klamp255(n2get32green(pix) + gout),					         n2klamp255(n2get32blue(pix)  + gout));									    src+=4;				    dst+=4;					                 }		     }		 } 	 else if (mode == 2)	// hyperbcos	hypc =  Ad13 * log ( tan (z*pi / 2))         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dy;	            if (k==0) {	               z =  map_alpha(x)  ;	                gout = plus +  v1 * log( tan(z*n2mathpi/2) ) ;	                   }                      pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   + gout),					         n2klamp255(n2get32green(pix) + gout),					         n2klamp255(n2get32blue(pix)  + gout));									    src+=4;				    dst+=4;					                 }		     }		 } 	 else if (mode == 3)	// arcsine arcs =  Ad13 * (.5 - .5 * sin( (.5-z) * pi )         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dy;	            if (k==0) {	               z =  map_alpha(x)  ;	                gout = plus +  v1 * (.5 - .5*sin((.5-z)*n2mathpi));	                    }                      pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   + gout),					         n2klamp255(n2get32green(pix) + gout),					         n2klamp255(n2get32blue(pix)  + gout));									    src+=4;				    dst+=4;					                 }		     }		 }  	 else if (mode == 4)	//expon = - (log (1-z)) / Ad13         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dy;	            if (k==0) {	               z =  map_alpha(x)  ;	                gout = plus +  - (log(1-z)) / v1;	                      }                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   + gout),					         n2klamp255(n2get32green(pix) + gout),					         n2klamp255(n2get32blue(pix)  + gout));									    src+=4;				    dst+=4;					                 }		     }		 }  	 else if (mode == 5)	//sinu = Ad13 * sin (SMP&  * vang  * Bd13 )         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dx;	            if (k==0) {	   //            z =  map_alpha(x)  ;	                gout = plus + v1 * sin (j * vangh * v2);	                      }                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   + gout),					         n2klamp255(n2get32green(pix) + gout),					         n2klamp255(n2get32blue(pix)  + gout));									    src+=4;				    dst+=4;					                 }		     }		 }  	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}		void nnato_processimage3(NNato *x, n2atom *data){                       long           i, j, k, l, roubitez, pix, gout                      ;                              short          width, height, err, mode = x->mode;                        	long		  		v1 = x->v1,					v2 = x->v2,					plus = x->plus,					dx = x->divx,					dy = x->divy	;	double			z		,  vangh, vangw					;    Ptr            src, dst, srcadresz, dstadresz;          n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate, dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);        if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.dev   : n2iensureimagedimeq err = %ld", err);             return;           }                    if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;                         dstpixmap   = n2igetpixmap(dstgvelt);         srcpixztate = n2igetpixstate(srcpixmap);                dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;               if (!n2ilockpix(dstpixmap)) goto ikk;                      srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);        vangh = n2mathdblpi/height;        vangw= n2mathdblpi/width;   //			--	-	cauchy		||		cauchy = Ad13 * tan ( (z-.5) * pi//			--	-	logist		||		l = - (log ( (1-z)/z ) + Bd13 )  /  Ad13//			--	-	hyperbcos		||		hypc =  Ad13 * log ( tan (z*pi / 2))//			--	-	arcsine		||		arcs =  Ad13 * (.5 - .5 * sin( (.5-z) * pi )//			--	-	exponencial	||		expon = - (log (1-z)) / Ad13//			--	-	sinus			||		sinu = Ad13 * sin (SMP&  * vang  * Bd13 )              if (!mode)		//cauchy         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;             k = i % dx;            if (k==0) { 	               z =  map_alpha(x)  ;	                gout = plus +  v1 * tan( (z - .5) * n2mathpi );                      }                                      for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   / gout),					         n2klamp255(n2get32green(pix) / gout),					         n2klamp255(n2get32blue(pix)  / gout));									    src+=4;				    dst+=4;					                 }		     }		 } 		         else if (mode == 1)	//logist         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;            k = i % dx;            if (k==0) {               z =  map_alpha(x)  ;                gout = plus  - (log(1-z)/z + v2) / v1 ;		}                                      for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   / gout),					         n2klamp255(n2get32green(pix) / gout),					         n2klamp255(n2get32blue(pix)  / gout));									    src+=4;				    dst+=4;					                 }		     }		 } 	 else if (mode == 2)	// hyperbcos	hypc =  Ad13 * log ( tan (z*pi / 2))         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;            k = i % dx;            if (k==0) {               z =  map_alpha(x)  ;                gout = plus +  v1 * log( tan(z*n2mathpi/2) ) ;                   }                  for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   / gout),					         n2klamp255(n2get32green(pix) / gout),					         n2klamp255(n2get32blue(pix)  / gout));									    src+=4;				    dst+=4;					                 }		     }		 } 	 else if (mode == 3)	// arcsine arcs =  Ad13 * (.5 - .5 * sin( (.5-z) * pi )         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;            k = i % dx;            if (k==0) {               z =  map_alpha(x)  ;                gout = plus +  v1 * (.5 - .5*sin((.5-z)*n2mathpi));                    }                  for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   / gout),					         n2klamp255(n2get32green(pix) / gout),					         n2klamp255(n2get32blue(pix)  / gout));									    src+=4;				    dst+=4;					                 }		     }		 }  	 else if (mode == 4)	//expon = - (log (1-z)) / Ad13         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;            k = i % dx;            if (k==0) {               z =  map_alpha(x)  ;                gout = plus +  - (log(1-z)) / v1;                      }                for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   / gout),					         n2klamp255(n2get32green(pix) / gout),					         n2klamp255(n2get32blue(pix)  / gout));									    src+=4;				    dst+=4;					                 }		     }		 }  	 else if (mode == 5)	//sinu = Ad13 * sin (SMP&  * vang  * Bd13 )         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;            k = i % dx;            if (k==0) {   //            z =  map_alpha(x)  ;                gout = plus + v1 * sin (i * vangh * v2);                      }                for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   / gout),					         n2klamp255(n2get32green(pix) / gout),					         n2klamp255(n2get32blue(pix)  / gout));									    src+=4;				    dst+=4;					                 }		     }		 }  	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}		void nnato_processimage4(NNato *x, n2atom *data){                       long           i, j, k, l, roubitez, pix, gout                      ;                              short          width, height, err, mode = x->mode;                        	long		  		v1 = x->v1,					v2 = x->v2,					plus = x->plus,					dx = x->divx,					dy = x->divy	;	double			z		,  vangh, vangw					;    Ptr            src, dst, srcadresz, dstadresz;          n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate, dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);        if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.dev   : n2iensureimagedimeq err = %ld", err);             return;           }                    if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;                         dstpixmap   = n2igetpixmap(dstgvelt);         srcpixztate = n2igetpixstate(srcpixmap);                dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;               if (!n2ilockpix(dstpixmap)) goto ikk;                      srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);        vangh = n2mathdblpi/height;        vangw= n2mathdblpi/width;   //			--	-	cauchy		||		cauchy = Ad13 * tan ( (z-.5) * pi//			--	-	logist		||		l = - (log ( (1-z)/z ) + Bd13 )  /  Ad13//			--	-	hyperbcos		||		hypc =  Ad13 * log ( tan (z*pi / 2))//			--	-	arcsine		||		arcs =  Ad13 * (.5 - .5 * sin( (.5-z) * pi )//			--	-	exponencial	||		expon = - (log (1-z)) / Ad13//			--	-	sinus			||		sinu = Ad13 * sin (SMP&  * vang  * Bd13 )                                         float p=0.0f;      //current position                                         float dp=1.0f;     //change in postion per sample                                         float pmax;        //maximum position                                         float x;           //position in sinc function                                         float leak=0.995f; //leaky integrator                                         float dc;          //dc offset                                         float saw;         //output                                         //set frequency...                                           pmax = 0.5f * getSampleRate() / freqHz;                                           dc = -0.498f/pmax;                                         //for each sample...                                           p += dp;                                           if(p < 0.0f)                                           {                                             p = -p;                                             dp = -dp;                                           }                                           else if(p > pmax)                                           {                                             p = pmax + pmax - p;                                             dp = -dp;                                           }                                           x= pi * p;                                           if(x < 0.00001f)                                              x=0.00001f; //don't divide by 0                                           saw = leak*saw + dc + (float)sin(x)/(x);              if (!mode)		//cauchy         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                                       for(j = 0; j < width; j++)                 { 	             k = i % dy;	            if (k==0) {	 	               z =  map_alpha(x)  ;		                gout = plus +  v1 * tan( (z - .5) * n2mathpi );	                      }                     pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   / gout  + gout),					         n2klamp255(n2get32green(pix) / gout  + gout),					         n2klamp255(n2get32blue(pix)  / gout  +  gout));									    src+=4;				    dst+=4;					                 }		     }		 } 		         else if (mode == 1)	//logist         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dy;	            if (k==0) {	               z =  map_alpha(x)  ;	                gout = plus  - (log(1-z)/z + v2) / v1 ;			}                                          pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   /gout + gout),					         n2klamp255(n2get32green(pix) / gout + gout),					         n2klamp255(n2get32blue(pix)  /gout + gout));									    src+=4;				    dst+=4;					                 }		     }		 } 	 else if (mode == 2)	// hyperbcos	hypc =  Ad13 * log ( tan (z*pi / 2))         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dy;	            if (k==0) {	               z =  map_alpha(x)  ;	                gout = plus +  v1 * log( tan(z*n2mathpi/2) ) ;	                   }                      pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix) /gout   + gout),					         n2klamp255(n2get32green(pix) /gout + gout),					         n2klamp255(n2get32blue(pix)  /gout + gout));									    src+=4;				    dst+=4;					                 }		     }		 } 	 else if (mode == 3)	// arcsine arcs =  Ad13 * (.5 - .5 * sin( (.5-z) * pi )         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dy;	            if (k==0) {	               z =  map_alpha(x)  ;	                gout = plus +  v1 * (.5 - .5*sin((.5-z)*n2mathpi));	                    }                      pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)  / gout  + gout),					         n2klamp255(n2get32green(pix) / gout + gout),					         n2klamp255(n2get32blue(pix)  / gout  + gout));									    src+=4;				    dst+=4;					                 }		     }		 }  	 else if (mode == 4)	//expon = - (log (1-z)) / Ad13         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dy;	            if (k==0) {	               z =  map_alpha(x)  ;	                gout = plus +  - (log(1-z)) / v1;	                      }                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)  / gout  + gout),					         n2klamp255(n2get32green(pix) / gout + gout),					         n2klamp255(n2get32blue(pix)  /gout + gout));									    src+=4;				    dst+=4;					                 }		     }		 }  	 else if (mode == 5)	//sinu = Ad13 * sin (SMP&  * vang  * Bd13 )         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dx;	            if (k==0) {	   //            z =  map_alpha(x)  ;	                gout = plus + v1 * sin (j * vangh * v2);	                      }                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)  /gout + gout),					         n2klamp255(n2get32green(pix) /gout + gout),					         n2klamp255(n2get32blue(pix)  /gout + gout));									    src+=4;				    dst+=4;					                 }		     }		 }  	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}		void nnato_processimage5(NNato *x, n2atom *data){                       long           i, j, k, l, roubitez, pix, gout                      ;                              short          width, height, err, mode = x->mode;                        	long		  		v1 = x->v1,					v2 = x->v2,					plus = x->plus,					dx = x->divx,					dy = x->divy	;	double			z		,  vangh, vangw					;    Ptr            src, dst, srcadresz, dstadresz;          n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate, dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);        if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.dev   : n2iensureimagedimeq err = %ld", err);             return;           }                    if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;                         dstpixmap   = n2igetpixmap(dstgvelt);         srcpixztate = n2igetpixstate(srcpixmap);                dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;               if (!n2ilockpix(dstpixmap)) goto ikk;                      srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);        vangh = n2mathdblpi/height;        vangw= n2mathdblpi/width;   //			--	-	cauchy		||		cauchy = Ad13 * tan ( (z-.5) * pi//			--	-	logist		||		l = - (log ( (1-z)/z ) + Bd13 )  /  Ad13//			--	-	hyperbcos		||		hypc =  Ad13 * log ( tan (z*pi / 2))//			--	-	arcsine		||		arcs =  Ad13 * (.5 - .5 * sin( (.5-z) * pi )//			--	-	exponencial	||		expon = - (log (1-z)) / Ad13//			--	-	sinus			||		sinu = Ad13 * sin (SMP&  * vang  * Bd13 )              if (!mode)		//cauchy         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;             k = i % dx;            if (k==0) { 	               z =  map_alpha(x)  ;	                gout = plus +  v1 * tan( (z - .5) * n2mathpi );                      }                                      for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp655(n2get32red(pix)   / gout),					         n2klamp655(n2get32green(pix) / gout),					         n2klamp655(n2get32blue(pix)  / gout));									    src+=4;				    dst+=4;					                 }		     }		 } 		         else if (mode == 1)	//logist         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;            k = i % dx;            if (k==0) {               z =  map_alpha(x)  ;                gout = plus  - (log(1-z)/z + v2) / v1 ;		}                                      for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp655(n2get32red(pix)   / gout),					         n2klamp655(n2get32green(pix) / gout),					         n2klamp655(n2get32blue(pix)  / gout));									    src+=4;				    dst+=4;					                 }		     }		 } 	 else if (mode == 2)	// hyperbcos	hypc =  Ad13 * log ( tan (z*pi / 2))         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;            k = i % dx;            if (k==0) {               z =  map_alpha(x)  ;                gout = plus +  v1 * log( tan(z*n2mathpi/2) ) ;                   }                  for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp655(n2get32red(pix)   / gout),					         n2klamp655(n2get32green(pix) / gout),					         n2klamp655(n2get32blue(pix)  / gout));									    src+=4;				    dst+=4;					                 }		     }		 } 	 else if (mode == 3)	// arcsine arcs =  Ad13 * (.5 - .5 * sin( (.5-z) * pi )         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;            k = i % dx;            if (k==0) {               z =  map_alpha(x)  ;                gout = plus +  v1 * (.5 - .5*sin((.5-z)*n2mathpi));                    }                  for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp655(n2get32red(pix)   / gout),					         n2klamp655(n2get32green(pix) / gout),					         n2klamp655(n2get32blue(pix)  / gout));									    src+=4;				    dst+=4;					                 }		     }		 }  	 else if (mode == 4)	//expon = - (log (1-z)) / Ad13         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;            k = i % dx;            if (k==0) {               z =  map_alpha(x)  ;                gout = plus +  - (log(1-z)) / v1;                      }                for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp655(n2get32red(pix)   / gout),					         n2klamp655(n2get32green(pix) / gout),					         n2klamp655(n2get32blue(pix)  / gout));									    src+=4;				    dst+=4;					                 }		     }		 }  	 else if (mode == 5)	//sinu = Ad13 * sin (SMP&  * vang  * Bd13 )         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;            k = i % dx;            if (k==0) {   //            z =  map_alpha(x)  ;                gout = plus + v1 * sin (i * vangh * v2);                      }                for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp655(n2get32red(pix)   / gout),					         n2klamp655(n2get32green(pix) / gout),					         n2klamp655(n2get32blue(pix)  / gout));									    src+=4;				    dst+=4;					                 }		     }		 }  	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}		void nnato_processimage6(NNato *x, n2atom *data){                       long           i, j, k, l, roubitez, pix, gout                      ;                              short          width, height, err, mode = x->mode;                        	long		  		v1 = x->v1,					v2 = x->v2,					plus = x->plus,					dx = x->divx,					dy = x->divy	;	double			z		,  vangh, vangw					;    Ptr            src, dst, srcadresz, dstadresz;          n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate, dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);        if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.dev   : n2iensureimagedimeq err = %ld", err);             return;           }                    if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;                         dstpixmap   = n2igetpixmap(dstgvelt);         srcpixztate = n2igetpixstate(srcpixmap);                dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;               if (!n2ilockpix(dstpixmap)) goto ikk;                      srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);        vangh = n2mathdblpi/height;        vangw= n2mathdblpi/width;   //			--	-	cauchy		||		cauchy = Ad13 * tan ( (z-.5) * pi//			--	-	logist		||		l = - (log ( (1-z)/z ) + Bd13 )  /  Ad13//			--	-	hyperbcos		||		hypc =  Ad13 * log ( tan (z*pi / 2))//			--	-	arcsine		||		arcs =  Ad13 * (.5 - .5 * sin( (.5-z) * pi )//			--	-	exponencial	||		expon = - (log (1-z)) / Ad13//			--	-	sinus			||		sinu = Ad13 * sin (SMP&  * vang  * Bd13 )              if (!mode)		//cauchy         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;             k = i % dx;            if (k==0) { 	               z =  map_alpha(x)  ;	                gout = plus +  v1 * tan( (z - .5) * n2mathpi );                      }                                      for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp655(n2get32red(pix)   + gout),					         n2klamp655(n2get32green(pix) + gout),					         n2klamp655(n2get32blue(pix)  + gout));									    src+=4;				    dst+=4;					                 }		     }		 } 		         else if (mode == 1)	//logist         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;            k = i % dx;            if (k==0) {               z =  map_alpha(x)  ;                gout = plus  - (log(1-z)/z + v2) / v1 ;		}                                      for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp655(n2get32red(pix)   + gout),					         n2klamp655(n2get32green(pix) + gout),					         n2klamp655(n2get32blue(pix)  + gout));									    src+=4;				    dst+=4;					                 }		     }		 } 	 else if (mode == 2)	// hyperbcos	hypc =  Ad13 * log ( tan (z*pi / 2))         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;            k = i % dx;            if (k==0) {               z =  map_alpha(x)  ;                gout = plus +  v1 * log( tan(z*n2mathpi/2) ) ;                   }                  for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp655(n2get32red(pix)   + gout),					         n2klamp655(n2get32green(pix) + gout),					         n2klamp655(n2get32blue(pix)  + gout));									    src+=4;				    dst+=4;					                 }		     }		 } 	 else if (mode == 3)	// arcsine arcs =  Ad13 * (.5 - .5 * sin( (.5-z) * pi )         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;            k = i % dx;            if (k==0) {               z =  map_alpha(x)  ;                gout = plus +  v1 * (.5 - .5*sin((.5-z)*n2mathpi));                    }                  for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp655(n2get32red(pix)   + gout),					         n2klamp655(n2get32green(pix) + gout),					         n2klamp655(n2get32blue(pix)  + gout));									    src+=4;				    dst+=4;					                 }		     }		 }  	 else if (mode == 4)	//expon = - (log (1-z)) / Ad13         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;            k = i % dx;            if (k==0) {               z =  map_alpha(x)  ;                gout = plus +  - (log(1-z)) / v1;                      }                for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp655(n2get32red(pix)   + gout),					         n2klamp655(n2get32green(pix) + gout),					         n2klamp655(n2get32blue(pix)  + gout));									    src+=4;				    dst+=4;					                 }		     }		 }  	 else if (mode == 5)	//sinu = Ad13 * sin (SMP&  * vang  * Bd13 )         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;            k = i % dx;            if (k==0) {   //            z =  map_alpha(x)  ;                gout = plus + v1 * sin (i * vangh * v2);                      }                for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp655(n2get32red(pix)   + gout),					         n2klamp655(n2get32green(pix) + gout),					         n2klamp655(n2get32blue(pix)  + gout));									    src+=4;				    dst+=4;					                 }		     }		 }  	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}		void nnato_processimage7(NNato *x, n2atom *data){                       long           i, j, k, l, roubitez, pix, gout1,gout2,gout3 ,gout                     ;                              short          width, height, err, mode = x->mode;                        	long		  		v1 = x->v1,					v2 = x->v2,					plus = x->plus,					dx = x->divx,					dy = x->divy	;	double			z1,z2,z3,z		,  vangh, vangw					;    Ptr            src, dst, srcadresz, dstadresz;          n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate, dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);        if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.dev   : n2iensureimagedimeq err = %ld", err);             return;           }                    if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;                         dstpixmap   = n2igetpixmap(dstgvelt);         srcpixztate = n2igetpixstate(srcpixmap);                dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;               if (!n2ilockpix(dstpixmap)) goto ikk;                      srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);        vangh = n2mathdblpi/height;        vangw= n2mathdblpi/width;   //			--	-	cauchy		||		cauchy = Ad13 * tan ( (z-.5) * pi//			--	-	logist		||		l = - (log ( (1-z)/z ) + Bd13 )  /  Ad13//			--	-	hyperbcos		||		hypc =  Ad13 * log ( tan (z*pi / 2))//			--	-	arcsine		||		arcs =  Ad13 * (.5 - .5 * sin( (.5-z) * pi )//			--	-	exponencial	||		expon = - (log (1-z)) / Ad13//			--	-	sinus			||		sinu = Ad13 * sin (SMP&  * vang  * Bd13 )              if (!mode)		//cauchy         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                                       for(j = 0; j < width; j++)                 { 	             k = i % dy;	            if (k==0) {	 	               z1 =  map_alpha(x)  ; z2 =  map_alpha(x)  ; z3 =  map_alpha(x)  ;		                gout1 = plus +  v1 * tan( (z1 - .5) * n2mathpi );		                 gout2 = plus +  v1 * tan( (z2 - .5) * n2mathpi );		                  gout3 = plus +  v1 * tan( (z3 - .5) * n2mathpi );	                      }                     pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)  + gout1),					         n2klamp255(n2get32green(pix)  + gout2),					         n2klamp255(n2get32blue(pix)   +  gout3));									    src+=4;				    dst+=4;					                 }		     }		 } 		         else if (mode == 1)	//logist         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dy;	            if (k==0) {	               z1 =  map_alpha(x)  ; z2 =  map_alpha(x)  ; z3 =  map_alpha(x)  ;	                gout1 = plus  - (log(1-z1)/z1 + v2) / v1 ;	                gout2 = plus  - (log(1-z2)/z2 + v2) / v1 ;	                gout3 = plus  - (log(1-z3)/z3 + v2) / v1 ;			}                                          pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   /gout1 ),					         n2klamp255(n2get32green(pix) / gout2 ),					         n2klamp255(n2get32blue(pix)  /gout3 ));									    src+=4;				    dst+=4;					                 }		     }		 } 	 else if (mode == 2)	// hyperbcos	hypc =  Ad13 * log ( tan (z*pi / 2))         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dy;	            if (k==0) {	              z1 =  map_alpha(x)  ; z2 =  map_alpha(x)  ; z3 =  map_alpha(x)  ;	                gout1 = plus +  v1 * log( tan(z1*n2mathpi/2) ) ;	                gout2 = plus +  v1 * log( tan(z2*n2mathpi/2) ) ;	                gout3 = plus +  v1 * log( tan(z3*n2mathpi/2) ) ;	                   }                      pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix) /gout1   + gout1),					         n2klamp255(n2get32green(pix) /gout2+ gout2),					         n2klamp255(n2get32blue(pix)  /gout3 + gout3));									    src+=4;				    dst+=4;					                 }		     }		 } 	 else if (mode == 3)	// arcsine arcs =  Ad13 * (.5 - .5 * sin( (.5-z) * pi )         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dy;	            if (k==0) {	                 z1 =  map_alpha(x)  ; z2 =  map_alpha(x)  ; z3 =  map_alpha(x)  ;	                gout1 = plus +  v1 * (.5 - .5*sin((.5-z1)*n2mathpi));	                gout2 = plus +  v1 * (.5 - .5*sin((.5-z2)*n2mathpi));	                gout3 = plus +  v1 * (.5 - .5*sin((.5-z3)*n2mathpi));	                    }                      pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)  / gout1  + gout1),					         n2klamp255(n2get32green(pix) / gout2 + gout2),					         n2klamp255(n2get32blue(pix)  / gout3  + gout3));									    src+=4;				    dst+=4;					                 }		     }		 }  	 else if (mode == 4)	//expon = - (log (1-z)) / Ad13         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dy;	            if (k==0) {	              z1 =  map_alpha(x)  ; z2 =  map_alpha(x)  ; z3 =  map_alpha(x)  ;	                gout1 = plus +  - (log(1-z1)) / v1;	                gout2 = plus +  - (log(1-z2)) / v1;	                gout3 = plus +  - (log(1-z3)) / v1;	                      }                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)  / gout1  + gout1),					         n2klamp255(n2get32green(pix) / gout2 + gout2),					         n2klamp255(n2get32blue(pix)  /gout3 + gout3));									    src+=4;				    dst+=4;					                 }		     }		 }  	 else if (mode == 5)	//sinu = Ad13 * sin (SMP&  * vang  * Bd13 )         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dx;	            if (k==0) {	   z1 =  map_alpha(x)  ; z2 =  map_alpha(x)  ; z3 =  map_alpha(x)  ;	                gout1 = plus + v1 * sin (z1+j * vangh * v2);	                gout2 = plus + v1 * sin (z2+j * vangh * v2);	                gout3 = plus + v1 * sin (z3+j * vangh * v2);	                      }                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)  /gout1 + gout1),					         n2klamp255(n2get32green(pix) /gout2 + gout2),					         n2klamp255(n2get32blue(pix)  /gout3 + gout3));									    src+=4;				    dst+=4;					                 }		     }		 }  	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}void nnato_processimage8(NNato *x, n2atom *data){                       long           i, j, k, l, roubitez, pix, gout1,gout2,gout3 ,gout                     ;                              short          width, height, err, mode = x->mode;                        	long		  		v1 = x->v1,					v2 = x->v2,					plus = x->plus,					dx = x->divx,					dy = x->divy	;	double			z1,z2,z3,z		,  vangh, vangw					;    Ptr            src, dst, srcadresz, dstadresz;          n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate, dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);        if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.dev   : n2iensureimagedimeq err = %ld", err);             return;           }                    if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;                         dstpixmap   = n2igetpixmap(dstgvelt);         srcpixztate = n2igetpixstate(srcpixmap);                dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;               if (!n2ilockpix(dstpixmap)) goto ikk;                      srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);        vangh = n2mathdblpi/height;        vangw= n2mathdblpi/width;   //			--	-	cauchy		||		cauchy = Ad13 * tan ( (z-.5) * pi//			--	-	logist		||		l = - (log ( (1-z)/z ) + Bd13 )  /  Ad13//			--	-	hyperbcos		||		hypc =  Ad13 * log ( tan (z*pi / 2))//			--	-	arcsine		||		arcs =  Ad13 * (.5 - .5 * sin( (.5-z) * pi )//			--	-	exponencial	||		expon = - (log (1-z)) / Ad13//			--	-	sinus			||		sinu = Ad13 * sin (SMP&  * vang  * Bd13 )              if (!mode)		//cauchy         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                                       for(j = 0; j < width; j++)                 { 	             k = j % dy;	            if (k==0) {	 	               z1 =  map_alpha(x)  ; z2 =  map_alpha(x)  ; z3 =  map_alpha(x)  ;	                      } 		                gout1 = plus +  v1 * tan( (z1 - .5) * n2mathpi );		                 gout2 = plus +  v1 * tan( (z2 - .5) * n2mathpi );		                  gout3 = plus +  v1 * tan( (z3 - .5) * n2mathpi );                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)  + gout1),					         n2klamp255(n2get32green(pix)  + gout2),					         n2klamp255(n2get32blue(pix)   +  gout3));									    src+=4;				    dst+=4;					                 }		     }		 } 		         else if (mode == 1)	//logist         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dy;	            if (k==0) {	               z1 =  map_alpha(x)  ; z2 =  map_alpha(x)  ; z3 =  map_alpha(x)  ;	                gout1 = plus  - (log(1-z1)/z1 + v2) / v1 ;	                gout2 = plus  - (log(1-z2)/z2 + v2) / v1 ;	                gout3 = plus  - (log(1-z3)/z3 + v2) / v1 ;			}                                          pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   /gout1 ),					         n2klamp255(n2get32green(pix) / gout2 ),					         n2klamp255(n2get32blue(pix)  /gout3 ));									    src+=4;				    dst+=4;					                 }		     }		 } 	 else if (mode == 2)	// hyperbcos	hypc =  Ad13 * log ( tan (z*pi / 2))         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dy;	            if (k==0) {	              z1 =  map_alpha(x)  ; z2 =  map_alpha(x)  ; z3 =  map_alpha(x)  ;	                gout1 = plus +  v1 * log( tan(z1*n2mathpi/2) ) ;	                gout2 = plus +  v1 * log( tan(z2*n2mathpi/2) ) ;	                gout3 = plus +  v1 * log( tan(z3*n2mathpi/2) ) ;	                   }                      pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix) /gout1   + gout1),					         n2klamp255(n2get32green(pix) /gout2+ gout2),					         n2klamp255(n2get32blue(pix)  /gout3 + gout3));									    src+=4;				    dst+=4;					                 }		     }		 } 	 else if (mode == 3)	// arcsine arcs =  Ad13 * (.5 - .5 * sin( (.5-z) * pi )         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dy;	            if (k==0) {	                 z1 =  map_alpha(x)  ; z2 =  map_alpha(x)  ; z3 =  map_alpha(x)  ;	                gout1 = plus +  v1 * (.5 - .5*sin((.5-z1)*n2mathpi));	                gout2 = plus +  v1 * (.5 - .5*sin((.5-z2)*n2mathpi));	                gout3 = plus +  v1 * (.5 - .5*sin((.5-z3)*n2mathpi));	                    }                      pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)  / gout1  + gout1),					         n2klamp255(n2get32green(pix) / gout2 + gout2),					         n2klamp255(n2get32blue(pix)  / gout3  + gout3));									    src+=4;				    dst+=4;					                 }		     }		 }  	 else if (mode == 4)	//expon = - (log (1-z)) / Ad13         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dy;	            if (k==0) {	              z1 =  map_alpha(x)  ; z2 =  map_alpha(x)  ; z3 =  map_alpha(x)  ;	                gout1 = plus +  - (log(1-z1)) / v1;	                gout2 = plus +  - (log(1-z2)) / v1;	                gout3 = plus +  - (log(1-z3)) / v1;	                      }                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)  / gout1  + gout1),					         n2klamp255(n2get32green(pix) / gout2 + gout2),					         n2klamp255(n2get32blue(pix)  /gout3 + gout3));									    src+=4;				    dst+=4;					                 }		     }		 }  	 else if (mode == 5)	//sinu = Ad13 * sin (SMP&  * vang  * Bd13 )         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dx;	            if (k==0) {	   z1 =  map_alpha(x)  ; z2 =  map_alpha(x)  ; z3 =  map_alpha(x)  ;	                gout1 = plus + v1 * sin (z1+j * vangh * v2);	                gout2 = plus + v1 * sin (z2+j * vangh * v2);	                gout3 = plus + v1 * sin (z3+j * vangh * v2);	                      }                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)  /gout1 + gout1),					         n2klamp255(n2get32green(pix) /gout2 + gout2),					         n2klamp255(n2get32blue(pix)  /gout3 + gout3));									    src+=4;				    dst+=4;					                 }		     }		 }  	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}void nnato_processimage9(NNato *x, n2atom *data){                       long           i, j, k, l, roubitez, pix, gout1,gout2,gout3 ,gout                     ;                              short          width, height, err, mode = x->mode;                        	long		  		v1 = x->v1,					v2 = x->v2,					plus = x->plus,					dx = x->divx,					dy = x->divy	;	double			z1,z2,z3,z		,  vangh, vangw					;    Ptr            src, dst, srcadresz, dstadresz;          n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate, dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);        if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.dev   : n2iensureimagedimeq err = %ld", err);             return;           }                    if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;                         dstpixmap   = n2igetpixmap(dstgvelt);         srcpixztate = n2igetpixstate(srcpixmap);                dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;               if (!n2ilockpix(dstpixmap)) goto ikk;                      srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);        vangh = n2mathdblpi/height;        vangw= n2mathdblpi/width;   //			--	-	cauchy		||		cauchy = Ad13 * tan ( (z-.5) * pi//			--	-	logist		||		l = - (log ( (1-z)/z ) + Bd13 )  /  Ad13//			--	-	hyperbcos		||		hypc =  Ad13 * log ( tan (z*pi / 2))//			--	-	arcsine		||		arcs =  Ad13 * (.5 - .5 * sin( (.5-z) * pi )//			--	-	exponencial	||		expon = - (log (1-z)) / Ad13//			--	-	sinus			||		sinu = Ad13 * sin (SMP&  * vang  * Bd13 )              if (!mode)		//cauchy         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                                       for(j = 0; j < width; j++)                 { 	             k = j % dy;	            if (k==0) {	 	               z1 =  map_alpha(x)  ; z2 =  map_alpha(x)  ; z3 =  map_alpha(x)  ;	                      } 		                gout1 = plus +  v1 * tan( (z3 - .5) * n2mathpi );		                 gout2 = plus +  v1 * tan( (z3 - .5) * n2mathpi );		                  gout3 = plus +  v1 * tan( (z3 - .5) * n2mathpi );                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)  + gout1),					         n2klamp255(n2get32green(pix)  + gout2),					         n2klamp255(n2get32blue(pix)   +  gout3));									    src+=4;				    dst+=4;					                 }		     }		 } 		         else if (mode == 1)	//logist         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dy;	            if (k==0) {	               z1 =  map_alpha(x)  ; z2 =  map_alpha(x)  ; z3 =  map_alpha(x)  ;	                gout1 = plus  - (log(1-z1)/z1 + v2) / v1 ;	                gout2 = plus  - (log(1-z2)/z2 + v2) / v1 ;	                gout3 = plus  - (log(1-z3)/z3 + v2) / v1 ;			}                                          pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)   /gout1 ),					         n2klamp255(n2get32green(pix) / gout2 ),					         n2klamp255(n2get32blue(pix)  /gout3 ));									    src+=4;				    dst+=4;					                 }		     }		 } 	 else if (mode == 2)	// hyperbcos	hypc =  Ad13 * log ( tan (z*pi / 2))         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dy;	            if (k==0) {	              z1 =  map_alpha(x)  ; z2 =  map_alpha(x)  ; z3 =  map_alpha(x)  ;	                gout1 = plus +  v1 * log( tan(z1*n2mathpi/2) ) ;	                gout2 = plus +  v1 * log( tan(z2*n2mathpi/2) ) ;	                gout3 = plus +  v1 * log( tan(z3*n2mathpi/2) ) ;	                   }                      pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix) /gout1   + gout1),					         n2klamp255(n2get32green(pix) /gout2+ gout2),					         n2klamp255(n2get32blue(pix)  /gout3 + gout3));									    src+=4;				    dst+=4;					                 }		     }		 } 	 else if (mode == 3)	// arcsine arcs =  Ad13 * (.5 - .5 * sin( (.5-z) * pi )         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dy;	            if (k==0) {	                 z1 =  map_alpha(x)  ; z2 =  map_alpha(x)  ; z3 =  map_alpha(x)  ;	                gout1 = plus +  v1 * (.5 - .5*sin((.5-z1)*n2mathpi));	                gout2 = plus +  v1 * (.5 - .5*sin((.5-z2)*n2mathpi));	                gout3 = plus +  v1 * (.5 - .5*sin((.5-z3)*n2mathpi));	                    }                      pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)  / gout1  + gout1),					         n2klamp255(n2get32green(pix) / gout2 + gout2),					         n2klamp255(n2get32blue(pix)  / gout3  + gout3));									    src+=4;				    dst+=4;					                 }		     }		 }  	 else if (mode == 4)	//expon = - (log (1-z)) / Ad13         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dy;	            if (k==0) {	              z1 =  map_alpha(x)  ; z2 =  map_alpha(x)  ; z3 =  map_alpha(x)  ;	                gout1 = plus +  - (log(1-z1)) / v1;	                gout2 = plus +  - (log(1-z2)) / v1;	                gout3 = plus +  - (log(1-z3)) / v1;	                      }                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)  / gout1  + gout1),					         n2klamp255(n2get32green(pix) / gout2 + gout2),					         n2klamp255(n2get32blue(pix)  /gout3 + gout3));									    src+=4;				    dst+=4;					                 }		     }		 }  	 else if (mode == 5)	//sinu = Ad13 * sin (SMP&  * vang  * Bd13 )         {               for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                for(j = 0; j < width; j++)                 {	            k = i % dx;	            if (k==0) {	   z1 =  map_alpha(x)  ; z2 =  map_alpha(x)  ; z3 =  map_alpha(x)  ;	                gout1 = plus + v1 * sin (z1+j * vangh * v2);	                gout2 = plus + v1 * sin (z2+j * vangh * v2);	                gout3 = plus + v1 * sin (z3+j * vangh * v2);	                      }                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp255(n2get32red(pix)  /gout1 + gout1),					         n2klamp255(n2get32green(pix) /gout2 + gout2),					         n2klamp255(n2get32blue(pix)  /gout3 + gout3));									    src+=4;				    dst+=4;					                 }		     }		 }  	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}