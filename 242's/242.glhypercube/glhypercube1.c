//draw a hypercube, screen saver, after - Richard Asbury//port to nato, Andre Sier 021205#include "Movies.h"#include "ext.h"#include "ext_common.h"#include "ext_user.h"#include "n2.basicstrings.c"#include "n2.0000.h"#include "agl.h"#include "glut.h"#include "math.h"#include <stdlib.h> const double radconv = 0.0174533;const double origpt[16][4] = {	{1.0, 1.0, 1.0, 1.0},	{1.0, 1.0, 1.0, -1.0},	{1.0, 1.0, -1.0, 1.0},	{1.0, 1.0, -1.0, -1.0},	{1.0, -1.0, 1.0, 1.0},	{1.0, -1.0, 1.0, -1.0},	{1.0, -1.0, -1.0, 1.0},	{1.0, -1.0, -1.0, -1.0},	{-1.0, 1.0, 1.0, 1.0},	{-1.0, 1.0, 1.0, -1.0},	{-1.0, 1.0, -1.0, 1.0},	{-1.0, 1.0, -1.0, -1.0},	{-1.0, -1.0, 1.0, 1.0},	{-1.0, -1.0, 1.0, -1.0},	{-1.0, -1.0, -1.0, 1.0},	{-1.0, -1.0, -1.0, -1.0}};const int connect[16][4] = {	{1, 2, 4, 8},	{0, 3, 5, 9},	{0, 3, 6, 10},	{0, 0, 7, 11},	{0, 5, 6, 12},	{0, 0, 7, 13},	{0, 0, 7, 14},	{0, 0, 0, 15},	{0, 9, 10, 12},	{0, 0, 11, 13},	{0, 0, 11, 14},	{0, 0, 10, 15},	{0, 0, 13, 14},	{0, 0, 0, 15},	{0, 0, 0, 15},	{0, 0, 0, 0}};const int face[24][4] = {	{1, 0, 2, 3},	{5, 4, 6, 7},	{9, 8, 10, 11},	{13, 12, 14, 15},	{1, 0, 4, 5},	{3, 2, 6, 7},	{9, 8, 12, 13},	{11, 10, 14, 15},	{1, 0, 8, 9},	{3, 2, 10, 11},	{5, 4, 12, 13},	{7, 6, 14, 15},	{2, 0, 4, 6},	{3, 1, 5, 7},	{10, 8, 12, 14},	{11, 9, 13, 15},	{2, 0, 8, 10},	{3, 1, 9, 11},	{6, 4, 12, 14},	{7, 5, 13, 15},	{4, 0, 8, 12},	{5, 1, 9, 13},	{6, 2, 10, 14},	{7, 3, 11, 15}};typedef struct zttz {	Object    n_ob; 	void     *n2hdr;    // required nato - position = important _ must b 2nd	    void   	 *glout;	// out gl fun    short     type, grid, step;//removed gridy and gridx->grid for vfun compatibility    GLfloat   vertex,vertex2,red,green,blue,              normalx,normaly,normalz, rate;//    float     posit[MAXGRID][MAXGRID];  //globalize it    GLboolean texture,border, calcFaceNorms, drawFaceNorms, antialias;                  Boolean        on, doubl, ignt;  		GLboolean	move;	float		offsetx, offsety;	//	short		listlenght, oplenght;	 long      shademodel;} NNato;void *nnato_new(void);void nnato_assist(NNato *x, void *b, long msg, long nr, char *s);void nnato_info(NNato *x, void *p, void *b);void nnato_free(NNato *x);void nnato_on(NNato *x, long flag);void nnato_bang(NNato *x);void nnato_int(NNato *x, long n);   void nnato_variant(NNato *x, short variant);void nnato_type(NNato *x, short type);void nnato_shademodel(NNato *x, long type);void nnato_klr(NNato *x, long red, long green, long blue);void nnato_normalz(NNato *x, long koordx, long koordy, long koordz);void nnato_texture(NNato *x, long flag);void nnato_revertgeo(NNato *x);void nnato_revert(NNato *x);void nnato_vectinit(NNato *x);void nnato_grid(NNato *x, long grid);void nnato_list(NNato *x, Symbol *s, short argc, Atom *argv);void nnato_float(NNato *x,double flag);				void nnato_st(NNato *x, float st);void nnato_doubl(NNato *x, long flag);void nnato_ignitv(NNato *x, int flaag, float flag);void nnato_shifth(NNato *x, int amount);void nnato_shifthh(NNato *x, int amount);void nnato_rate(NNato *x, float n);void nnato_border(NNato *x, long flag);void nnato_offset(NNato *x, float oofx, float oofy);void nnato_hypercube_auto (NNato *x );void nnato_hypecube_refresh(NNato *x);void nnato_hypecube_rotatewx(NNato *x,double a);void nnato_hypecube_rotatewy(NNato *x,double a);void nnato_hypecube_rotatewz(NNato *x,double a);void nnato_hypecube_scale(NNato *x,double s);void nnato_hypecube_iterate(NNato *x);void nnato_hypercube_move (NNato *x, int move );double ran(void);double alea(double min, double max);void nnato_glfun(n2glatom glatom);void nnato_glfun2(n2glatom glatom);		//void nnato_glfun3(n2glatom glatom);void nnato_glfun4(n2glatom glatom);void nnato_glregister(NNato *x, void *klientz);void    *nnato_class;//globais	double currpt[16][4];	double angle[6];	double angvel[6];	double angdest[6];	double pos[3], vel[3], dest[3];	const double angular_acc = 0.1;	const double redirect_limit = 10.0;	const double max_angular_vel = 3.0;	const double scalar_acc = 0.005;	const double max_scalar_vel = 0.15;	const double alpha_wave_length = 20.0;	const double alpha_fade_val = alpha_wave_length * 159.15494309;	const double edge_alpha = 1.0;	const double face_alpha = 0.5;main(){	setup(&nnato_class, nnato_new, (method)nnato_free, (short)sizeof(NNato), 0L, 0L, 0); 	addmess((method)nnato_assist,	                  "assist",          	A_CANT,0); 	addmess((method)nnato_info,	                      "info",		        A_CANT,0);    n2objaddglcmd();    n2addstatecmd((method)nnato_int,(method)nnato_bang,                  (method)nnato_on,-1,-1,-1,-1,(method)nnato_variant,0);    addmess((method)nnato_klr,                        "color",              A_DEFLONG,A_DEFLONG,A_DEFLONG,0);    addmess((method)nnato_texture,                    "texture",            A_DEFLONG,0);    addmess((method)nnato_revert,                     "revert",             0);    addmess((method)nnato_shademodel,"model",A_DEFLONG,0);    addmess((method)nnato_type,"type",A_DEFLONG,0);    addmess((method)nnato_normalz,"normal",A_DEFLONG,A_DEFLONG,A_DEFLONG,0);    addmess((method)nnato_border,"border",A_DEFLONG,0);    post("242.glhypercube, a++sier,2002",0);    n2addfklass("242.glterrain02");	}double ran(void){		return(alea(0.0, 1.0));}double alea(double min, double max){	if (max >= min)		return ((max-min)*((double)rand()/RAND_MAX) + min);	else		return ((min-max)*((double)rand()/RAND_MAX) + max);	}void nnato_assist(NNato *x, void *b, long msg, long nr, char *s){}void nnato_info(NNato *x, void *p, void *b){ //     n2info();}void *nnato_new(){    NNato      *x;	short      err, i,j;	x = (NNato *)newobject(nnato_class);    n2addoutlet(x,&x->glout);        if (err = n2objinit(x))       { post("242.glplain :  n2initobjekt err = %ld",err); return;} 	x->ignt=0;    nnato_revert(x);    post("revert bypassed",0);//    nnato_vectinit(x);	    n2objsetglregister(x,(method)nnato_glregister);   // zpecify gl regizter routine    n2objsetglfun(x,(method)nnato_glfun);             // zpecify gl drau routine    post("registered and set fun",0);			x->on = true;    post("x->on = true",0);        	return (x);   ikk:	nnato_free(x);}void nnato_free(NNato *x){   //	if(posit)		    n2objfree(x);}void nnato_on(NNato *x, long flag){        x->on = flag;}  void nnato_int(NNato *x, long n)    {								       if (!n) x->on = false;   else x->on = true;}void nnato_bang(NNato *x){   n2gldraw(x, n2objtype);}void nnato_variant(NNato *x, short variant){   if (!variant) n2objsetglfun(x,(method)nnato_glfun);}void nnato_type(NNato *x, short type){   if (type >= 0 && type <= 9) x->type = type;}void nnato_klr(NNato *x, long red, long green, long blue){   x->red   = (float)red   * 0.01;   x->green = (float)green * 0.01;   x->blue  = (float)blue  * 0.01;      }  void nnato_normalz(NNato *x, long koordx, long koordy, long koordz){   x->normalx  = (float)koordx * 0.01;   x->normaly  = (float)koordy * 0.01;   x->normalz  = (float)koordz * 0.01;      }  void nnato_shademodel(NNato *x, long type){   if (type == 0) x->shademodel = GLU_SMOOTH;   else if (type == 1) x->shademodel = GLU_FLAT;   else if (type == 2) x->shademodel = GLU_NONE;}void nnato_doubl(NNato *x, long flag){    x->doubl = flag;}void nnato_texture(NNato *x, long flag){    x->texture = flag;}void nnato_border(NNato *x, long flag){        x->border = flag;}  void nnato_revert(NNato *x){	    x->normalx = x->normaly = 0.0;    x->normalz = 1.0;        //    nnato_grid(x,64);    x->grid=64;//    x->grid=128;  //  x->grid=128;	x->ignt=0;    x->step=0;    x->texture = true;    x->rate=0.;        x->border=0;    nnato_klr(x,50,50,50);        x->calcFaceNorms = 0;    x->drawFaceNorms = 0;    x->antialias = 0;    x->offsetx = 1.;    x->offsety = -1.;        x->move = 1;}void nnato_hypercube_auto (NNato *x ){	int i,j;	for (i = 0; i < 6; i++) {		angle[i] = rand() % 360;		angvel[i] = (double) (rand() % 100) / 20.0;		angdest[i] = rand() % 360;	}	for (j = 0; j < 3; j++) {		pos[j] = (rand() % 20) - 10;		dest[j] = (rand() % 20) - 10;		vel[j] = (double) ((rand() % 20) - 10) / 10.0;	}}void nnato_hypecube_refresh(NNato *x){	int i,j;	for (i = 0; i < 16; i++) {		for ( j = 0; j < 4; j++)			currpt[i][j] = origpt[i][j];	}}void nnato_hypecube_rotatewx(NNato *x,double a){	double temp;	double cosang = cos(a), sinang = sin(a);	int i;	for (i = 0; i < 16; i++) {		temp = currpt[i][0];		currpt[i][0] = cosang * temp - sinang * currpt[i][3];		currpt[i][3] = sinang * temp + cosang * currpt[i][3];	}}void nnato_hypecube_rotatewy(NNato *x,double a){	double temp;	double cosang = cos(a), sinang = sin(a);	int i;	for (i = 0; i < 16; i++) {		temp = currpt[i][1];		currpt[i][1] = cosang * temp - sinang * currpt[i][3];		currpt[i][3] = sinang * temp + cosang * currpt[i][3];	}}void nnato_hypecube_rotatewz(NNato *x,double a){	double temp;	double cosang = cos(a), sinang = sin(a);	int i;	for (i = 0; i < 16; i++) {		temp = currpt[i][2];		currpt[i][2] = cosang * temp - sinang * currpt[i][3];		currpt[i][3] = sinang * temp + cosang * currpt[i][3];	}}void nnato_hypecube_scale(NNato *x,double s){	int i,j;	for ( i = 0; i < 16; i++) {		for ( j = 0; j < 3; j++) 			currpt[i][j] = currpt[i][j] * s;	}}void nnato_hypecube_iterate(NNato *x){	// angles	int i,j;	for (i = 0; i < 6; i++) {		angle[i] += angvel[i];		while (angle[i] > 360.0) angle[i] -= 360.0;		while (angle[i] < 0.0) angle[i] += 360.0;		if (fmod(angle[i] - angdest[i] + 360.0, 360.0) > fmod(angdest[i] - angle[i] + 360.0, 360.0)) 			angvel[i] += angular_acc;		else 			angvel[i] -= angular_acc;		if (fabs(angle[i] - angdest[i]) < redirect_limit) 			angdest[i] = rand() % 360;		if (angvel[i] > max_angular_vel) angvel[i] = max_angular_vel;		if (angvel[i] < -max_angular_vel) angvel[i] = -max_angular_vel;	}	// position	for (j = 0; j < 3; j++) {		pos[j] += vel[j];		if (fabs(pos[j] - dest[j]) < 1.0) 			dest[j] = (double) ((rand() % 20) - 10);		if (pos[j] > 10.0 && vel[j] > 0.0) vel[j] = -vel[j];		if (pos[j] < -10.0 && vel[j] < 0.0) vel[j] = -vel[j];		if (pos[j] < dest[j]) 			vel[j] += scalar_acc;		else 			vel[j] -= scalar_acc;		if (vel[j] > max_scalar_vel) vel[j] = max_scalar_vel;		if (vel[j] < -max_scalar_vel) vel[j] = -max_scalar_vel;	}}void nnato_hypecube_move(NNato *x, int move){	x->move = move;}void nnato_glfun(n2glatom glatom) // draw wireframe{    NNato *x = (NNato *)n2getglatomobj(glatom);	int i, j, k;	double color[16];	double temp; double s = 1.5;	double cosanga = cos(angle[3] * radconv); double sinanga = sin(angle[3] * radconv);	double cosangb = cos(angle[4] * radconv); double sinangb = sin(angle[4] * radconv);	double cosangc = cos(angle[5] * radconv); double sinangc = sin(angle[5] * radconv);       if (!x->on) return;    if (x->move) nnato_hypercube_iterate(x);	for (i = 0; i < 16; i++) {		for ( j = 0; j < 4; j++)			currpt[i][j] = origpt[i][j];	}	for (i = 0; i < 16; i++) {		temp = currpt[i][0];		currpt[i][0] = cosanga * temp - sinanga * currpt[i][3];		currpt[i][3] = sinanga * temp + cosanga * currpt[i][3];	}	for (i = 0; i < 16; i++) {		temp = currpt[i][1];		currpt[i][1] = cosangb * temp - sinangb * currpt[i][3];		currpt[i][3] = sinangb * temp + cosangb * currpt[i][3];	}	for (i = 0; i < 16; i++) {		temp = currpt[i][2];		currpt[i][2] = cosangc * temp - sinangc * currpt[i][3];		currpt[i][3] = sinangc * temp + cosangc * currpt[i][3];	}	for ( i = 0; i < 16; i++) {		for ( j = 0; j < 3; j++) 			currpt[i][j] = currpt[i][j] * s;	}	//	glMatrixMode(GL_MODELVIEW);//	glLoadIdentity();	glTranslated(0 + pos[0], 0 + pos[1], -30.0 - pos[2]);	glRotated(angle[0], 1, 0, 0);	glRotated(angle[1], 0, 1, 0);	glRotated(angle[2], 0, 0, 1);	for (i = 0; i < 16; i++)		color[i] = (currpt[i][3] / 3.0) + 0.5;	glBegin(GL_LINES);	{		for (i = 0; i < 16; i++) {			for (j = 0; j < 4; j++) {				if (k = connect[i][j]) {					glColor4d(color[i], 0.0, 1.0 - color[i], edge_alpha);					glVertex3d(currpt[i][0], currpt[i][1], currpt[i][2]);					glColor4d(color[k], 0.0, 1.0 - color[k], edge_alpha);					glVertex3d(currpt[k][0], currpt[k][1], currpt[k][2]);				}			}		}	}	glEnd();	glBegin(GL_QUADS);	{		for (i = 0; i < 24; i++) {			for (j = 0; j < 4; j++) {				k = face[i][j];				glColor4d(1 - color[k], 0, color[k], (sin((double) 1.0 /alpha_fade_val) + 1.0) * 0.5 * face_alpha);				glVertex3d(currpt[k][0], currpt[k][1], currpt[k][2]);			}		}	}	glEnd();} void nnato_glregister(NNato *x, void *klientz){    n2glregisterx(x,n2objtype,x->glout,klientz);  // bkom 01 klient ov gl alimentari data}			/*----------------------------------------------------------	EOF----------------------------------------------------------*/