/*- * Permission to use, copy, modify, and distribute this software and its * documentation for any purpose and without fee is hereby granted, * provided that the above copyright notice appear in all copies and that * both that copyright notice and this permission notice appear in * supporting documentation. * * This file is provided AS IS with no warranties of any kind.  The author * shall have no liability with respect to the infringement of copyrights, * trade secrets or any patents by this file or any part thereof.  In no * event will the author be liable for any lost revenue or profits or * other special, indirect and consequential damages. * * Revision History: * 1999: written by Tim Robinson <the_luggage@bigfoot.com> *       a 3-D representation of the Sierpinski gasket fractal. * * 10-Dec-99  jwz   rewrote to draw a set of tetrahedrons instead of a *                  rand scattering of points. * 01-Nov-2000: s.sudre optimized the computation by pre-calculating the normals                        only 4 normals are needed for the whole scene. *//*- * due to a Bug/feature in VMS X11/Intrinsic.h has to be placed before xlock. * otherwise caddr_t is not defined correctly *//*- * yet anothr sier hack20.12.2002 */#include "Movies.h"#include "ext.h"#include "ext_common.h"#include "ext_user.h"#include "n2.basicstrings.c"#include "n2.0000.h"#include "agl.h"#include "GL/glut.h"#include "math.h" //for sqrt#include <stdlib.h>#define MAXGRID 64 //gl max vector stuff#define WIREFRAME false //gl max vector stuff#undef countof#define countof(x) (sizeof((x))/sizeof((*x)))static int max_depth;static int speed;static unsigned long frameCount;typedef struct{  GLfloat x;  GLfloat y;  GLfloat z;} GL_VECTOR;typedef struct {  GLfloat     view_rotx, view_roty, view_rotz;  GLfloat     light_colour[4];/* = {6.0, 6.0, 6.0, 1.0}; */  GLfloat     pos[3];/* = {0.0, 0.0, 0.0}; */  GLfloat     xinc,yinc,zinc;  GLfloat     angle;  GLuint      gasket1;  int current_depth;} gasketstruct;typedef struct vector {  GLfloat x, y, z;} vector;typedef struct plane {  vector p1, p2, p3;} plane;typedef struct zttz {	Object    n_ob; 	void     *n2hdr;    // required nato - position = important _ must b 2nd	    void   	 *glout;	// out gl fun    short     type, grid, step;//removed gridy and gridx->grid for vfun compatibility    GLfloat   vertex,vertex2,red,green,blue,              normalx,normaly,normalz, rate;//    float     posit[MAXGRID][MAXGRID];  //globalize it    GLboolean texture,border, calcFaceNorms, drawFaceNorms, antialias;                  Boolean        on, doubl, ignt;  		float		inputlist[MAXGRID];	float		st;//	short		listlenght, oplenght;	 long      shademodel;	 	 	vector 	faceNormals[4];	gasketstruct *gp;} NNato;//global carve stufffloat	    posit[MAXGRID][MAXGRID];			        //positionfloat	    vertNorms[MAXGRID][MAXGRID][3];				//normalsfloat	    faceNorms[2][MAXGRID][MAXGRID][3];  		//facenormalsfloat	    faceNormSegs[2][2][MAXGRID][MAXGRID][3];	//facenormal segmentsfloat 		texCoords[MAXGRID][MAXGRID][2];				//texture coordinates//vector void copy(float vec0[3], float vec1[3]);void sub(float vec0[3], float vec1[3], float vec2[3]);void add(float vec0[3], float vec1[3], float vec2[3]);void scalDiv(float vec[3], float c);void cross(float vec0[3], float vec1[3], float vec2[3]);void norm(float vec[3]);void set(float vec[3], float x, float y, float z);static void 	vector_set(vector *v, GLfloat x, GLfloat y, GLfloat z);static void		vector_cross(vector v1, vector v2, vector *v3);static void		vector_subtract(vector v1, vector v2, vector *res);static void		plane_normal(plane p, vector *n);static voiddraw_normal(GLfloat x1, GLfloat y1, GLfloat z1,	  GLfloat x2, GLfloat y2, GLfloat z2,	  GLfloat x3, GLfloat y3, GLfloat z3,int inNormalIndex);static voidtriangle (GL_VECTOR * inVector1,GL_VECTOR * inVector2,GL_VECTOR * inVector3,int inNormalIndex);static voidfour_tetras (GL_VECTOR *outer,int countdown);static voidcompile_gasket(gasketstruct *gp);static void compute_faceNormals(NNato *x);static voiddraw(gasketstruct *gp);static voidpinit(gasketstruct *gp);static voiddraw_gasket( gasketstruct *gp);void getFaceNorms(NNato *x);void getVertNorms(NNato *x);void getFaceNormSegs(NNato *x);void getTexCoords(NNato *x);void drawFaceNormals(NNato *x);void nnato_drawFaceNorms(NNato *x, long flag);void nnato_calcFaceNorms(NNato *x, long flag);void nnato_antialias(NNato *x, long flag);void *nnato_new(void);void nnato_assist(NNato *x, void *b, long msg, long nr, char *s);void nnato_info(NNato *x, void *p, void *b);void nnato_free(NNato *x);void nnato_on(NNato *x, long flag);void nnato_bang(NNato *x);void nnato_int(NNato *x, long n);   void nnato_variant(NNato *x, short variant);void nnato_type(NNato *x, short type);void nnato_shademodel(NNato *x, long type);void nnato_klr(NNato *x, long red, long green, long blue);void nnato_normalz(NNato *x, long koordx, long koordy, long koordz);void nnato_texture(NNato *x, long flag);void nnato_revertgeo(NNato *x);void nnato_revert(NNato *x);void nnato_vectinit(NNato *x);void nnato_grid(NNato *x, long grid);void nnato_list(NNato *x, Symbol *s, short argc, Atom *argv);void nnato_float(NNato *x,double flag);				void nnato_st(NNato *x, float st);void nnato_doubl(NNato *x, long flag);void nnato_ignitv(NNato *x, int flaag, float flag);void nnato_shifth(NNato *x, int amount);void nnato_shifthh(NNato *x, int amount);void nnato_rate(NNato *x, float n);void nnato_border(NNato *x, long flag);void nnato_setspeed(NNato *x, float st);void nnato_setradius(NNato *x, float st);void nnato_setdepth(NNato *x, float st);void nnato_glfun(n2glatom glatom);void nnato_glfun2(n2glatom glatom);		//void nnato_glfun3(n2glatom glatom);void nnato_glfun4(n2glatom glatom);void nnato_glregister(NNato *x, void *klientz);void    *nnato_class;main(){	setup(&nnato_class, nnato_new, (method)nnato_free, (short)sizeof(NNato), 0L, 0L, 0); 	addmess((method)nnato_assist,	                  "assist",          	A_CANT,0); 	addmess((method)nnato_info,	                      "info",		        A_CANT,0);    n2objaddglcmd();    n2addstatecmd((method)nnato_int,(method)nnato_bang,                  (method)nnato_on,-1,-1,-1,-1,(method)nnato_variant,0);    addmess((method)nnato_klr,                        "color",              A_DEFLONG,A_DEFLONG,A_DEFLONG,0);    addmess((method)nnato_texture,                    "texture",            A_DEFLONG,0);    addmess((method)nnato_revert,                     "revert",             0);    addmess((method)nnato_grid,"grid",A_DEFLONG,A_DEFLONG,0);	addmess((method)nnato_list,"list",A_GIMME, 0);	addfloat((method)nnato_float);    addmess((method)nnato_st,"stride",A_DEFFLOAT, 0);    addmess((method)nnato_shademodel,"model",A_DEFLONG,0);    addmess((method)nnato_type,"type",A_DEFLONG,0);    addmess((method)nnato_normalz,"normal",A_DEFLONG,A_DEFLONG,A_DEFLONG,0);    addmess((method)nnato_shifth,"shift.left",0);    addmess((method)nnato_shifthh,"shift.right",0);    addmess((method)nnato_shifthh,"rate",A_DEFFLOAT,0);    addmess((method)nnato_border,"border",A_DEFLONG,0);    addmess((method)nnato_drawFaceNorms,"face_norms",A_DEFLONG,0);    addmess((method)nnato_calcFaceNorms,"calc_face_norms",A_DEFLONG,0);    addmess((method)nnato_antialias,"antialias",A_DEFLONG,0);    n2reklama();    n2reklama();    n2reklama();    n2reklama();    post("×		Eastern Bunny",0);    n2addfklass("242.glterrain02");	}void nnato_assist(NNato *x, void *b, long msg, long nr, char *s){	if (msg == 1)      // !nlet	   strcpy( s, m9ndfukcpropaganda00);       {	   if (msg == 2)   // outlet	      if (nr == 0)	         strcpy( s, n2gltypestr);  // default `gl data type` outlet de[a]ss!zt--	   }}void nnato_info(NNato *x, void *p, void *b){      n2info();}void *nnato_new(){    NNato      *x;	short      err, i,j;	x = (NNato *)newobject(nnato_class);    n2addoutlet(x,&x->glout);        if (err = n2objinit(x))       { post("242.glplain :  n2initobjekt err = %ld",err); return;} 	x->ignt=0;    nnato_revert(x);    post("revert bypassed",0);//    nnato_vectinit(x);	    for(i=0;i < x->grid; i++)        for(j=0;j < x->grid; j++){			posit[i][j] = 0.0f; 	}			post ("zeroed vector i count %ld j count %ld", i, j,0);/*    for(i=0; i < MAXGRID; i++)    	x->inputlist[i]=0.0f;    post("inputlist zeroed  and i is %ld",i,0);*/    n2objsetglregister(x,(method)nnato_glregister);   // zpecify gl regizter routine    n2objsetglfun(x,(method)nnato_glfun);             // zpecify gl drau routine    post("registered and set fun",0);			x->on = true;    post("x->on = true",0);        	return (x);   ikk:	nnato_free(x);}void nnato_free(NNato *x){   //	if(posit)		    n2objfree(x);}void nnato_on(NNato *x, long flag){        x->on = flag;}  void nnato_int(NNato *x, long n)    {								       if (!n) x->on = false;   else x->on = true;}void nnato_bang(NNato *x){   n2gldraw(x, n2objtype);}void nnato_variant(NNato *x, short variant){   if (!variant) n2objsetglfun(x,(method)nnato_glfun);   else if (variant==1) n2objsetglfun(x,(method)nnato_glfun2);   else if (variant==2) n2objsetglfun(x,(method)nnato_glfun3);   else if (variant==3) n2objsetglfun(x,(method)nnato_glfun4);}void nnato_st(NNato *x, float st){ 	x->st   = st; }void nnato_type(NNato *x, short type){   if (type >= 0 && type <= 9) x->type = type;}void nnato_klr(NNato *x, long red, long green, long blue){   x->red   = (float)red   * 0.01;   x->green = (float)green * 0.01;   x->blue  = (float)blue  * 0.01;      }  void nnato_normalz(NNato *x, long koordx, long koordy, long koordz){   x->normalx  = (float)koordx * 0.01;   x->normaly  = (float)koordy * 0.01;   x->normalz  = (float)koordz * 0.01;      }  void nnato_shademodel(NNato *x, long type){   if (type == 0) x->shademodel = GLU_SMOOTH;   else if (type == 1) x->shademodel = GLU_FLAT;   else if (type == 2) x->shademodel = GLU_NONE;}void nnato_doubl(NNato *x, long flag){    x->doubl = flag;}void nnato_texture(NNato *x, long flag){    x->texture = flag;}void nnato_border(NNato *x, long flag){        x->border = flag;}  void nnato_revert(NNato *x){		gasketstruct *gp = x->gp;    x->normalx = x->normaly = 0.0;    x->normalz = 1.0;        //    nnato_grid(x,64);    x->grid=64;//    x->grid=128;  //  x->grid=128;	x->ignt=0;    x->step=0;    x->st=0.2;    x->texture = true;    x->rate=0.;        x->border=0;    nnato_klr(x,50,50,50);        x->calcFaceNorms = 0;    x->drawFaceNorms = 0;    x->antialias = 0;      pinit(gp);}void nnato_grid(NNato *x, long grid){/*	if((grid<MAXGRID&&grid>0))//&&	\{//	(grid<MAXGRID&&grid>0)){    x->grid = grid;//    x->grid = grid;    x->step = 0;     nnato_vectinit(x);//lets begin again//    } else {//    x->grid = 64;//   x->grid = 64;        }*/	if((grid<MAXGRID&&grid>0))		x->grid = grid;	getTexCoords(x);}void nnato_vectinit(NNato *x){	short i,j;	    for(i=0;i<x->grid;i++)        for(j=0;j<x->grid;j++)		{			posit[i][j] = 0.0f; 		}}void nnato_rate(NNato *x, float n){        int cand=0, i, j;        x->rate = n ;//* 0.01;          for(i=1; i<x->grid; i++){	   for(j=0; j<x->grid; j++)	{	   	cand = (i+j)%2;	   	if (!cand) posit[i][j] += (posit[i][j]*x->rate);		//even numbrs	   	else if (cand==1)		 posit[i][j] -= (posit[i][j]*x->rate);				//odd numbrs		}  	}  }  void nnato_ignitv(NNato *x, int flaag, float flag){    register short i, j;        posit[0][flaag]=flag;     if (flaag==x->grid-1)	{      for(i=1; i<x->grid; i++){	   for(j=0; j<x->grid; j++)	{		 posit[i][j] = posit[i-1][j];	//_copy	next			//		 posit[i][j] = 0.01f;	//just zero the vector out				  		}		   	   }			x->ignt=true;		post("x->ignt=%ld", x->ignt,0);  	 	}}void nnato_list(NNato *x, Symbol *s, short argc, Atom *argv){	register short 	i, j;	short	indi, grid=x->grid;	float	poslisratio, incremento, a, b, indice, val;		if (argc > 64) return;	for (i=0; i < argc; i++) {		if (argv[i].a_type==A_LONG) {			x->inputlist[i] = (float)argv[i].a_w.w_long * 0.01;//divide por 100 se int		}		else if (argv[i].a_type==A_FLOAT) {			x->inputlist[i] = argv[i].a_w.w_float;		}	 }	if (argc == 64) goto stemall;	poslisratio = (float)grid / argc;		for(j=0; j<grid; j++){			indice = ((float)j/poslisratio);// valor inteiro			indi = (int)(indice);		// valor arredondado			a = x->inputlist[indi];			b = x->inputlist[indi+1];			incremento = (float) ((b-a)/poslisratio)*((indi+1)-indice);			val = (float)x->inputlist[indi] + incremento;//			if(x->ignt==true) {				posit[0][j]=val;	//entra elemento para a posicao 0//					}//			else nnato_ignitv(x, j, val);//			if(x->ignt==0) {//				nnato_ignitv(x, j, val);//				}//			else if (x->ignt==1) {//				posit[0][j]=val;	//entra elemento para a posicao 0//			}		}						// o elemento da posicao 1 passa para a pos 2, ie cpstep+1->c[step+2// depois o elemnto da pos 1 copia zerojustdoit:			for(i=grid-1; i>=0; --i)	for(j=grid; j>=0; --j){//		if(!x->border)		 posit[i+1][j] = posit[i][j];	//_copy	next//		else//		if(x->border)//			if( j==0 ||  i == 0	|| j == grid-1 || i == grid-2)//				posit[i][j]=0.0f;			//		if (i==0||j==0||i==grid-1||j==grid-1) posit[i][j]=0.0;		}		   	return;stemall:	for(j=0; j<grid; j++){	posit[0][j]=x->inputlist[j];	} 	goto justdoit;}void nnato_float(NNato *x,double flag){	register short 	i, j;	short grid=x->grid;	for(j=0; j<grid; j++){				posit[0][j]=(float)flag;	//entra elemento para a posicao 0		}	for(i=grid-1; i>=0; --i)	for(j=grid; j>=0; --j){//		if(!x->border)		 posit[i+1][j] = posit[i][j];	//_copy	next//		else if (x->border) {//			if( j==0 ||  i == 0	|| j == grid-1 || i == grid-2) {//				posit[i+1][j]=0.0f;	//			  	} //			  else posit[i+1][j] = posit[i][j];	//		}	//		if (i==0||j==0||i==grid-1||j==grid-1) posit[i][j]=0.0;	}}void nnato_shifth(NNato *x, int amount){	register short i, j;//	short	a1,b1;	//	if (amount){	for(i=x->grid-1; i>=0; --i)	for(j=x->grid-1; j>=0; --j){//		a1=amount+j;//		b1=a1%j;//		 posit[i][b1] = posit[i+1][j];	//not 					//		 posit[i][j+1] = posit[i+1][j];	//shift 1 left					 posit[i+1][j+1] = posit[i][j];	//shift 1 left				  }	  // }}void nnato_shifthh(NNato *x, int amount){	register short i, j;	short	a1,b1;	//	if (amount){	for(i=x->grid-1; i>=0; --i)	for(j=0; j<x->grid-1; j++){//		a1=amount+j;//		b1=a1%j;//		 posit[i][b1] = posit[i+1][j];	//not 							 posit[i+1][j] = posit[i][j+1];	//shift 1 left				  }	//   }}void nnato_glfun(n2glatom glatom) // draw wireframe{    NNato *x = (NNato *)n2getglatomobj(glatom);	gasketstruct *gp = x->gp;		short	i,j, grid=x->grid;	float   st=x->st; 	int total;       if (!x->on) return;    	draw_gasket(gp);   }     void nnato_glfun2(n2glatom glatom)	//draew textured{    NNato *x = (NNato *)n2getglatomobj(glatom);	short	i,j, grid=x->grid;	float   st=x->st;        if (!x->on) return;        if (x->antialias)    {        glEnable(GL_BLEND);        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);        glEnable(GL_LINE_SMOOTH);        glLineWidth(1.5);    }    else    {        glDisable(GL_BLEND);        glDisable(GL_LINE_SMOOTH);        glLineWidth(1.0);    }    glTranslatef(-grid / 2.0 + .5, -grid / 2.0 + .5, 0); //center it    glColor3f(x->red, x->green, x->blue);	//color it    if (x->calcFaceNorms) {    getFaceNorms(x);    getVertNorms(x);	}//    	{ drawTextured(x); }    glEnable(GL_TEXTURE_2D);    for (i = 0; i < grid - 1; ++i)    {        glBegin(GL_TRIANGLE_STRIP);        for (j = 0; j < grid; ++j)        {            glNormal3fv( vertNorms[i][j] );            glTexCoord2fv( texCoords[i][j] );            glVertex3f( i, j, posit[i][j] );            glNormal3fv( vertNorms[i+1][j] );            glTexCoord2fv( texCoords[i+1][j] );            glVertex3f( i+1, j, posit[i+1][j] );        }        glEnd();    }    glDisable(GL_TEXTURE_2D);    if (x->drawFaceNorms)        {        getFaceNormSegs(x);        drawFaceNormals(x);    }/*    if (x->antialias)    {        glDisable(GL_BLEND);        glDisable(GL_LINE_SMOOTH);        glLineWidth(1.0);    }*/}      void nnato_glfun3(n2glatom glatom) // { drawSmoothShaded(x); }{    NNato *x = (NNato *)n2getglatomobj(glatom);	short	i,j, grid=x->grid;	float   st=x->st;        if (!x->on) return;        if (x->antialias)    {        glEnable(GL_BLEND);        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);        glEnable(GL_LINE_SMOOTH);        glLineWidth(1.5);    }    else    {        glDisable(GL_BLEND);        glDisable(GL_LINE_SMOOTH);        glLineWidth(1.0);    }    glTranslatef(-grid / 2.0 + .5, -grid / 2.0 + .5, 0); //center it//    glColor3f(x->red, x->green, x->blue);	//color it    if (x->calcFaceNorms) {    getFaceNorms(x);    getVertNorms(x);	}//    glEnable(GL_POLYGON_OFFSET_FILL);    glColor3f(x->red, x->green, x->blue);	//color it    for (i = 0; i < x->grid - 1; ++i)    {        glBegin(GL_TRIANGLE_STRIP);        for (j = 0; j < x->grid; ++j)        {            glNormal3fv( vertNorms[i][j] );            glVertex3f( i, j, posit[i][j] );            glNormal3fv( vertNorms[i+1][j] );            glVertex3f( i+1, j, posit[i+1][j] );        }        glEnd();    }    if (x->drawFaceNorms)        {        getFaceNormSegs(x);        drawFaceNormals(x);    }//    glDisable(GL_POLYGON_OFFSET_FILL);/*    if (x->antialias)    {        glDisable(GL_BLEND);        glDisable(GL_LINE_SMOOTH);        glLineWidth(1.0);    }*/ }     void nnato_glfun4(n2glatom glatom) // //    drawFlatShaded(x); }{    NNato *x = (NNato *)n2getglatomobj(glatom);	short	i,j, grid=x->grid;	float   st=x->st, rate=x->rate;        if (!x->on) return;        if (x->antialias)    {        glEnable(GL_BLEND);        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);        glEnable(GL_LINE_SMOOTH);        glLineWidth(1.5);    }    else    {        glDisable(GL_BLEND);        glDisable(GL_LINE_SMOOTH);        glLineWidth(1.0);    }    glTranslatef(-grid / 2.0 + .5, -grid / 2.0 + .5, 0); //center it    glColor3f(x->red, x->green, x->blue);	//color it    if (x->calcFaceNorms) {    getFaceNorms(x);    getVertNorms(x);	}    glEnable(GL_POLYGON_OFFSET_FILL);      for (i = 0; i < x->grid - 1; ++i)    {        glBegin(GL_TRIANGLE_STRIP);        glVertex3f( (float) i, (float) 0, (float) posit[i][0]);        glVertex3f( (float) i+1, (float) 0, (float) posit[i+1][0]);        for (j = 1; j < x->grid; ++j)        {            glNormal3fv( faceNorms[0][i][j-1] );            glVertex3f( (float) i, (float) j, (float) posit[i][j]);              glNormal3fv( faceNorms[1][i][j-1] );            glVertex3f( (float) i+1, (float) j, (float) posit[i+1][j]);        }        glEnd();    }    glDisable(GL_POLYGON_OFFSET_FILL);/*    if (x->antialias)    {        glDisable(GL_BLEND);        glDisable(GL_LINE_SMOOTH);        glLineWidth(1.0);    }*/}void nnato_glregister(NNato *x, void *klientz){    n2glregisterx(x,n2objtype,x->glout,klientz);  // bkom 01 klient ov gl alimentari data}			/* face normals - for flat shading */void getFaceNorms(NNato *x){	int i,j;    float vec0[3], vec1[3], vec2[3], norm0[3], norm1[3];    float geom0[3], geom1[3], geom2[3], geom3[3];    for (i = 0; i < x->grid-1; ++i)    {        for (j = 0; j < x->grid-1; ++j)        {            /* get vectors from geometry points */            geom0[0] = i; geom0[1] = j; geom0[2] = posit[i][j];            geom1[0] = i; geom1[1] = j+1; geom1[2] = posit[i][j+1];            geom2[0] = i+1; geom2[1] = j; geom2[2] = posit[i+1][j];            geom3[0] = i+1; geom3[1] = j+1; geom3[2] = posit[i+1][j+1];            sub( vec0, geom1, geom0 );            sub( vec1, geom1, geom2 );            sub( vec2, geom1, geom3 );            /* get triangle face normals from vectors & normalize them */            cross( norm0, vec0, vec1 );            norm( norm0 );            cross( norm1, vec1, vec2 );             norm( norm1 );            copy( faceNorms[0][i][j], norm0 );            copy( faceNorms[1][i][j], norm1 );        }    }}/* vertex normals - average of face normals for smooth shading */void getVertNorms(NNato *x){	int i,j;    float avg[3];    for (i = 0; i < x->grid; ++i)    {        for (j = 0; j < x->grid; ++j)        {            /* For each vertex, average normals from all faces sharing */            /* vertex.  Check each quadrant in turn */            set(avg, 0.0, 0.0, 0.0);            /* Right & above */            if (j < x->grid-1 && i < x->grid-1)            {                add( avg, avg, faceNorms[0][i][j] );            }            /* Right & below */            if (j < x->grid-1 && i > 0)            {                add( avg, avg, faceNorms[0][i-1][j] );                add( avg, avg, faceNorms[1][i-1][j] );            }            /* Left & above */            if (j > 0 && i < x->grid-1)            {                add( avg, avg, faceNorms[0][i][j-1] );                add( avg, avg, faceNorms[1][i][j-1] );            }            /* Left & below */            if (j > 0 && i > 0)            {                add( avg, avg, faceNorms[1][i-1][j-1] );            }            /* Normalize */            norm( avg );            copy( vertNorms[i][j], avg );        }    }}void getFaceNormSegs(NNato *x){	int i,j;    float center0[3], center1[3], normSeg0[3], normSeg1[3];    float geom0[3], geom1[3], geom2[3], geom3[3];     for (i = 0; i < x->grid - 1; ++i)    {        for (j = 0; j < x->grid - 1; ++j)        {            geom0[0] = i; geom0[1] = j; geom0[2] = posit[i][j];            geom1[0] = i; geom1[1] = j+1; geom1[2] = posit[i][j+1];            geom2[0] = i+1; geom2[1] = j; geom2[2] = posit[i+1][j];            geom3[0] = i+1; geom3[1] = j+1; geom3[2] = posit[i+1][j+1];            /* find center of triangle face by averaging three vertices */            add( center0, geom2, geom0 );            add( center0, center0, geom1 );            scalDiv( center0, 3.0 );            add( center1, geom2, geom1 );            add( center1, center1, geom3 );            scalDiv( center1, 3.0 );            /* translate normal to center of triangle face to get normal segment */            add( normSeg0, center0, faceNorms[0][i][j] );            add( normSeg1, center1, faceNorms[1][i][j] );            copy( faceNormSegs[0][0][i][j], center0 );            copy( faceNormSegs[1][0][i][j], center1 );            copy( faceNormSegs[0][1][i][j], normSeg0 );            copy( faceNormSegs[1][1][i][j], normSeg1 );        }    }}void getTexCoords(NNato *x){	int i,j;    for (i = 0; i < x->grid; ++i)    {        for (j = 0; j < x->grid; ++j)        {            texCoords[i][j][0] = (float)j/(float)(x->grid-1);            texCoords[i][j][1] = (float)i/(float)(x->grid-1);        }    }}void drawFaceNormals(NNato *x){    int i,j;    glColor3f(1.0,1.0,1.0);    for (i = 0; i < x->grid - 1; ++i)    {        for (j = 0; j < x->grid - 1; ++j)        {            glBegin(GL_LINES);            glVertex3fv(faceNormSegs[0][0][i][j]);            glVertex3fv(faceNormSegs[0][1][i][j]);            glEnd();            glBegin(GL_LINES);            glVertex3fv(faceNormSegs[1][0][i][j]);            glVertex3fv(faceNormSegs[1][1][i][j]);            glEnd();        }    }}void nnato_drawFaceNorms(NNato *x, long flag){        x->drawFaceNorms = flag;}  void nnato_calcFaceNorms(NNato *x, long flag){        x->calcFaceNorms = flag;}  void nnato_antialias(NNato *x, long flag){        x->antialias = flag;}  // mathvoid copy(float vec0[3], float vec1[3]){    vec0[0] = vec1[0];    vec0[1] = vec1[1];    vec0[2] = vec1[2];}void sub(float vec0[3], float vec1[3], float vec2[3]){    vec0[0] = vec1[0] - vec2[0];    vec0[1] = vec1[1] - vec2[1];    vec0[2] = vec1[2] - vec2[2];}void add(float vec0[3], float vec1[3], float vec2[3]){    vec0[0] = vec1[0] + vec2[0];    vec0[1] = vec1[1] + vec2[1];    vec0[2] = vec1[2] + vec2[2];}void scalDiv(float vec[3], float c){    vec[0] /= c; vec[1] /= c; vec[2] /= c;}void cross(float vec0[3], float vec1[3], float vec2[3]){    vec0[0] = vec1[1] * vec2[2] - vec1[2] * vec2[1];    vec0[1] = vec1[2] * vec2[0] - vec1[0] * vec2[2];    vec0[2] = vec1[0] * vec2[1] - vec1[1] * vec2[0];}void norm(float vec[3]){    float c = sqrt(vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2]);    scalDiv(vec, c); }void set(float vec[3], float x, float y, float z){    vec[0] = x;    vec[1] = y;    vec[2] = z;}/*----------------------------------------------------------	EOF----------------------------------------------------------*/static voidvector_set(vector *v, GLfloat x, GLfloat y, GLfloat z){  v->x = x;  v->y = y;  v->z = z;}static voidvector_cross(vector v1, vector v2, vector *v3){  v3->x = (v1.y * v2.z) - (v1.z * v2.y);  v3->y = (v1.z * v2.x) - (v1.x * v2.z);  v3->z = (v1.x * v2.y) - (v1.y * v2.x);}static voidvector_subtract(vector v1, vector v2, vector *res){  res->x = v1.x - v2.x;  res->y = v1.y - v2.y;  res->z = v1.z - v2.z;}static voidplane_normal(plane p, vector *n){  vector v1, v2;  vector_subtract(p.p1, p.p2, &v1);  vector_subtract(p.p1, p.p3, &v2);  vector_cross(v2, v1, n);}static voiddraw_normal(GLfloat x1, GLfloat y1, GLfloat z1,	  GLfloat x2, GLfloat y2, GLfloat z2,	  GLfloat x3, GLfloat y3, GLfloat z3,int inNormalIndex){    /* Draw a line in the direction of this face's normal. */    NNato *x ;  {    GLfloat ax = x->faceNormals[inNormalIndex].x > 0 ? x->faceNormals[inNormalIndex].x : -x->faceNormals[inNormalIndex].x;    GLfloat ay = x->faceNormals[inNormalIndex].y > 0 ? x->faceNormals[inNormalIndex].y : -x->faceNormals[inNormalIndex].y;    GLfloat az = x->faceNormals[inNormalIndex].z > 0 ? x->faceNormals[inNormalIndex].z : -x->faceNormals[inNormalIndex].z;    GLfloat mx = (x1 + x2 + x3) / 3;    GLfloat my = (y1 + y2 + y3) / 3;    GLfloat mz = (z1 + z2 + z3) / 3;    GLfloat xx, yy, zz;    GLfloat max = ax > ay ? ax : ay;    if (az > max) max = az;    max *= 2;    xx = x->faceNormals[inNormalIndex].x / max;    yy = x->faceNormals[inNormalIndex].y / max;    zz = x->faceNormals[inNormalIndex].z / max;    glBegin(GL_LINE_LOOP);    glVertex3f(mx, my, mz);    glVertex3f(mx+xx, my+yy, mz+zz);    glEnd();  }}static voidtriangle (GL_VECTOR * inVector1,GL_VECTOR * inVector2,GL_VECTOR * inVector3,int inNormalIndex) {      NNato *x;    if (WIREFRAME==true)	glBegin (GL_LINE_LOOP);    else    {	glNormal3f(x->faceNormals[inNormalIndex].x, x->faceNormals[inNormalIndex].y, x->faceNormals[inNormalIndex].z);	#ifdef DEBUG	draw_normal (inVector1->x, inVector1->y, inVector1->z,                     inVector2->x, inVector2->y, inVector2->z,                     inVector3->x, inVector3->y, inVector3->z,                     inNormalIndex);	#endif	glBegin (GL_TRIANGLES);    }        glVertex3f (inVector1->x, inVector1->y, inVector1->z);    glVertex3f (inVector2->x, inVector2->y, inVector2->z);    glVertex3f (inVector3->x, inVector3->y, inVector3->z);    glEnd();}static voidfour_tetras (GL_VECTOR *outer,int countdown){  if (countdown <= 0)    {      triangle (outer,                outer+1,                outer+2,2);      triangle (outer,                outer+3,                outer+1,1);      triangle (outer,                outer+2,                outer+3,0);	      triangle (outer+1,                outer+3,                outer+2,3);    }  else    {#     define M01 0#     define M02 1#     define M03 2#     define M12 3#     define M13 4#     define M23 5      GL_VECTOR inner[M23+1];      GL_VECTOR corner[4];      inner[M01].x = (outer[0].x + outer[1].x) / 2.0;      inner[M01].y = (outer[0].y + outer[1].y) / 2.0;      inner[M01].z = (outer[0].z + outer[1].z) / 2.0;      inner[M02].x = (outer[0].x + outer[2].x) / 2.0;      inner[M02].y = (outer[0].y + outer[2].y) / 2.0;      inner[M02].z = (outer[0].z + outer[2].z) / 2.0;      inner[M03].x = (outer[0].x + outer[3].x) / 2.0;      inner[M03].y = (outer[0].y + outer[3].y) / 2.0;      inner[M03].z = (outer[0].z + outer[3].z) / 2.0;      inner[M12].x = (outer[1].x + outer[2].x) / 2.0;      inner[M12].y = (outer[1].y + outer[2].y) / 2.0;      inner[M12].z = (outer[1].z + outer[2].z) / 2.0;      inner[M13].x = (outer[1].x + outer[3].x) / 2.0;      inner[M13].y = (outer[1].y + outer[3].y) / 2.0;      inner[M13].z = (outer[1].z + outer[3].z) / 2.0;      inner[M23].x = (outer[2].x + outer[3].x) / 2.0;      inner[M23].y = (outer[2].y + outer[3].y) / 2.0;      inner[M23].z = (outer[2].z + outer[3].z) / 2.0;      countdown--;      corner[0] = outer[0];      corner[1] = inner[M01];      corner[2] = inner[M02];      corner[3] = inner[M03];      four_tetras (corner, countdown);      corner[0] = inner[M01];      corner[1] = outer[1];      corner[2] = inner[M12];      corner[3] = inner[M13];      four_tetras (corner,countdown);      corner[0] = inner[M02];      corner[1] = inner[M12];      corner[2] = outer[2];      corner[3] = inner[M23];      four_tetras (corner,countdown);      corner[0] = inner[M03];      corner[1] = inner[M13];      corner[2] = inner[M23];      corner[3] = outer[3];      four_tetras (corner,countdown);    }}static voidcompile_gasket(gasketstruct *gp){  GL_VECTOR   vertex[5];  /* define verticies */  vertex[0].x =  0.5;   vertex[0].y = -(1.0/3.0)*sqrt((2.0/3.0));  vertex[0].z = -sqrt(3.0)/6.0;  vertex[1].x = -0.5;   vertex[1].y = -(1.0/3.0)*sqrt((2.0/3.0));   vertex[1].z = -sqrt(3.0)/6.0;   vertex[2].x = 0.0;   vertex[2].y = (2.0/3.0)*sqrt((2.0/3.0));  vertex[2].z = -sqrt(3.0)/6.0;   vertex[3].x = 0.0;   vertex[3].y = 0.0;   vertex[3].z = sqrt(3.0)/3.0;   vertex[4].x = 0.0;  vertex[4].y = 0.0;   vertex[4].z = 0.0;    four_tetras (vertex,                (gp->current_depth < 0                ? -gp->current_depth : gp->current_depth));}/* There are only 4 normals for the whole model whatever resolution we draw */static void compute_faceNormals(NNato *x){    GL_VECTOR   vertex[5];    plane plane;    GLfloat norm;    int i;          /* define verticies */  vertex[0].x =  0.5;   vertex[0].y = -(1.0/3.0)*sqrt((2.0/3.0));  vertex[0].z = -sqrt(3.0)/6.0;  vertex[1].x = -0.5;   vertex[1].y = -(1.0/3.0)*sqrt((2.0/3.0));   vertex[1].z = -sqrt(3.0)/6.0;   vertex[2].x = 0.0;   vertex[2].y = (2.0/3.0)*sqrt((2.0/3.0));  vertex[2].z = -sqrt(3.0)/6.0;   vertex[3].x = 0.0;   vertex[3].y = 0.0;   vertex[3].z = sqrt(3.0)/3.0;   vertex[4].x = 0.0;  vertex[4].y = 0.0;   vertex[4].z = 0.0;     vector_set(&plane.p1, vertex[0].x, vertex[0].y, vertex[0].z);  vector_set(&plane.p2, vertex[3].x, vertex[3].y, vertex[3].z);  vector_set(&plane.p3, vertex[2].x, vertex[2].y, vertex[2].z);  plane_normal(plane, &x->faceNormals[0]);    vector_set(&plane.p1, vertex[0].x, vertex[0].y, vertex[0].z);  vector_set(&plane.p2, vertex[1].x, vertex[1].y, vertex[1].z);  vector_set(&plane.p3, vertex[3].x, vertex[3].y, vertex[3].z);  plane_normal(plane, &x->faceNormals[1]);    vector_set(&plane.p1, vertex[0].x, vertex[0].y, vertex[0].z);  vector_set(&plane.p2, vertex[2].x, vertex[2].y, vertex[2].z);  vector_set(&plane.p3, vertex[1].x, vertex[1].y, vertex[1].z);  plane_normal(plane, &x->faceNormals[2]);    vector_set(&plane.p1, vertex[1].x, vertex[1].y, vertex[1].z);  vector_set(&plane.p2, vertex[2].x, vertex[2].y, vertex[2].z);  vector_set(&plane.p3, vertex[3].x, vertex[3].y, vertex[3].z);  plane_normal(plane, &x->faceNormals[3]);    // Normalized the normals, quite normal isn't it ?    for(i=0;i<4;i++)  {	norm=sqrt(x->faceNormals[i].x*x->faceNormals[i].x+x->faceNormals[i].y*x->faceNormals[i].y+x->faceNormals[i].z*x->faceNormals[i].z);	x->faceNormals[i].x/=norm;	x->faceNormals[i].y/=norm;	x->faceNormals[i].z/=norm;  }}static voiddraw(gasketstruct *gp){  static int tick = 0;    static float position0[] = {-0.5,  1.2, 0.5, 0.0};  static float ambient0[]  = {0.4, 0.6, 0.4, 1.0};  static float spec[]      = {0.7, 0.7, 0.7, 1.0};  glLightfv(GL_LIGHT0, GL_POSITION,  position0);  glLightfv(GL_LIGHT0, GL_AMBIENT,   ambient0);  glLightfv(GL_LIGHT0, GL_SPECULAR,  spec);  glLightfv(GL_LIGHT0, GL_DIFFUSE,   gp->light_colour);  glShadeModel(GL_SMOOTH);  glEnable(GL_LIGHTING);  glEnable(GL_LIGHT0);  glEnable(GL_DEPTH_TEST);    glEnable(GL_CULL_FACE);  //glEnable(GL_NORMALIZE);	// We don't need that since the normals are normalized    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  glPushMatrix();  glTranslatef( gp->pos[0], gp->pos[1], 0/*gp->pos[2]*/ );    glPushMatrix();  glRotatef(2*gp->angle, 1.0, 0.0, 0.0);  glRotatef(3*gp->angle, 0.0, 1.0, 0.0);  glRotatef(  gp->angle, 0.0, 0.0, 1.0);  glScalef( 8.0, 8.0, 8.0 );  glCallList(gp->gasket1);    glPopMatrix();  glPopMatrix();  if (tick++ >= speed)    {      tick = 0;      if (gp->current_depth >= max_depth)        gp->current_depth = -max_depth;      gp->current_depth++;      glDeleteLists (gp->gasket1, 1);      glNewList (gp->gasket1, GL_COMPILE);      compile_gasket (gp);      glEndList();      /* do the colour change */      gp->light_colour[0] = 3.0*sin(gp->angle/20.0) + 4.0;      gp->light_colour[1] = 3.0*sin(gp->angle/30.0) + 4.0;      gp->light_colour[2] = 3.0*sin(gp->angle/60.0) + 4.0;    }}static voidpinit(gasketstruct *gp){  gp->xinc = 0.1*(1.0*rand()/RAND_MAX);  gp->yinc = 0.1*(1.0*rand()/RAND_MAX);  gp->zinc = 0.1*(1.0*rand()/RAND_MAX);  gp->light_colour[0] = 6.0;  gp->light_colour[1] = 6.0;  gp->light_colour[2] = 6.0;  gp->light_colour[3] = 1.0;  gp->pos[0] = 0.0;       gp->pos[1] = 0.0;  gp->pos[2] = 0.0;      /* draw the gasket */  gp->gasket1 = glGenLists(1);  gp->current_depth = 0;       /* start out at level 0, not 1 */  glNewList(gp->gasket1, GL_COMPILE);    compile_gasket(gp);  glEndList();}static voiddraw_gasket( gasketstruct *gp){  int           angle_incr = 1;  int           rot_incr = 1;/*MI_COUNT(mi) ? MI_COUNT(mi) : 1;*/  glDrawBuffer(GL_BACK);  if (max_depth > 10)    max_depth = 10;        draw(gp);    #if DEBUG  frameCount++;  #endif  /* rotate */  gp->angle = (int) (gp->angle + angle_incr) % 360;  if ( abs( gp->pos[0] ) > 8.0 ) gp->xinc = -1.0 * gp->xinc;  if ( abs( gp->pos[1] ) > 6.0 ) gp->yinc = -1.0 * gp->yinc;  if ( abs( gp->pos[2] ) >15.0 ) gp->zinc = -1.0 * gp->zinc;  gp->pos[0] += gp->xinc;  gp->pos[1] += gp->yinc;  gp->pos[2] += gp->zinc;      gp->view_rotx = (int) (gp->view_rotx + rot_incr) % 360;  gp->view_roty = (int) (gp->view_roty +(rot_incr/2.0)) % 360;  gp->view_rotz = (int) (gp->view_rotz +(rot_incr/3.0)) % 360;  glFinish();}