/*- * Permission to use, copy, modify, and distribute this software and its * documentation for any purpose and without fee is hereby granted, * provided that the above copyright notice appear in all copies and that * both that copyright notice and this permission notice appear in * supporting documentation. * * This file is provided AS IS with no warranties of any kind.  The author * shall have no liability with respect to the infringement of copyrights, * trade secrets or any patents by this file or any part thereof.  In no * event will the author be liable for any lost revenue or profits or * other special, indirect and consequential damages. * * Revision History: * 1999: written by Tim Robinson <the_luggage@bigfoot.com> *       a 3-D representation of the Sierpinski gasket fractal. * * 10-Dec-99  jwz   rewrote to draw a set of tetrahedrons instead of a *                  rand scattering of points. * 01-Nov-2000: s.sudre optimized the computation by pre-calculating the normals                        only 4 normals are needed for the whole scene. *//*- * due to a Bug/feature in VMS X11/Intrinsic.h has to be placed before xlock. * otherwise caddr_t is not defined correctly *//*- * yet anothr sier hack20.12.2002 */#include "Movies.h"#include "ext.h"#include "ext_common.h"#include "ext_user.h"#include "n2.basicstrings.c"#include "n2.0000.h"#include "agl.h"#include "GL/glut.h"#include "math.h" //for sqrt#include <stdlib.h>#define MAXGRID 64 //gl max vector stuff#define WIREFRAME false //gl max vector stuff#undef countof#define countof(x) (sizeof((x))/sizeof((*x)))static int max_depth;static int speed;static unsigned long frameCount;typedef struct{  GLfloat x;  GLfloat y;  GLfloat z;} GL_VECTOR;typedef struct {  GLfloat     view_rotx, view_roty, view_rotz;  GLfloat     light_colour[4];/* = {6.0, 6.0, 6.0, 1.0}; */  GLfloat     pos[3];/* = {0.0, 0.0, 0.0}; */  GLfloat     xinc,yinc,zinc;  GLfloat     angle;  GLuint      gasket1;  int current_depth;} gasketstruct;typedef struct vector {  GLfloat x, y, z;} vector;typedef struct plane {  vector p1, p2, p3;} plane;typedef struct zttz {	Object    n_ob; 	void     *n2hdr;    // required nato - position = important _ must b 2nd	    void   	 *glout;	// out gl fun	 Boolean        on;	 	vector 	faceNormals[4];	gasketstruct *gp;} NNato;static void 	vector_set(vector *v, GLfloat x, GLfloat y, GLfloat z);static void		vector_cross(vector v1, vector v2, vector *v3);static void		vector_subtract(vector v1, vector v2, vector *res);static void		plane_normal(plane p, vector *n);static voiddraw_normal(GLfloat x1, GLfloat y1, GLfloat z1,	  GLfloat x2, GLfloat y2, GLfloat z2,	  GLfloat x3, GLfloat y3, GLfloat z3,int inNormalIndex);static voidtriangle (GL_VECTOR * inVector1,GL_VECTOR * inVector2,GL_VECTOR * inVector3,int inNormalIndex);static voidfour_tetras (GL_VECTOR *outer,int countdown);static voidcompile_gasket(gasketstruct *gp);static void compute_faceNormals(NNato *x);static voiddraw(gasketstruct *gp);static voidpinit(gasketstruct *gp);static voiddraw_gasket( gasketstruct *gp);void *nnato_new(void);void nnato_assist(NNato *x, void *b, long msg, long nr, char *s);void nnato_info(NNato *x, void *p, void *b);void nnato_free(NNato *x);void nnato_on(NNato *x, long flag);void nnato_bang(NNato *x);void nnato_int(NNato *x, long n);   void nnato_variant(NNato *x, short variant);void nnato_texture(NNato *x, long flag);void nnato_revert(NNato *x);void nnato_glfun(n2glatom glatom);void nnato_glregister(NNato *x, void *klientz);void    *nnato_class;main(){	setup(&nnato_class, nnato_new, (method)nnato_free, (short)sizeof(NNato), 0L, 0L, 0); 	addmess((method)nnato_assist,	                  "assist",          	A_CANT,0); 	addmess((method)nnato_info,	                      "info",		        A_CANT,0);    n2objaddglcmd();    n2addstatecmd((method)nnato_int,(method)nnato_bang,                  (method)nnato_on,-1,-1,-1,-1,(method)nnato_variant,0);    n2reklama();    n2reklama();    n2reklama();    n2reklama();//    post("×		Eastern Bunny",0);    n2addfklass("242.glterrain02");	}void nnato_assist(NNato *x, void *b, long msg, long nr, char *s){	if (msg == 1)      // !nlet	   strcpy( s, m9ndfukcpropaganda00);       {	   if (msg == 2)   // outlet	      if (nr == 0)	         strcpy( s, n2gltypestr);  // default `gl data type` outlet de[a]ss!zt--	   }}void nnato_info(NNato *x, void *p, void *b){      n2info();}void *nnato_new(){    NNato      *x;	short      err, i,j;	x = (NNato *)newobject(nnato_class);    n2addoutlet(x,&x->glout);        if (err = n2objinit(x))       { post("= %ld",err); return;}     nnato_revert(x);    n2objsetglregister(x,(method)nnato_glregister);   // zpecify gl regizter routine    n2objsetglfun(x,(method)nnato_glfun);             // zpecify gl drau routine    post("registered and set fun",0);			x->on = true;    post("x->on = true",0);        	return (x);   ikk:	nnato_free(x);}void nnato_free(NNato *x){   //	if(posit)		    n2objfree(x);}void nnato_on(NNato *x, long flag){        x->on = flag;}  void nnato_int(NNato *x, long n)    {								       if (!n) x->on = false;   else x->on = true;}void nnato_bang(NNato *x){   n2gldraw(x, n2objtype);}void nnato_variant(NNato *x, short variant){   if (!variant) n2objsetglfun(x,(method)nnato_glfun);}void nnato_revert(NNato *x){		gasketstruct *gp = x->gp;      pinit(gp);}void nnato_glfun(n2glatom glatom) // draw wireframe{    NNato *x = (NNato *)n2getglatomobj(glatom);	gasketstruct *gp = x->gp;	       if (!x->on) return;    	draw_gasket(gp);   }     void nnato_glregister(NNato *x, void *klientz){    n2glregisterx(x,n2objtype,x->glout,klientz);  // bkom 01 klient ov gl alimentari data}			static voidvector_set(vector *v, GLfloat x, GLfloat y, GLfloat z){  v->x = x;  v->y = y;  v->z = z;}static voidvector_cross(vector v1, vector v2, vector *v3){  v3->x = (v1.y * v2.z) - (v1.z * v2.y);  v3->y = (v1.z * v2.x) - (v1.x * v2.z);  v3->z = (v1.x * v2.y) - (v1.y * v2.x);}static voidvector_subtract(vector v1, vector v2, vector *res){  res->x = v1.x - v2.x;  res->y = v1.y - v2.y;  res->z = v1.z - v2.z;}static voidplane_normal(plane p, vector *n){  vector v1, v2;  vector_subtract(p.p1, p.p2, &v1);  vector_subtract(p.p1, p.p3, &v2);  vector_cross(v2, v1, n);}static voiddraw_normal(GLfloat x1, GLfloat y1, GLfloat z1,	  GLfloat x2, GLfloat y2, GLfloat z2,	  GLfloat x3, GLfloat y3, GLfloat z3,int inNormalIndex){    /* Draw a line in the direction of this face's normal. */    NNato *x ;  {    GLfloat ax = x->faceNormals[inNormalIndex].x > 0 ? x->faceNormals[inNormalIndex].x : -x->faceNormals[inNormalIndex].x;    GLfloat ay = x->faceNormals[inNormalIndex].y > 0 ? x->faceNormals[inNormalIndex].y : -x->faceNormals[inNormalIndex].y;    GLfloat az = x->faceNormals[inNormalIndex].z > 0 ? x->faceNormals[inNormalIndex].z : -x->faceNormals[inNormalIndex].z;    GLfloat mx = (x1 + x2 + x3) / 3;    GLfloat my = (y1 + y2 + y3) / 3;    GLfloat mz = (z1 + z2 + z3) / 3;    GLfloat xx, yy, zz;    GLfloat max = ax > ay ? ax : ay;    if (az > max) max = az;    max *= 2;    xx = x->faceNormals[inNormalIndex].x / max;    yy = x->faceNormals[inNormalIndex].y / max;    zz = x->faceNormals[inNormalIndex].z / max;    glBegin(GL_LINE_LOOP);    glVertex3f(mx, my, mz);    glVertex3f(mx+xx, my+yy, mz+zz);    glEnd();  }}static voidtriangle (GL_VECTOR * inVector1,GL_VECTOR * inVector2,GL_VECTOR * inVector3,int inNormalIndex) {      NNato *x;    if (WIREFRAME==true)	glBegin (GL_LINE_LOOP);    else    {	glNormal3f(x->faceNormals[inNormalIndex].x, x->faceNormals[inNormalIndex].y, x->faceNormals[inNormalIndex].z);	#ifdef DEBUG	draw_normal (inVector1->x, inVector1->y, inVector1->z,                     inVector2->x, inVector2->y, inVector2->z,                     inVector3->x, inVector3->y, inVector3->z,                     inNormalIndex);	#endif	glBegin (GL_TRIANGLES);    }        glVertex3f (inVector1->x, inVector1->y, inVector1->z);    glVertex3f (inVector2->x, inVector2->y, inVector2->z);    glVertex3f (inVector3->x, inVector3->y, inVector3->z);    glEnd();}static voidfour_tetras (GL_VECTOR *outer,int countdown){  if (countdown <= 0)    {      triangle (outer,                outer+1,                outer+2,2);      triangle (outer,                outer+3,                outer+1,1);      triangle (outer,                outer+2,                outer+3,0);	      triangle (outer+1,                outer+3,                outer+2,3);    }  else    {#     define M01 0#     define M02 1#     define M03 2#     define M12 3#     define M13 4#     define M23 5      GL_VECTOR inner[M23+1];      GL_VECTOR corner[4];      inner[M01].x = (outer[0].x + outer[1].x) / 2.0;      inner[M01].y = (outer[0].y + outer[1].y) / 2.0;      inner[M01].z = (outer[0].z + outer[1].z) / 2.0;      inner[M02].x = (outer[0].x + outer[2].x) / 2.0;      inner[M02].y = (outer[0].y + outer[2].y) / 2.0;      inner[M02].z = (outer[0].z + outer[2].z) / 2.0;      inner[M03].x = (outer[0].x + outer[3].x) / 2.0;      inner[M03].y = (outer[0].y + outer[3].y) / 2.0;      inner[M03].z = (outer[0].z + outer[3].z) / 2.0;      inner[M12].x = (outer[1].x + outer[2].x) / 2.0;      inner[M12].y = (outer[1].y + outer[2].y) / 2.0;      inner[M12].z = (outer[1].z + outer[2].z) / 2.0;      inner[M13].x = (outer[1].x + outer[3].x) / 2.0;      inner[M13].y = (outer[1].y + outer[3].y) / 2.0;      inner[M13].z = (outer[1].z + outer[3].z) / 2.0;      inner[M23].x = (outer[2].x + outer[3].x) / 2.0;      inner[M23].y = (outer[2].y + outer[3].y) / 2.0;      inner[M23].z = (outer[2].z + outer[3].z) / 2.0;      countdown--;      corner[0] = outer[0];      corner[1] = inner[M01];      corner[2] = inner[M02];      corner[3] = inner[M03];      four_tetras (corner, countdown);      corner[0] = inner[M01];      corner[1] = outer[1];      corner[2] = inner[M12];      corner[3] = inner[M13];      four_tetras (corner,countdown);      corner[0] = inner[M02];      corner[1] = inner[M12];      corner[2] = outer[2];      corner[3] = inner[M23];      four_tetras (corner,countdown);      corner[0] = inner[M03];      corner[1] = inner[M13];      corner[2] = inner[M23];      corner[3] = outer[3];      four_tetras (corner,countdown);    }}static voidcompile_gasket(gasketstruct *gp){  GL_VECTOR   vertex[5];  /* define verticies */  vertex[0].x =  0.5;   vertex[0].y = -(1.0/3.0)*sqrt((2.0/3.0));  vertex[0].z = -sqrt(3.0)/6.0;  vertex[1].x = -0.5;   vertex[1].y = -(1.0/3.0)*sqrt((2.0/3.0));   vertex[1].z = -sqrt(3.0)/6.0;   vertex[2].x = 0.0;   vertex[2].y = (2.0/3.0)*sqrt((2.0/3.0));  vertex[2].z = -sqrt(3.0)/6.0;   vertex[3].x = 0.0;   vertex[3].y = 0.0;   vertex[3].z = sqrt(3.0)/3.0;   vertex[4].x = 0.0;  vertex[4].y = 0.0;   vertex[4].z = 0.0;    four_tetras (vertex,                (gp->current_depth < 0                ? -gp->current_depth : gp->current_depth));}/* There are only 4 normals for the whole model whatever resolution we draw */static void compute_faceNormals(NNato *x){    GL_VECTOR   vertex[5];    plane plane;    GLfloat norm;    int i;          /* define verticies */  vertex[0].x =  0.5;   vertex[0].y = -(1.0/3.0)*sqrt((2.0/3.0));  vertex[0].z = -sqrt(3.0)/6.0;  vertex[1].x = -0.5;   vertex[1].y = -(1.0/3.0)*sqrt((2.0/3.0));   vertex[1].z = -sqrt(3.0)/6.0;   vertex[2].x = 0.0;   vertex[2].y = (2.0/3.0)*sqrt((2.0/3.0));  vertex[2].z = -sqrt(3.0)/6.0;   vertex[3].x = 0.0;   vertex[3].y = 0.0;   vertex[3].z = sqrt(3.0)/3.0;   vertex[4].x = 0.0;  vertex[4].y = 0.0;   vertex[4].z = 0.0;     vector_set(&plane.p1, vertex[0].x, vertex[0].y, vertex[0].z);  vector_set(&plane.p2, vertex[3].x, vertex[3].y, vertex[3].z);  vector_set(&plane.p3, vertex[2].x, vertex[2].y, vertex[2].z);  plane_normal(plane, &x->faceNormals[0]);    vector_set(&plane.p1, vertex[0].x, vertex[0].y, vertex[0].z);  vector_set(&plane.p2, vertex[1].x, vertex[1].y, vertex[1].z);  vector_set(&plane.p3, vertex[3].x, vertex[3].y, vertex[3].z);  plane_normal(plane, &x->faceNormals[1]);    vector_set(&plane.p1, vertex[0].x, vertex[0].y, vertex[0].z);  vector_set(&plane.p2, vertex[2].x, vertex[2].y, vertex[2].z);  vector_set(&plane.p3, vertex[1].x, vertex[1].y, vertex[1].z);  plane_normal(plane, &x->faceNormals[2]);    vector_set(&plane.p1, vertex[1].x, vertex[1].y, vertex[1].z);  vector_set(&plane.p2, vertex[2].x, vertex[2].y, vertex[2].z);  vector_set(&plane.p3, vertex[3].x, vertex[3].y, vertex[3].z);  plane_normal(plane, &x->faceNormals[3]);    // Normalized the normals, quite normal isn't it ?    for(i=0;i<4;i++)  {	norm=sqrt(x->faceNormals[i].x*x->faceNormals[i].x+x->faceNormals[i].y*x->faceNormals[i].y+x->faceNormals[i].z*x->faceNormals[i].z);	x->faceNormals[i].x/=norm;	x->faceNormals[i].y/=norm;	x->faceNormals[i].z/=norm;  }}static voiddraw(gasketstruct *gp){  static int tick = 0;    static float position0[] = {-0.5,  1.2, 0.5, 0.0};  static float ambient0[]  = {0.4, 0.6, 0.4, 1.0};  static float spec[]      = {0.7, 0.7, 0.7, 1.0};  glLightfv(GL_LIGHT0, GL_POSITION,  position0);  glLightfv(GL_LIGHT0, GL_AMBIENT,   ambient0);  glLightfv(GL_LIGHT0, GL_SPECULAR,  spec);  glLightfv(GL_LIGHT0, GL_DIFFUSE,   gp->light_colour);  glShadeModel(GL_SMOOTH);  glEnable(GL_LIGHTING);  glEnable(GL_LIGHT0);  glEnable(GL_DEPTH_TEST);    glEnable(GL_CULL_FACE);  //glEnable(GL_NORMALIZE);	// We don't need that since the normals are normalized    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  glPushMatrix();  glTranslatef( gp->pos[0], gp->pos[1], 0/*gp->pos[2]*/ );    glPushMatrix();  glRotatef(2*gp->angle, 1.0, 0.0, 0.0);  glRotatef(3*gp->angle, 0.0, 1.0, 0.0);  glRotatef(  gp->angle, 0.0, 0.0, 1.0);  glScalef( 8.0, 8.0, 8.0 );  glCallList(gp->gasket1);    glPopMatrix();  glPopMatrix();  if (tick++ >= speed)    {      tick = 0;      if (gp->current_depth >= max_depth)        gp->current_depth = -max_depth;      gp->current_depth++;      glDeleteLists (gp->gasket1, 1);      glNewList (gp->gasket1, GL_COMPILE);      compile_gasket (gp);      glEndList();      /* do the colour change */      gp->light_colour[0] = 3.0*sin(gp->angle/20.0) + 4.0;      gp->light_colour[1] = 3.0*sin(gp->angle/30.0) + 4.0;      gp->light_colour[2] = 3.0*sin(gp->angle/60.0) + 4.0;    }}static voidpinit(gasketstruct *gp){  gp->xinc = 0.1*(1.0*rand()/RAND_MAX);  gp->yinc = 0.1*(1.0*rand()/RAND_MAX);  gp->zinc = 0.1*(1.0*rand()/RAND_MAX);  gp->light_colour[0] = 6.0;  gp->light_colour[1] = 6.0;  gp->light_colour[2] = 6.0;  gp->light_colour[3] = 1.0;  gp->pos[0] = 0.0;       gp->pos[1] = 0.0;  gp->pos[2] = 0.0;      /* draw the gasket */  gp->gasket1 = glGenLists(1);  gp->current_depth = 0;       /* start out at level 0, not 1 */  glNewList(gp->gasket1, GL_COMPILE);    compile_gasket(gp);  glEndList();}static voiddraw_gasket( gasketstruct *gp){  int           angle_incr = 1;  int           rot_incr = 1;/*MI_COUNT(mi) ? MI_COUNT(mi) : 1;*/  glDrawBuffer(GL_BACK);  if (max_depth > 10)    max_depth = 10;        draw(gp);    #if DEBUG  frameCount++;  #endif  /* rotate */  gp->angle = (int) (gp->angle + angle_incr) % 360;  if ( abs( gp->pos[0] ) > 8.0 ) gp->xinc = -1.0 * gp->xinc;  if ( abs( gp->pos[1] ) > 6.0 ) gp->yinc = -1.0 * gp->yinc;  if ( abs( gp->pos[2] ) >15.0 ) gp->zinc = -1.0 * gp->zinc;  gp->pos[0] += gp->xinc;  gp->pos[1] += gp->yinc;  gp->pos[2] += gp->zinc;      gp->view_rotx = (int) (gp->view_rotx + rot_incr) % 360;  gp->view_roty = (int) (gp->view_roty +(rot_incr/2.0)) % 360;  gp->view_rotz = (int) (gp->view_rotz +(rot_incr/3.0)) % 360;  glFinish();}