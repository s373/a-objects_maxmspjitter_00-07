  /*******  *ÑÑÑÑÑÑ	  *******	*ÑÑÑÑÑÑÑ  *		   /	  /  *     *   /-_* -*		  /		 /  *--**     /*******- /______*  *      *  /_______*242.glgauss3d_ __ 7.12.2001a++					 .					adapted from (c) Mark J. Kilgard, 1994.+computer science journal+kant+hume+wittgenstein+melanie+ `üş‚×õ÷åøùÀ®òñğïîıìëêÎã«äÿç¬ö¯¸ÓÕÈ®òÑâá¡àßŞİÜÛÚ± ¨«ÏŒ¶½Ãº÷µ²ÉÂûÆú©Ä§¶ŒÏ·¨« ´¬ö¿¹Ò­Ğ¼»¥¦¤°¢£ªÁ¤Ï·****************/#include "Movies.h"#include "ext_common.h"#include "ext.h"#include "ext_user.h"#include "n2.basicstrings.c"#include "n2.0000.h"#include "agl.h"#include "GL/glut.h" //glu glu++#include <stdlib.h> // for rand() RANDMAX... no we dont#include <math.h> // sin pleasetypedef struct zttz {	Object    n_ob; 	void     *n2hdr;    	    void   	 *glout;        short     type;    long      shademodel, variant, step, result;	//each scene has...    GLfloat   vertex,vertex2,red,green,blue,              normalx,normaly,normalz,               anglx, angly, anglz,              dev, offset,					// rand deviation & offset              nr, nr1, nr2,					// 3 rands ? 3 : 4              rate;  						//    GLint	  r, c, mod;							// row&columns of quad-vertex field    GLboolean texture;              	//and we calc gauss like this...	GLfloat        	centre, stdDev, floor, peak, power, plus,			     	centrey	;		// perhaps we dont need mod. perhaps will only jump geom.	GLfloat			r1, r2  , angle, gmin, gmax	;    Boolean        on;  } NNato;void *nnato_new(void);void nnato_assist(NNato *x, void *b, long msg, long nr, char *s);void nnato_info(NNato *x, void *p, void *b);void nnato_free(NNato *x);void nnato_on(NNato *x, long flag);void nnato_bang(NNato *x);void nnato_int(NNato *x, long n);   void nnato_variant(NNato *x, short variant);void nnato_type(NNato *x, short type);void nnato_vertex(NNato *x, long vertex, long vertex2);void nnato_shademodel(NNato *x, long type);void nnato_klr(NNato *x, long red, long green, long blue);void nnato_normalz(NNato *x, long koordx, long koordy, long koordz);void nnato_texture(NNato *x, long flag);void nnato_revertgeo(NNato *x);void nnato_revert(NNato *x);//scenevoid nnato_angl(NNato *x, float val, float val1, float val2);void nnato_O(NNato *x, float val, float val1);void nnato_row(NNato *x, long n);   void nnato_column(NNato *x, long n);   void nnato_stgo(NNato *x, long n, long n1);void nnato_rate(NNato *x, float n);void nnato_bing(NNato *x);	double ran(void);						//	my rand...double alea(double min, double max);	//	the only i ever got working...//gauss methods, float!void nnato_centre(NNato *x,   float centre);void nnato_centrey(NNato *x, float centrey);void nnato_coords(NNato *x, float centre, float centrey);	//  your center!ªvoid nnato_stdDev(NNato *x,float stdDev);					void nnato_floor(NNato *x,  float floor);void nnato_peak(NNato *x, float peak);void nnato_power(NNato *x, long power);						//  get a hold of yourself++void nnato_plus(NNato *x, float plus);void nnato_mod(NNato *x, long plus);						//  erase itvoid nnato_angle(NNato *x, float angle);					//  but not this onevoid nnato_rot(NNato *x, float r1, float r2);void nnato_rezt (NNato *x);									//	reset/init gaussfloat nnato_constrain(NNato *x, float angle)	;				//	constrain goutvoid nnato_getconstrain(NNato *x, float min, float max) ;//funvoid nnato_glfun(n2glatom glatom);		// only alphavoid nnato_glfun2(n2glatom glatom);		//void nnato_glfun3(n2glatom glatom);void nnato_glfun4(n2glatom glatom);void nnato_glfun5(n2glatom glatom);void nnato_glfun6(n2glatom glatom);void nnato_glfun7(n2glatom glatom);void nnato_glfun8(n2glatom glatom);void nnato_glfun9(n2glatom glatom);void nnato_glregister(NNato *x, void *klientz);void    *nnato_class;main(){	setup(&nnato_class, nnato_new, (method)nnato_free, (short)sizeof(NNato), 0L, 0L, 0); 	addmess((method)nnato_assist,	                  "assist",          	A_CANT,0); 	addmess((method)nnato_info,	                      "info",		        A_CANT,0);    n2objaddglcmd();    n2addstatecmd((method)nnato_int,(method)nnato_bang,                  (method)nnato_on,-1,-1,-1,-1,(method)nnato_variant,0);    addmess((method)nnato_type,                       "drau.type",          A_DEFLONG,0);    addmess((method)nnato_shademodel,                 "normal.type",        A_DEFLONG,0);    addmess((method)nnato_normalz,                    "normal",             A_DEFLONG,A_DEFLONG,A_DEFLONG,0);    addmess((method)nnato_klr,                        "color",              A_DEFLONG,A_DEFLONG,A_DEFLONG,0);    addmess((method)nnato_texture,                    "texture",            A_DEFLONG,0);    addmess((method)nnato_vertex,                     "geo",                A_DEFLONG,A_DEFLONG,0);    addmess((method)nnato_revertgeo,                  "revert.geo",         0);    addmess((method)nnato_revert,                     "revert",             0);    addmess((method)nnato_angl,                        "alpha",              A_DEFFLOAT, A_DEFFLOAT, A_DEFFLOAT,0);    addmess((method)nnato_row,                    "r",            A_DEFLONG,0);    addmess((method)nnato_column,                    "c",            A_DEFLONG,0);    addmess((method)nnato_row,                    "row",            A_DEFLONG,0);    addmess((method)nnato_column,                    "col",            A_DEFLONG,0);    addmess((method)nnato_O,                        "do",              A_DEFFLOAT, A_DEFFLOAT,0);    addmess((method)nnato_stgo,                     "step",            A_DEFLONG,A_DEFLONG,0);    addmess((method)nnato_stgo,                     "%",               A_DEFLONG,A_DEFLONG,0);    addmess((method)nnato_bing,                    "bing",             0);    addmess((method)nnato_rate,                    "rate",            A_DEFFLOAT,0);    addmess((method)nnato_centre,                     "x",           A_DEFFLOAT,0);    addmess((method)nnato_centrey,                   "y",           A_DEFFLOAT,0);    addmess((method)nnato_coords,                      "coords",  A_DEFFLOAT,A_DEFFLOAT, 0);    addmess((method)nnato_stdDev,             	  "dev",	    A_DEFLONG,0);    addmess((method)nnato_floor,                        "floor",       A_DEFLONG,0);    addmess((method)nnato_peak,                         "peak",     A_DEFLONG,0);    addmess((method)nnato_power,                       "pow",        A_DEFLONG,0);    addmess((method)nnato_plus,                           "+",           A_DEFLONG,0);    addmess((method)nnato_angle,                          "angle",           A_DEFFLOAT,0);    addmess((method)nnato_rot,                            "magnitude",      A_DEFFLOAT,A_DEFFLOAT, 0);    addmess((method)nnato_rot,                            "mag",  	      A_DEFFLOAT,A_DEFFLOAT, 0);    addmess((method)nnato_mod,                           "%",         A_DEFLONG,0);    addmess((method)nnato_getconstrain,                    "between",    A_DEFFLOAT, A_DEFFLOAT,0);    post ("242.glgauss3d ÑÑÑ sier,2001", 0);    n2addfklass("242.glgauss3d");	}void nnato_assist(NNato *x, void *b, long msg, long nr, char *s){	if (msg == 1)      // !nlet	   strcpy( s, "ˆ mem—ria de Almada Negreiros - K4\, QUADRADO AZUL\,-- 47 x 56 cm");       {	   if (msg == 2)   // outlet	      if (nr == 0)	         strcpy( s, n2gltypestr);  // default `gl data type` outlet de[a]ss!zt--	   }}void nnato_info(NNato *x, void *p, void *b){ }void *nnato_new(){    NNato      *x;	short      err;	x = (NNato *)newobject(nnato_class);    n2addoutlet(x,&x->glout);        if (err = n2objinit(x))       { post("242.glgauss3d :  n2initobjekt err = %ld",err); return;}     n2objsetglregister(x,(method)nnato_glregister);   // zpecify gl regizter routine    n2objsetglfun(x,(method)nnato_glfun);             // zpecify gl drau routine    nnato_revert(x);				// must hold all other init's	nnato_rezt(x);			x->on = true;	return (x);   ikk:	nnato_free(x);}void nnato_free(NNato *x){       n2objfree(x);}void nnato_on(NNato *x, long flag){        x->on = flag;}  void nnato_int(NNato *x, long n)    {								       if (!n) x->on = false;   else x->on = true;}void nnato_bang(NNato *x){   n2gldraw(x, n2objtype);}void nnato_variant(NNato *x, short variant){   if (!variant) n2objsetglfun(x,(method)nnato_glfun);   else if (variant==1) n2objsetglfun(x,(method)nnato_glfun2);   else if (variant==2) n2objsetglfun(x,(method)nnato_glfun3);   else if (variant==3) n2objsetglfun(x,(method)nnato_glfun4);   else if (variant==4) n2objsetglfun(x,(method)nnato_glfun5);   else if (variant==5) n2objsetglfun(x,(method)nnato_glfun6);   else if (variant==6) n2objsetglfun(x,(method)nnato_glfun7);   else if (variant==7) n2objsetglfun(x,(method)nnato_glfun8);   else if (variant==8) n2objsetglfun(x,(method)nnato_glfun9);}void nnato_type(NNato *x, short type){   if (type >= 0 && type <= 9) x->type = type;}void nnato_klr(NNato *x, long red, long green, long blue){   x->red   = (float)red   * 0.01;   x->green = (float)green * 0.01;   x->blue  = (float)blue  * 0.01;      }  void nnato_normalz(NNato *x, long koordx, long koordy, long koordz){   x->normalx  = (float)koordx * 0.01;   x->normaly  = (float)koordy * 0.01;   x->normalz  = (float)koordz * 0.01;      }  void nnato_shademodel(NNato *x, long type){   if (type == 0) x->shademodel = GLU_SMOOTH;   else if (type == 1) x->shademodel = GLU_FLAT;   else if (type == 2) x->shademodel = GLU_NONE;}void nnato_vertex(NNato *x, long vertex, long vertex2){    x->vertex   = (float)vertex  * .01;    x->vertex2  = (float)vertex2 * .01;}			void nnato_texture(NNato *x, long flag){    x->texture = flag;}void nnato_revertgeo(NNato *x){	    x->vertex = x->vertex2 = .5;   }		void nnato_revert(NNato *x){		x->type = 6;	    x->vertex = x->vertex2 = .5;    x->shademodel = GLU_SMOOTH;     x->normalx = x->normaly = 0.0;    x->normalz = 1.0;        x->texture = true;    x->r = x->c = 32;		// 32x32 scene default    x->anglx =     x->angly =     x->anglz = 0.;    x->step =    x->result = 0 ;    x->dev = 2.;    x->offset = -1.;    x->nr = x->nr1 = x->nr2 = 0.;        nnato_klr(x,50,50,50);}void nnato_angl(NNato *x, float val, float val1, float val2){    x->anglx = val;    x->angly = val1;    x->anglz = val2;}void nnato_O(NNato *x, float val, float val1){    x->dev = val;    x->offset = val1;    nnato_bing(x);}void nnato_row(NNato *x, long n){        x->r = n;}  void nnato_column(NNato *x, long n){        x->r = n;}  void nnato_rate(NNato *x, float n){        x->rate = n;}  void nnato_stgo(NNato *x, long n, long n1){        x->step = n;    x->result = n1;}  void nnato_bing(NNato *x)	//method to change values{								// change this really soon    x->nr = ran() * x->dev + x->offset;    x->nr1 = ran() * x->dev + x->offset;    x->nr2 = ran() * x->dev + x->offset;        }void nnato_centre(NNato *x, float centre)					{ x->centre = centre; }void nnato_centrey(NNato *x, float centrey)					{ x->centrey = centrey; }void nnato_coords(NNato *x, float centre, float centrey) 	{ x->centre = centre; x->centrey = centrey; }void nnato_stdDev(NNato *x, float stdDev) 					{ x->stdDev = stdDev; }void nnato_floor(NNato *x, float floor)						{ x->floor = floor; }void nnato_peak(NNato *x, float peak)						{ x->peak = peak; }void nnato_power(NNato *x, long power)						{ x->power = power; }void nnato_plus(NNato *x, float plus)						{ x->plus = plus; }void nnato_mod(NNato *x, long plus)							{ x->mod = plus; }void nnato_rot(NNato *x, float r1, float r2)				{ x->r1 = r1; x->r2 = r2; }void nnato_angle(NNato *x, float angle)						{ x->r1 = sin (angle); x->r2 = cos (angle); }void nnato_getconstrain(NNato *x, float min, float max)		{ x->gmin = min; x->gmax = max; }float nnato_constrain(NNato *x, float angle)					{ 	float temp;	//	((angle < x->gmin) ? temp = x->gmin : temp = angle;	//	(angle > x->gmax) ? temp = x->gmax : temp = angle;//	return temp;		((angle < x->gmin) ? (temp = x->gmin) : ((angle > x->gmax) ? (temp = x->gmax) : (temp = angle)) ) ;	return temp;	}void nnato_rezt (NNato *x){	x->centre = x->centrey = 3.;    x->peak = -3.;	x->stdDev = 2.;	x->floor = 5.;	x->power=2;	x->plus=0.;	x->mod = 0;	x->r1 = x->r2 = 0.010 ;	x->gmin = -2.000 ;	x->gmax = 2.000  ;}void nnato_glfun(n2glatom glatom){    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS;  //gauss variables  	float		    aa, bb, 				// what a mess... 					centre = x->centre,					centrey = x->centrey,					stdDev = x->stdDev,					peak = x->peak,					floor = x->floor,					powr = x->power,					plus = x->plus ;	float			r1 = x->r1,  r2 = x->r2, gout ;	//geeeeee	int	test;	    if (!x->on) return;       	aa = 2 * pow(stdDev, powr);		    	    		bb = (peak - floor);			        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);	// center fill screen    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {		//there*        glPushMatrix();        glTranslatef(i, j, 0);                glRotatef(anglx, 1, 0, 0);        glRotatef(angly, 0, 1, 0);        glRotatef(anglz, 0, 0, 1);        		//get gauss here and not there* 		if ( !x->mod)		gout = ( bb * exp( -1 * ( pow( (r2*j - centre), powr) + pow( (r1*i - centrey), powr) ) /aa) + floor + plus ); // 2d aa!		else {		test = j % x->mod ;			if ( !test)			gout = ( bb * exp( -1 * ( pow( (r2*j - centre), powr) + pow( (r1*i - centrey), powr) ) /aa) + floor + plus ); // 2d		}//got it	//		if(i==COLS/2-1) post("gout:%f", gout); //debug found always NaN -- not inited!!		nnato_constrain(x, gout);		        glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        glTexCoord2f(i * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(-a, -b, gout);        glTexCoord2f((i + 1) * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(a, -b, gout);        glTexCoord2f((i + 1) * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(a, b, gout);        glTexCoord2f(i * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(-a, b, gout);        glEnd();        glPopMatrix();      }    }}void nnato_glfun2(n2glatom glatom){    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS;  //gauss variables  	float		    aa, bb, 				// what a mess... 					centre = x->centre,					centrey = x->centrey,					stdDev = x->stdDev,					peak = x->peak,					floor = x->floor,					powr = x->power,					plus = x->plus ;	float			r1 = x->r1,  r2 = x->r2, gout ;	//geeeeee	int	test;	    if (!x->on) return;       	aa = 2 * pow(stdDev, powr);		    	    		bb = (peak - floor);			        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);	// center fill screen    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {		//there*        glPushMatrix();        glTranslatef(i, j, 0);                glRotatef(anglx, 1, 0, 0);        glRotatef(angly, 0, 1, 0);        glRotatef(anglz, 0, 0, 1);         		if ( !x->mod)		gout = ( bb * exp( -1 * ( pow( (r2*j - centre), powr) + pow( (r1*i - centrey), powr) ) /aa) + floor + plus ); // 2d aa!		else {		test = j % x->mod ;			if ( !test)			gout = ( bb * exp( -1 * ( pow( (r2*j - centre), powr) + pow( (r1*i - centrey), powr) ) /aa) + floor + plus ); // 2d		}//got it			nnato_constrain(x, gout);		        glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        glTexCoord2f(i * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(-a, -b, gout);        glTexCoord2f((i + 1) * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(a, -b, gout);        glTexCoord2f((i + 1) * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(a, b, gout);        glTexCoord2f(i * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(-a, b, gout);        glEnd();        glPopMatrix();      }    }}void nnato_glfun3(n2glatom glatom){    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS,           nr ;        if (!x->on) return;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {        glPushMatrix();        glTranslatef(i, j, 0);		if(j%x->step==x->result)        nr = ran() * x->dev + x->offset;        glRotatef(anglx + nr, 1, 0, 0);        glRotatef(angly + nr, 0, 1, 0);        glRotatef(anglz + nr, 0, 0, 1);                glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        glTexCoord2f(i * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(-a, -b, nr);        glTexCoord2f((i + 1) * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(a, -b, nr);        glTexCoord2f((i + 1) * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(a, b, nr);        glTexCoord2f(i * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(-a, b, nr);        glEnd();        glPopMatrix();      }    }}void nnato_glfun4(n2glatom glatom){    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS,           nr, nr1, nr2 ;        if (!x->on) return;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {        glPushMatrix();        glTranslatef(i, j, 0);		if(j%x->step==x->result){        nr = ran() * x->dev + x->offset;        nr1 = ran() * x->dev + x->offset;        nr2 = ran() * x->dev + x->offset;        }        glRotatef(anglx + nr, 1, 0, 0);        glRotatef(angly + nr1, 0, 1, 0);        glRotatef(anglz + nr2, 0, 0, 1);                glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        glTexCoord2f(i * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(-a, -b, nr);        glTexCoord2f((i + 1) * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(a, -b, nr1);        glTexCoord2f((i + 1) * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(a, b, nr2);        glTexCoord2f(i * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(-a, b, nr1);        glEnd();        glPopMatrix();      }    }}void nnato_glfun5(n2glatom glatom){    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS,           nr, nr1, nr2 ;        if (!x->on) return;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {        glPushMatrix();        glTranslatef(i, j, 0);		if(j%x->step==x->result){        nr = ran() * x->dev + x->offset;        nr1 = ran() * x->dev + x->offset;        nr2 = ran() * x->dev + x->offset;        }        glRotatef(anglx , 1, 0, 0);        glRotatef(angly , 0, 1, 0);        glRotatef(anglz , 0, 0, 1);                glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        glTexCoord2f(i * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(-a, -b, nr);        glTexCoord2f((i + 1) * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(a, -b, nr1);        glTexCoord2f((i + 1) * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(a, b, nr2);        glTexCoord2f(i * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(-a, b, nr1);        glEnd();        glPopMatrix();      }    }}void nnato_glfun6(n2glatom glatom){    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS,           nr = x->nr,            nr1 = x->nr1,             nr2 = x->nr2 ;        if (!x->on) return;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {        glPushMatrix();        glTranslatef(i, j, 0);        glRotatef(anglx , 1, 0, 0);        glRotatef(angly , 0, 1, 0);        glRotatef(anglz , 0, 0, 1);                glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        glTexCoord2f(i * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(-a, -b, nr);        glTexCoord2f((i + 1) * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(a, -b, nr1);        glTexCoord2f((i + 1) * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(a, b, nr);        glTexCoord2f(i * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(-a, b, nr1);        glEnd();        glPopMatrix();      }    }}void nnato_glfun7(n2glatom glatom){    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS,           nr = x->nr,            nr1 = x->nr1,             nr2 = x->nr2 ;        if (!x->on) return;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {        glPushMatrix();        glTranslatef(i, j, 0);        glRotatef(anglx , 1, 0, 0);        glRotatef(angly , 0, 1, 0);        glRotatef(anglz , 0, 0, 1);                glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        glTexCoord2f(i * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(-a, -b, nr2);        glTexCoord2f((i + 1) * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(a, -b, nr1);        glTexCoord2f((i + 1) * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(a, b, nr2);        glTexCoord2f(i * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(-a, b, nr1);        glEnd();        glPopMatrix();      }    }}void nnato_glfun8(n2glatom glatom)							// with rate++{    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS,           nr = x->nr,            nr1 = x->nr1,             nr2 = x->nr2 ;        if (!x->on) return;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {        glPushMatrix();        glTranslatef(i, j, 0);        glRotatef(anglx , 1, 0, 0);        glRotatef(angly , 0, 1, 0);        glRotatef(anglz , 0, 0, 1);                glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        glTexCoord2f(i * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(-a, -b, nr2 += x->rate);        glTexCoord2f((i + 1) * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(a, -b, nr1 -= x->rate);        glTexCoord2f((i + 1) * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(a, b, nr2 += x->rate);        glTexCoord2f(i * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(-a, b, nr1 -= x->rate);        glEnd();        glPopMatrix();      }    }}void nnato_glfun9(n2glatom glatom)							// with rate++{    NNato *x = (NNato *)n2getglatomobj(glatom);    int	   i, j,    		COLS = x->c,    		ROWS = x->r;                           float  a  = x->vertex,           b  = x->vertex2,           anglx = x->anglx,           angly = x->angly,           anglz = x->anglz,           TILE_TEX_W = 1.0/COLS,           TILE_TEX_H = 1.0/ROWS,           nr = x->nr,            nr1 = x->nr1,             nr2 = x->nr2 ;        if (!x->on) return;        glShadeModel(x->shademodel);    glColor3f(x->red, x->green, x->blue);    glTranslatef(-COLS / 2.0 + .5, -ROWS / 2.0 + .5, 0);    for (i = 0; i < COLS; i++) {      for (j = 0; j < ROWS; j++) {        glPushMatrix();        glTranslatef(i, j, 0);        glRotatef(anglx , 1, 0, 0);        glRotatef(angly , 0, 1, 0);        glRotatef(anglz , 0, 0, 1);                glBegin(x->type);      	glNormal3f(x->normalx,x->normaly,x->normalz);        glTexCoord2f(i * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(-a, -b, nr2 += x->rate);        glTexCoord2f((i + 1) * TILE_TEX_W, j * TILE_TEX_H);        glVertex3f(a, -b, nr1 -= x->rate);        glTexCoord2f((i + 1) * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(a, b, nr2 += x->rate);        glTexCoord2f(i * TILE_TEX_W, (j + 1) * TILE_TEX_H);        glVertex3f(-a, b, nr1 -= x->rate);        glEnd();        glPopMatrix();      }    }}void nnato_glregister(NNato *x, void *klientz){    n2glregisterx(x,n2objtype,x->glout,klientz);  // bkom 01 klient ov gl alimentari data}			// // returns a random double between 0 and 1 //double ran(void){		return(alea(0.0, 1.0));}//// returns a random value as double between min and max value // ANSI says that RAND_MAX = 32767, pretty piss poor I say!//double alea(double min, double max){	if (max >= min)		return ((max-min)*((double)rand()/RAND_MAX) + min);	else		return ((min-max)*((double)rand()/RAND_MAX) + max);	}//comment//comments are for me, not for you//under no way you should think that//under no way this is core//no way //i am no programmer//simply implies a mental state of//euforia carefully induced by action//