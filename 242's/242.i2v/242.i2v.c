//produce a vector out each frame like this: [x][y][rgbvalue]#include "Movies.h"#include "ext_common.h"#include "ext.h"#include "ext_user.h"#include "n2.basicstrings.c"#include "n2.0000.h"     // n2.inkludes#define MAXSIZE 256typedef struct zttz {	Object   	n_ob;     // required max 	void     	*n2hdr;   // required nato - position = signifikant _ must b 2nd		void	  	*out; // bang outlet	 	n2imgptr    gvelt;         // img buffer    	short           othere,mode,outputmode;       // var!ablz	t_atom	vout[MAXSIZE];    	Boolean        on,bypass,freeze,think,quarrel;  // nato.objstate flagz} NNato;void *nnato_new(long variant);void nnato_assist(NNato *x, void *b, long msg, long nr, char *s);void nnato_info(NNato *x, void *p, void *b);void nnato_free(NNato *x);void nnato_processimage(NNato *x, n2atom *data);void nnato_on(NNato *x, long flag);void nnato_bypass(NNato *x, long flag);void nnato_freeze(NNato *x, long flag);void nnato_int(NNato *x, long n);void nnato_think(NNato *x, short val);void nnato_quarrel(NNato *x, short val);void nnato_othere(NNato *x, short red);void nnato_outhere(NNato *x, short red);void nnato_mode(NNato *x, short red);void     *nnato_class;main(void){	setup(&nnato_class, nnato_new, (method)nnato_free, (short)sizeof(NNato), 0L, A_DEFLONG,0);    n2objaddimagecmd();    n2addstatecmd((method)nnato_int,0L,                  (method)nnato_on,(method)nnato_freeze,(method)nnato_bypass,                  (method)nnato_think,(method)nnato_quarrel,0L,0); 	addmess((method)nnato_assist, "assist",    	A_CANT,0); 	addmess((method)nnato_info,    "info",		    A_CANT,0);    	addmess((method)nnato_othere,                      "output",           A_DEFLONG,0);    	addmess((method)nnato_outhere,                   "outputmode",           A_DEFLONG,0);    	addmess((method)nnato_mode,                        "mode",           A_DEFLONG,0);    	n2addfklass("242.i2v");	post("	242.i2v: andr]e sierÃ2002");  }void nnato_assist(NNato *x, void *b, long msg, long nr, char *s){	if (msg == 1)      // !nlet	   strcpy( s, "(Nato) Input Image");     // s!ng.oun.pra!zez - comment +? hap!l+e +? da.     else       {	   if (msg == 2)   // outlet	      if (nr == 0)	         strcpy( s, "(List)");  // default `image data type` outlet de[a]ss!zt--       }}void nnato_info(NNato *x, void *p, void *b){      n2info();}void *nnato_new(long variant){    NNato      *x;    short      err,i;  		x = (NNato *)newobject(nnato_class);	x->out = listout(x);    if (err = n2objinit(x))       { post("242.i2v  :  n2objinit err = %ld",err); return;}            if ((err = n2inewimage(&x->gvelt,n2idefwidth,n2idefheight)))       { post("242.i2v  :  n2inewimage err = %ld",err); goto ikk;}      n2objsetimagefun(x,(method)nnato_processimage);	x->othere = 1;	x->mode = 3; //default to avg calculation	x->outputmode = 1; //default to only values output	for (i=0;i<MAXSIZE;i++) 		x->vout[i].a_w.w_long=0;    x->on = true;    x->bypass = x->freeze = x->think = x->quarrel = false;         return (x);ikk:	nnato_free(x);}void nnato_free(NNato *x){    if (x->gvelt) { n2idisposeimage(x->gvelt); x->gvelt = 0;}    n2objfree(x);}void nnato_on(NNato *x, long flag){        x->on = flag;}    void nnato_bypass(NNato *x, long flag){        x->bypass = flag;}      void nnato_freeze(NNato *x, long flag){        x->freeze = flag;} void nnato_int(NNato *x, long n){   n2defintstatefun(x,n);}void nnato_think(NNato *x, short val){   x->think = val;}void nnato_quarrel(NNato *x, short val){   x->quarrel = val;}void nnato_othere(NNato *x, short red){   x->othere = red;}void nnato_outhere(NNato *x, short red){   x->outputmode = red;}void nnato_mode(NNato *x, short red){   x->mode = red;}void nnato_processimage(NNato *x, n2atom *data){                       long           i, j,k,arg=0, roubitez, pix;                              short          check, width, height, err, redpix, greenpix, bluepix, value;                            Ptr            src, srcadresz;          n2pixmaphdl    srcpixmap;    n2pixstate     srcpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);    t_atom *output;        if (!x->on || !gveltptr) return;        if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.i2v  : n2iensureimagedimeq err = %ld", err);             return;           }           if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);                                 srcpixztate = n2igetpixstate(srcpixmap);                 if (!n2ilockpix(srcpixmap)) return;                              srcadresz = n2igetpixaddr(srcpixmap);  		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);	arg=0;	output = x->vout;                    for(i = 0; i < height; i++) {            src = srcadresz + i * roubitez;                        for(j = 0; j < width; j++) {                          pix = n2get32(src);                redpix=n2get32red(pix);                greenpix=n2get32green(pix);                bluepix=n2get32blue(pix);         	         if(!x->mode) value = redpix;	         else if(x->mode==1) value = greenpix;	         else if(x->mode==2) value = bluepix;	         else if(x->mode==3) value = redpix + greenpix + bluepix /3; //avg colors down		if(!x->outputmode) {// output coords+value	 		for(k = 0; k < 3; k++) {	 		  if (arg>MAXSIZE) { arg = 0; goto bangg; }	 		  if (!k) { output[arg].a_w.w_long = j; arg++;}	 		  else if (k==1) { output[arg].a_w.w_long = i; arg++;}	  		  else if (k==2) { output[arg].a_w.w_long = value; arg++;}			 		}		} else if (x->outputmode==1) { //output only values	 		  if (arg>MAXSIZE) { arg = 0; goto bangg; }	 		  output[arg].a_w.w_long = value; arg++;		}bangg:		;                }        	src+=4;	    }		   if(x->othere) {	for(i=0; i<MAXSIZE; i++){		SETLONG(output+i, output[i].a_w.w_long);	}		outlet_list(x->out,0L,arg, output);	   }		return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);}		