// 1d && magnitude// inspired over Trond Lossius' list-gauss#include "Movies.h"#include "ext_common.h"#include "ext.h"#include "ext_user.h"#include "math.h"#include "n2.basicstrings.c"#include "n2.0000.h"     typedef struct zttz {	Object   		n_ob;      	void     		*n2hdr;   		void             	*dataout;      	n2imgptr         	gvelt;         	long               	centre, stdDev, floor, peak, power, plus, variant,			     	mod, angle	;	float			r1, r2	;   	Boolean          	on,bypass,freeze,think,quarrel;  } NNato;void *nnato_new(short variant);void nnato_assist(NNato *x, void *b, long msg, long nr, char *s);void nnato_info(NNato *x, void *p, void *b);void nnato_free(NNato *x);void nnato_processimage(NNato *x, n2atom *data);void nnato_processimage2(NNato *x, n2atom *data);void nnato_on(NNato *x, long flag);void nnato_bypass(NNato *x, long flag);void nnato_freeze(NNato *x, long flag);void nnato_int(NNato *x, long n);void nnato_bang(NNato *x);void nnato_think(NNato *x, short val);void nnato_quarrel(NNato *x, short val);void nnato_variant(NNato *x, short variant);void nnato_centre(NNato *x,   long centre);void nnato_coords(NNato *x, long centre);void nnato_stdDev(NNato *x,long stdDev);void nnato_floor(NNato *x,  long floor);void nnato_peak(NNato *x, long peak);void nnato_power(NNato *x, long power);void nnato_plus(NNato *x, long plus);void nnato_mod(NNato *x, long plus);void nnato_angle(NNato *x, float angle);void nnato_rot(NNato *x, float r1, float r2);void     *nnato_class;main (void){	setup(&nnato_class, nnato_new, (method)nnato_free, (short)sizeof(NNato), 0L,         A_DEFLONG, 0);    n2objaddimagecmd();    n2addstatecmd((method)nnato_int,(method)nnato_bang,                  (method)nnato_on,(method)nnato_freeze,(method)nnato_bypass,                  (method)nnato_think,(method)nnato_quarrel,(method)nnato_variant,0); 	addmess((method)nnato_assist,	                   "assist",    	A_CANT,0); 	addmess((method)nnato_info,	                    "info",		    A_CANT,0);    addmess((method)nnato_centre,                     "centre",           A_DEFLONG,0);    addmess((method)nnato_centre,                   "x",           A_DEFLONG,0);    addmess((method)nnato_coords,                      "coords",  A_DEFLONG, 0);    addmess((method)nnato_stdDev,             	  "dev",	    A_DEFLONG,0);    addmess((method)nnato_floor,                        "floor",       A_DEFLONG,0);    addmess((method)nnato_peak,                         "peak",     A_DEFLONG,0);    addmess((method)nnato_power,                       "pow",        A_DEFLONG,0);    addmess((method)nnato_plus,                           "+",           A_DEFLONG,0);    addmess((method)nnato_angle,                          "angle",           A_DEFFLOAT,0);    addmess((method)nnato_rot,                            "magnitude",  	      A_DEFFLOAT,A_DEFFLOAT, 0);    addmess((method)nnato_rot,                            "mag",  	      A_DEFFLOAT,A_DEFFLOAT, 0);    addmess((method)nnato_mod,                           "%",         A_DEFLONG,0);    n2addfklass("242.gauss1d");    post("242.gauss1d: sier, 2001");}void nnato_assist(NNato *x, void *b, long msg, long nr, char *s){	if (msg == 1)      	   sprintf(s, "n2ImageIn: variant_%ld", x->variant);      else       {	   if (msg == 2)   	      if (nr == 0)	         sprintf(s, "n2Imageout: %ld_%ld__%ld", x->peak, x->floor, x->variant);        }}void nnato_info(NNato *x, void *p, void *b){ //     n2info();}void *nnato_new(short variant){	NNato      *x;    	short      err;  		x = (NNato *)newobject(nnato_class);    	n2addoutlet(x,&x->dataout);        	if (err = n2objinit(x))       { post("242.gauss1d  :  n2objinit err = %ld",err); return;}           	if ((err = n2inewimage(&x->gvelt,n2idefwidth,n2idefheight)))       { post("242.gauss1d  :  n2inewimage err = %ld",err); goto ikk;}      	n2objsetimagefun(x,(method)nnato_processimage);		// igniting...	if(variant) x->variant = variant; else  x->variant = 0;	x->centre = 160;     	x->peak = -90;	x->stdDev = 110;	x->floor = 0;	x->power=2;	x->plus=0;	x->mod = 0;	x->r1 = x->r2 = 1.000 ;	x->mod = 0;	   	x->on = true;    	x->bypass = x->freeze = x->think = x->quarrel = false;           	return (x);ikk:	nnato_free(x);}void nnato_free(NNato *x){    if (x->gvelt) { n2idisposeimage(x->gvelt); x->gvelt = 0;}    n2objfree(x);}void nnato_on(NNato *x, long flag){        x->on = flag;}    void nnato_bypass(NNato *x, long flag){        x->bypass = flag;}      void nnato_freeze(NNato *x, long flag){        x->freeze = flag;} void nnato_int(NNato *x, long n){   n2defintstatefun(x,n);}void nnato_bang(NNato *x){   n2registerimage(x,n2objtype,x->dataout,0,x->gvelt);}void nnato_think(NNato *x, short val){   x->think = val;}void nnato_quarrel(NNato *x, short val){   x->quarrel = val;}void nnato_variant(NNato *x, short variant){   if (!variant)       n2objsetimagefun(x,(method)nnato_processimage);       else if (variant == 1)      n2objsetimagefun(x,(method)nnato_processimage2);}void nnato_centre(NNato *x, long centre){   x->centre = centre;}void nnato_stdDev(NNato *x, long stdDev){   x->stdDev = stdDev;}void nnato_peak(NNato *x, long peak){   x->peak = peak;}void nnato_floor(NNato *x, long floor){   x->floor = floor;}void nnato_power(NNato *x, long power){   x->power = power;}void nnato_plus(NNato *x, long plus){   x->plus = plus;}void nnato_mod(NNato *x, long plus){   x->mod = plus;}void nnato_coords(NNato *x, long centre){   x->centre = centre; }void nnato_rot(NNato *x, float r1, float r2){   x->r1 = r1; x->r2 = r2;}void nnato_angle(NNato *x, float angle){	x->r1 = sin (angle);	x->r2 = cos (angle);}void nnato_processimage(NNato *x, n2atom *data){                       long           i, j, roubitez, pix, gout;                              short          width, height, err;                        	long		    a, b, test ,					centre = x->centre,					stdDev = x->stdDev,					peak = x->peak,					floor = x->floor,					powr = x->power,					plus = x->plus ;	float		r1 = x->r1 ,  r2 = x->r2 ;	    Ptr            src, dst, srcadresz, dstadresz;          n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate, dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);        if (!x->on || !gveltptr) return;        if (x->freeze)	           {   	              n2registerimage( x, n2objtype, x->dataout, data, x->gvelt );	              return;	           }                       if (x->bypass)	           {	              n2registerimage( x, n2objtype, x->dataout, data, gveltptr);	              return;   	           }         if ((err = n2iensuredimeq( &gveltptr, &x->gvelt )))	           {	             post ("242.gauss1d  : n2iensureimagedimeq err = %ld", err);	             return;	           }                                  	a = 2 * pow(x->stdDev, powr);		//				    2		b = (x->peak - x->floor);			//      == 	   1/2¹sigma  - minimum                  if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;                         dstpixmap   = n2igetpixmap(dstgvelt);         srcpixztate = n2igetpixstate(srcpixmap);                dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;               if (!n2ilockpix(dstpixmap)) goto ikk;                      srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);	roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);                                    for(i = 0; i < height; i++)          {            src = srcadresz + i * roubitez;                        dst = dstadresz + i * roubitez;                                              for(j = 0; j < width; j++)          {  		if ( !x->mod)  		{		gout = ( b * exp( -1 * ( pow( (r2*j  + r1*i - centre), powr) ) /a) + floor + plus ); // 1d		}		else {		test = j % x->mod ;			if ( !test)	 		{			gout = ( b * exp( -1 * ( pow( (r2*j  + r1*i - centre), powr) ) /a) + floor + plus ); // 1d			}		}						pix = n2get32 (src);                      				n2set32m(dst,				         n2get32alpha(pix),				         n2klamp255(n2get32red(pix)   + gout),				         n2klamp255(n2get32green(pix) + gout),				         n2klamp255(n2get32blue(pix)  + gout));				src+=4;				dst+=4;					             }	 }  	n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}		void nnato_processimage2(NNato *x, n2atom *data){                       long           i, j, roubitez, pix, gout;                              short          width, height, err;                        	long		    a, b, test ,					centre = x->centre,					stdDev = x->stdDev,					peak = x->peak,					floor = x->floor,					powr = x->power,					plus = x->plus ;	float		r1 = x->r1 ,  r2 = x->r2 ;		    Ptr            src, dst, srcadresz, dstadresz;          n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate, dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);        if (!x->on || !gveltptr) return;        if (x->freeze)	           {   	              n2registerimage( x, n2objtype, x->dataout, data, x->gvelt );	              return;	           }                       if (x->bypass)	           {	              n2registerimage( x, n2objtype, x->dataout, data, gveltptr);	              return;   	           }         if ((err = n2iensuredimeq( &gveltptr, &x->gvelt )))	           {	             post ("242.gauss1d  : n2iensureimagedimeq err = %ld", err);	             return;	           }                                  	a = 2 * pow(x->stdDev, powr);		//				    2		b = (x->peak - x->floor);			//      == 	   1/2¹sigma  - minimum                  if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;                         dstpixmap   = n2igetpixmap(dstgvelt);         srcpixztate = n2igetpixstate(srcpixmap);                dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;               if (!n2ilockpix(dstpixmap)) goto ikk;                      srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);	roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);                                    for(i = 0; i < height; i++)          {            src = srcadresz + i * roubitez;                        dst = dstadresz + i * roubitez;                                              for(j = 0; j < width; j++)          {  		if ( !x->mod)  		{		gout = ( b * exp( -1 * ( pow( (r2*j  + r1*i - centre), powr) ) /a) + floor + plus ); // 1d		}		else {		test = j % x->mod ;			if ( !test)	 		{			gout = ( b * exp( -1 * ( pow( (r2*j  + r1*i - centre), powr) ) /a) + floor + plus ); // 1d			}		}						pix = n2get32 (src);                      				n2set32m(dst,				         n2get32alpha(pix),				         n2klamp255(n2get32red(pix)   / gout + gout),				         n2klamp255(n2get32green(pix) / gout + gout),				         n2klamp255(n2get32blue(pix)  / gout + gout));				src+=4;				dst+=4;					             }	 }  	n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}		