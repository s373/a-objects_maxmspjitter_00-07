/*deve receber uma lista, escrever essa posicao no espaco*/#include "Movies.h"#include "ext.h"#include "ext_common.h"#include "ext_user.h"#include "n2.basicstrings.c"#include "n2.0000.h"#include "agl.h"#include "GL/glut.h"//#define MAXVECTOR 256#define MAXVECTOR 64typedef struct zttz {	Object    n_ob; 	void     *n2hdr;    // required nato - position = important _ must b 2nd	    void   	 *glout;    short     type, gridx, gridy, step;    GLfloat   vertex,vertex2,red,green,blue,              normalx,normaly,normalz,              posit[MAXVECTOR][MAXVECTOR];      GLboolean texture;                  Boolean        on;  	float		inputlist[MAXVECTOR];	float		st;//	short		listlenght, oplenght;	} NNato;void *nnato_new(void);void nnato_assist(NNato *x, void *b, long msg, long nr, char *s);void nnato_info(NNato *x, void *p, void *b);void nnato_free(NNato *x);void nnato_on(NNato *x, long flag);void nnato_bang(NNato *x);void nnato_int(NNato *x, long n);   void nnato_variant(NNato *x, short variant);void nnato_type(NNato *x, short type);void nnato_vertex(NNato *x, long vertex, long vertex2);void nnato_shademodel(NNato *x, long type);void nnato_klr(NNato *x, long red, long green, long blue);void nnato_normalz(NNato *x, long koordx, long koordy, long koordz);void nnato_texture(NNato *x, long flag);void nnato_revertgeo(NNato *x);void nnato_revert(NNato *x);void nnato_vectinit(NNato *x);void nnato_grid(NNato *x, long gridx, long gridy);void nnato_list(NNato *x, Symbol *s, short argc, Atom *argv);				void nnato_st(NNato *x, float st);void nnato_glfun(n2glatom glatom);void nnato_glregister(NNato *x, void *klientz);void    *nnato_class;main(){	setup(&nnato_class, nnato_new, (method)nnato_free, (short)sizeof(NNato), 0L, 0L, 0); 	addmess((method)nnato_assist,	                  "assist",          	A_CANT,0); 	addmess((method)nnato_info,	                      "info",		        A_CANT,0);    n2objaddglcmd();    n2addstatecmd((method)nnato_int,(method)nnato_bang,                  (method)nnato_on,-1,-1,-1,-1,(method)nnato_variant,0);    addmess((method)nnato_klr,                        "color",              A_DEFLONG,A_DEFLONG,A_DEFLONG,0);    addmess((method)nnato_texture,                    "texture",            A_DEFLONG,0);    addmess((method)nnato_revert,                     "revert",             0);    addmess((method)nnato_grid,"grid",A_DEFLONG,A_DEFLONG,0);	addmess((method)nnato_list,"list",A_GIMME, 0);    addmess((method)nnato_st,"stride",A_DEFFLOAT, 0);    n2reklama();    post("	¶¹ã 		242.glplainoscillatoer   ¶¹",0);    n2addfklass("242.glplainosc11");	}void nnato_assist(NNato *x, void *b, long msg, long nr, char *s){	if (msg == 1)      // !nlet	   strcpy( s, m9ndfukcpropaganda00);       {	   if (msg == 2)   // outlet	      if (nr == 0)	         strcpy( s, n2gltypestr);  // default `gl data type` outlet de[a]ss!zt--	   }}void nnato_info(NNato *x, void *p, void *b){      n2info();}void *nnato_new(){    NNato      *x;	short      err, i,j;	x = (NNato *)newobject(nnato_class);    n2addoutlet(x,&x->glout);        if (err = n2objinit(x))       { post("242.glplain :  n2initobjekt err = %ld",err); return;}     nnato_revert(x);    post("revert bypassed",0);//    nnato_vectinit(x);	    for(i=0;i < x->gridx; i++)        for(j=0;j < x->gridy; j++){			x->posit[i][j] = 0; 	}			post ("zeroed vector i count %ld j count %ld", i, j,0);/*    for(i=0; i < MAXVECTOR; i++)    	x->inputlist[i]=0.0f;    post("inputlist zeroed  and i is %ld",i,0);*/    n2objsetglregister(x,(method)nnato_glregister);   // zpecify gl regizter routine    n2objsetglfun(x,(method)nnato_glfun);             // zpecify gl drau routine    post("registered and set fun",0);			x->on = true;    post("x->on = true",0);        	return (x);   ikk:	nnato_free(x);}void nnato_free(NNato *x){   //	if(x->posit)		    n2objfree(x);}void nnato_on(NNato *x, long flag){        x->on = flag;}  void nnato_int(NNato *x, long n)    {								       if (!n) x->on = false;   else x->on = true;}void nnato_bang(NNato *x){   n2gldraw(x, n2objtype);}void nnato_variant(NNato *x, short variant){//   if (!variant) n2objsetglfun(x,(method)nnato_glfun);}void nnato_st(NNato *x, float st){ 	x->st   = st; }void nnato_klr(NNato *x, long red, long green, long blue){   x->red   = (float)red   * 0.01;   x->green = (float)green * 0.01;   x->blue  = (float)blue  * 0.01;      }  void nnato_texture(NNato *x, long flag){    x->texture = flag;}void nnato_revert(NNato *x){	    x->normalx = x->normaly = 0.0;    x->normalz = 1.0;            x->gridx=64;    x->gridy=64;    x->step=0;    x->st=0.2;    x->texture = true;    nnato_klr(x,50,50,50);}void nnato_grid(NNato *x, long gridx, long gridy){//	if((gridx<MAXVECTOR&&gridx>0)&&	\	(gridy<MAXVECTOR&&gridy>0)){    x->gridx = gridx;    x->gridy = gridy;    x->step = 0; //lets begin again//    } else {//    x->gridx = 64;//   x->gridy = 64;    //    }}void nnato_vectinit(NNato *x){	short i,j;		post ("zeroing vector",0);    for(i=0;i<MAXVECTOR;i++)        for(j=0;j<MAXVECTOR;j++)		{			x->posit[i][j] = 0.0f; //			if (i==254)post("x->posit[%ld][%ld]=%f", i,j,x->posit[i][j],0);		}		post ("zeroed vector i count %ld j count %ld", i, j,0);}void nnato_list(NNato *x, Symbol *s, short argc, Atom *argv){	register short 	i, j;	short	listlen, indi, gridy, cpstep, gridx=x->gridx;	float	poslisratio, incremento, a, b, indice, val;		for (i=0; i < argc; i++) {		if (argv[i].a_type==A_LONG) {			x->inputlist[i] = (float)argv[i].a_w.w_long;//divide por 100 se int		}		else if (argv[i].a_type==A_FLOAT) {			x->inputlist[i] = argv[i].a_w.w_float;		}	 }//	}	//	post ("args set in x->inputlist",0);	cpstep = x->step;	// o indice	gridy = x->gridy;	listlen = argc;	//o comprimento da lista de entrada	post ("listlen is %ld",listlen, 0);	poslisratio = (float)gridy / listlen;	post ("poslisratio is %f",poslisratio, 0);				for(j=0; j<gridy; j++){					indice = ((float)j/poslisratio);// valor inteiro			indi = (int)(indice);				// valor arredondado			a = x->inputlist[indi];			b = x->inputlist[indi+1];			incremento = (float) ((b-a)/poslisratio)*(indi-indice);	//acho q vai exponencialment rebentar com a escala em cada unidade														//sempre 0.-1.			val = (float)x->inputlist[indi] + incremento;			x->posit[cpstep][j]=val;			if (j==gridy-1) {			post ("x->posit[%ld][%ld]=%f",cpstep, j, val, 0);			post ("a is %f b is %f indice %f",a, b, indice, 0);			}		}		post ("for cycle++",0);		if(x->step<gridx)  x->step+=1;	post("x->step=%ld", x->step,0);	if(x->step==gridx) x->step=0;		post ("and current active step is %ls",cpstep,0);	post ("       next active step is %ls",x->step,0);}void nnato_glfun(n2glatom glatom){    NNato *x = (NNato *)n2getglatomobj(glatom);	short	i,j, gridy=x->gridy, gridx=x->gridx;	float   st=x->st;        if (!x->on) return;        glTranslatef(-gridx / 2.0 + .5, -gridy / 2.0 + .5, 0); //center it    glColor3f(x->red, x->green, x->blue);	//color it    for(i=0;i < gridx;i++)    {        glBegin(GL_LINE_STRIP);        for(j=0;j <  gridy;j++)            glVertex3f( (float) st*i, (float) st*j, (float) x->posit[i][j]);        glEnd();    }        for(i=0;i < gridx;i++)    {        glBegin(GL_LINE_STRIP);        for(j=0;j < gridy;j++)            glVertex3f( (float) j, (float) i, (float) x->posit[j][i]);        glEnd();    }}     void nnato_glregister(NNato *x, void *klientz){    n2glregisterx(x,n2objtype,x->glout,klientz);  // bkom 01 klient ov gl alimentari data}			