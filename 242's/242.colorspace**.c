void tristimulus_product(double *matrix,double *input,double *output){  int f,g;  for(f=0;f<3;f++)    {    output[f] = input[0]*matrix[f*3+0]+                input[1]*matrix[f*3+1]+                input[2]*matrix[f*3+2];    }}void nnato_processimage(NNato *x, n2atom *data) // rgb->xyz{                       long           i, j, roubitez, pix, xc, yc, zc;//    double		   xt,yt,zt;                                 short          width, height, err;                        Ptr            src, dst, srcadresz, dstadresz;          n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate, dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);	double input[3],output[3];	double RnGnBn_XYZ[9]    = /* from Jain 71, almost same as Pratt, 66 */	                        { 0.60700,  0.17400,  0.20100,   	                          0.29900,  0.58700,  0.11400,  	                          0.00000,  0.06600,  1.11700 };         if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.colorspace  : n2iensureimagedimeq err = %ld", err);             return;           }           if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;                         dstpixmap   = n2igetpixmap(dstgvelt);         srcpixztate = n2igetpixstate(srcpixmap);                dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;               if (!n2ilockpix(dstpixmap)) goto ikk;                      srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);                    for(i = 0; i < height; i++)          {            src = srcadresz + i * roubitez;                        dst = dstadresz + i * roubitez;                                  for(j = 0; j < width; j++)            {                pix = n2get32(src);                input[0] = n2get32red(pix);                input[1] = n2get32green(pix);                input[2] = n2get32blue(pix);				tristimulus_product(RnGnBn_XYZ,input,output);				xc=output[0]; 				yc=output[1]; 				zc=output[2]; 				n2set32m(dst,				         n2get32alpha(pix),				         n2klamp255(xc),				         n2klamp255(yc),				         n2klamp255(zc));				src+=4;				dst+=4;					             }		 }  	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}/*		scrub	 *//*	percolate src, dubois	 *//*		allocating	 *//*		freeing	 *//*		initializing	 */void scrub_alloc(t_scrub *x){	x->buf0 = t_getbytes(BUFLENGTH * sizeof(float));	if (!x->buf0) {		error("scrub: out of memory");		return;	}	x->buf1 = t_getbytes(BUFLENGTH * sizeof(float));	if (!x->buf1) {		error("scrub: out of memory");		return;	}	x->buf2 = t_getbytes(BUFLENGTH * sizeof(float));	if (!x->buf2) {		error("scrub: out of memory");		return;	}}void scrub_free(t_scrub *x){	if (x->buf1)		t_freebytes(x->buf1, BUFLENGTH * sizeof(float));	if (x->buf2)		t_freebytes(x->buf2, BUFLENGTH * sizeof(float));	if (x->buf0)		t_freebytes(x->buf0, BUFLENGTH * sizeof(float));	dsp_free((t_pxobject *)x);}void *scrub_new(double initial_coeff){	int i;		float rate;    t_scrub *x = (t_scrub *)newobject(scrub_class);    dsp_setup((t_pxobject *)x,2);    outlet_new((t_object *)x, "signal");    scrub_alloc(x);        x->rate = 1.;    x->where = 0.;    x->recordPoint = 0;    x->whichBuf = 0;    x->overlap = 4410.;    x->recordenv = 4410.;    x->attkTail = BUFSIZE - x->overlap;        x->overlapInv = 1./x->overlap;     x->recordenvInv = 1./x->recordenv;        x->power = 1;        for(i=0; i<BUFSIZE; i++) {    	x->buf0[i] = 0.;    	x->buf1[i] = 0.;    	x->buf2[i] = 0.;    }    x->srate = sys_getsr();    x->one_over_srate = 1./x->srate;        return (x);}/*		buffersinstruct	 *//*		freeing	 *//*		initializing	 */    float *buf0, *buf1, *buf2;