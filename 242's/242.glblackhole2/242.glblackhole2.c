/*242.glhole__ 15.12.2001 / sier modoriginal copyright Chris Halsall September 2000					 .revision: particle struct outside object struct*/// ----------------------// OpenGL Black Hole Simulator.//// Written by and Copyright Chris Halsall (chalsall@chalsall.com).// First published on the O'Reilly Network on Linux.com// (oreilly.linux.com).  September 2000.  All rights reserved.//// This code is licensed under the GNU GPL Version 2.0.// See (URL: http://www.gnu.org/copyleft/gpl.html ) for details.//// Coded to the groovy tunes of Fluke: Risotto.//// Dedicated to Stephen W. Hawking, one of the greatest explorers // of our time.//#define PROGRAM_TITLE "O'Reilly Net: Black Hole -- C.Halsall"#include "Movies.h"#include "ext_common.h"#include "ext.h"#include "ext_user.h"#include "n2.basicstrings.c"#include "n2.0000.h"#include "agl.h"#include <GL/gl.h>   // OpenGL itself.#include <glu.h>  // GLU support library.#include <GL/glut.h> // GLUT support library.#include <math.h>#include <stdlib.h> // for rand() RANDMAX... no we dont#include <stdio.h>   // Always a good idea.//#include <memory>//#include <cstring>//void * 	memset(void * dst, int val, size_t len);//#include <stdio.h>//#include <iostream.h>//#include <string.h>//#include <math.h>// our particle structure// A quick macro to populate a 1x3 vector array. #define ourVectInit(a,x,y,z) { (a)[0]=x; (a)[1]=y; (a)[2]=z; }// "Name" for first (and only) OpenGL display list.#define STAR_FIELD 1#define M_PI n2mathpi// Structure to hold all the data for each particle.typedef struct {   int Running;   float Pos[3];  // Position.   float Vel[3];  // Velocity.   float Grav[3]; // Acceleration.   float Color[3];} Particle;typedef struct zttz 	//our nato.gl obj{	Object    n_ob;		//max 	void     *n2hdr;    // nato.header	    void   	 *glout;	// sync gl out		// Pointer for allocated array of Particles.	Particle *Parts;			// We'll request a sphere from the GLU library at run-time.	struct GLUquadric *Black_Hole;    short     type;    GLfloat   red,green,blue,alpha,              normalx,normaly,normalz; 		    GLboolean texture, Draw_Axis, Draw_Vectors, Draw_Stars, Heads_Up;  //our flags                long      variant ;    Boolean        on;          	//sphere variables    GLfloat srad;    GLint sx, sy; 		// Particle status variables.	int Parts_Running, Parts_Allocated, Parts_LastUnused;		// Number of parts initially in the system.  Make sure there's at least		// one over a hundred (101, 801), so our Root particle doesn't get deleted.	int Parts_Num;	float Parts_Brightness ;		// Particle Gun variables.	float Gun_PX, Gun_PY, Gun_PZ, 		  Gun_VX, Gun_VY, Gun_VZ,		  Gun_R, Gun_OffR, firetresh;		// Backwards firing and off-target probabilities.	float Gun_Back, Gun_Off ;		// '.' key toggels between keypad adjusting gun position and eject vect.	int Gun_Control;		// Orbit and motion settings.	int On_Orbit, Move_Enable, Move_Step;		// Observer initial placement.	float Obs_Angle, Obs_Height, Obs_Dist;		// Calculated observer location.	float Obs[3];		// How quickly do the orbits decay? 		// Lower number (limit 1) is faster decay.	int Decay_Factor;		// The force of gravity exterted by the black hole.	float Grav;} NNato;// Somewhat arbitrary values for Event and Escape horizons.#define EVENT_HORIZON_GRAV .5#define ESCAPE_HORIZON 60 #define ESCAPE_HORIZON_SQR (ESCAPE_HORIZON * ESCAPE_HORIZON)//	 function prototypesvoid *nnato_new(void);void nnato_assist(NNato *x, void *b, long msg, long nr, char *s);void nnato_info(NNato *x, void *p, void *b);void nnato_free(NNato *x);void nnato_on(NNato *x, long flag);void nnato_bang(NNato *x);void nnato_int(NNato *x, long n);   void nnato_variant(NNato *x, short variant);void nnato_init_globals(NNato *x);// particle functionsParticle 	*ourAllocParticles(NNato *x, int Num);void 		ourInit(NNato *x);void 		ourBuildStarfield(NNato *x, int Stars);static void ourFireParticleGun(Particle *p, NNato *x);	//need to acess vars at xstatic void ourMoveParticle(Particle *p, NNato *x);float 		ourA2R(float Angle);static void ourCalcObs(NNato *x);void 		ourRenderAxis(void);void 		ourRenderVectors(NNato *x);void 		ourRenderHeadsUp(NNato *x);// particle messagesvoid 	nnato_Parts_Num (NNato *x, long val);void 	nnato_Parts_Brightness (NNato *x, float val);void 	nnato_Draw_Axis 	(NNato *x, long val);void 	nnato_Draw_Vectors 	(NNato *x, long val);void 	nnato_Draw_Stars 	(NNato *x, long val);void 	nnato_Heads_Up 		(NNato *x, long val);void 	nnato_Gun_Back 		(NNato *x, float val);void 	nnato_Gun_Off 		(NNato *x, float val);void 	nnato_Gun_Control 	(NNato *x, int val);void 	nnato_On_Orbit 		(NNato *x, int val);void 	nnato_Move_Enable 	(NNato *x, int val);void 	nnato_Move_Step 	(NNato *x, int val);void 	nnato_Obs_Angle 	(NNato *x, float val);void 	nnato_Obs_Height 	(NNato *x, float val);void 	nnato_Obs_Dist 		(NNato *x, float val);void 	nnato_Decay_Factor 	(NNato *x, int val);void 	nnato_Grav 			(NNato *x, float val);void 	nnato_doGunP(NNato *x, float gx, float gy, float gz);void 	nnato_doGunV(NNato *x, float gx, float gy, float gz);static void ourPrintString(void *font, char *str);//void 	nnato_texture		(NNato *x, long flag);void 	nnato_klr(NNato *x, long red, long green, long blue, long alpha);//added alphavoid 	nnato_sphere(NNato *x, float koordx, long koordy, long koordz);void 	nnato_init_globals(NNato *x);void	nnato_revert(NNato *x);void nnato_glfun(n2glatom glatom);		// nprocesxvoid nnato_glregister(NNato *x, void *klientz); // registerdouble ran(void);	//ran 0. 1.double alea(double min, double max);void    *nnato_class;//mainmain(){	setup(&nnato_class, nnato_new, (method)nnato_free, (short)sizeof(NNato), 0L, 0L, 0); 	addmess((method)nnato_assist,	                  "assist",          	A_CANT,0); 	addmess((method)nnato_info,	                      "info",		        A_CANT,0);    n2objaddglcmd();    n2addstatecmd((method)nnato_int,(method)nnato_bang,                  (method)nnato_on,-1,-1,-1,-1,(method)nnato_variant,0);    addmess((method)nnato_klr,                        "color",              A_DEFLONG,A_DEFLONG,A_DEFLONG,A_DEFLONG,0);    addmess((method)nnato_texture,                    "texture",            A_DEFLONG,0);    addmess((method)nnato_revert,                     "revert",             0);    addmess((method)nnato_Parts_Num,                  "parts.num",          A_DEFLONG,0);    addmess((method)nnato_Parts_Brightness,           "parts.bright",       A_DEFFLOAT,0);    addmess((method)nnato_Draw_Axis,                  "draw.axis",          A_DEFLONG,0);    addmess((method)nnato_Draw_Vectors,               "draw.vector",        A_DEFLONG,0);    addmess((method)nnato_Draw_Stars,                 "draw.stars",        A_DEFLONG,0);    addmess((method)nnato_Heads_Up,                   "draw.hud",        A_DEFLONG,0);    addmess((method)nnato_init_globals,                   "init",        0);//    addmess((method)nnato_On_Orbit,         "are_we_on_orbit?",        A_DEFLONG,0);    addmess((method)nnato_On_Orbit,         "orbit",        			A_DEFLONG,0);//    addmess((method)nnato_Move_Enable,      "are_we_on_moving?",        A_DEFLONG,0);    addmess((method)nnato_Move_Enable,      "moving",        			A_DEFLONG,0);    addmess((method)nnato_Move_Step,      "move.step",        			A_DEFLONG,0);    addmess((method)nnato_Obs_Angle,         "obs.angle",       A_DEFFLOAT,0);    addmess((method)nnato_Obs_Height,        "obs.height",       A_DEFFLOAT,0);    addmess((method)nnato_Obs_Dist,          "obs.dist",       A_DEFFLOAT,0);    addmess((method)nnato_Grav,              "grav",      		 A_DEFFLOAT,0);    addmess((method)nnato_Grav,              "newton's_apple",   A_DEFFLOAT,0);    addmess((method)nnato_Decay_Factor,      "decay.factor",     A_DEFLONG,0);    addmess((method)nnato_sphere,      		"sphere.geo",     A_DEFFLOAT, A_DEFLONG, A_DEFLONG,0);    addmess((method)nnato_doGunP,      		"gun.p",     A_DEFFLOAT, A_DEFFLOAT, A_DEFFLOAT,0);    addmess((method)nnato_doGunV,      		"gun.v",     A_DEFFLOAT, A_DEFFLOAT, A_DEFFLOAT,0);    addmess((method)nnato_Gun_Back,           "gun.back",       A_DEFFLOAT,0);    addmess((method)nnato_Gun_Off,           "gun.prob",      		 A_DEFFLOAT,0);    addmess((method)nnato_Gun_Control,    	 "gun.control",        A_DEFLONG,0);    post ("242.op.glbhole ÑÑÑ sier,2002ÑÑÑcopyright Chris Halsall September 2000", 0);    n2addfklass("242.op.glhole");	}void nnato_assist(NNato *x, void *b, long msg, long nr, char *s){	if (msg == 1)      // !nlet	   strcpy( s, n2gltypestr);       {	   if (msg == 2)   // outlet	      if (nr == 0)	         strcpy( s, n2gltypestr);  // default `gl data type` outlet de[a]ss!zt--	   }}void nnato_info(NNato *x, void *p, void *b){ n2info();}void *nnato_new(){    NNato      *x;	short      err;	x = (NNato *)newobject(nnato_class);    n2addoutlet(x,&x->glout);        if (err = n2objinit(x))       { post("242.glhole :  n2initobjekt err = %ld",err); return;} 	nnato_init_globals(x);    n2objsetglregister(x,(method)nnato_glregister);   // zpecify gl regizter routine    n2objsetglfun(x,(method)nnato_glfun);             // zpecify gl drau routine   // OK, OpenGL's ready to go.  Let's call our own init function.   ourInit(x);    nnato_revert(x);			x->on = true;	return (x);   ikk:	nnato_free(x);}void nnato_free(NNato *x){   	   // Free our allocated particle array.	   //ourAllocParticles(x,0);    if (x->Parts) {n2disposeptr(x->Parts);  x->Parts = 0;}    n2objfree(x);}void nnato_on(NNato *x, long flag){        x->on = flag;}  void nnato_int(NNato *x, long n)    {								       if (!n) x->on = false;   else x->on = true;}void nnato_bang(NNato *x){   n2gldraw(x, n2objtype);}void nnato_variant(NNato *x, short variant){   if (!variant) n2objsetglfun(x,(method)nnato_glfun);}double ran(void){		return(alea(0.0, 1.0));}double alea(double min, double max){	if (max >= min)		return ((max-min)*((double)rand()/RAND_MAX) + min);	else		return ((min-max)*((double)rand()/RAND_MAX) + max);}static void ourPrintString(void *font, char *str){   int i,l=strlen(str);   for(i=0;i<l;i++)      glutBitmapCharacter(font,*str++);}void nnato_Parts_Num (NNato *x, long val){	x->Parts_Num = val ;	ourAllocParticles (x,x->Parts_Num) ; 	//important!! reallocate part structure	ourBuildStarfield (x,val);}void nnato_Parts_Brightness (NNato *x, float val){	x->Parts_Brightness = val ;}void 	nnato_Draw_Axis 	(NNato *x, long val){	x->Draw_Axis = val ;}void 	nnato_Draw_Vectors 	(NNato *x, long val){	x->Draw_Vectors = val ;}void 	nnato_Draw_Stars 	(NNato *x, long val){	x->Draw_Stars = val ;}void 	nnato_Heads_Up 		(NNato *x, long val){	x->Heads_Up = val ;}void 	nnato_Gun_Back 		(NNato *x, float val){	x->Gun_Back = val ;}void 	nnato_Gun_Off 		(NNato *x, float val){	x->Gun_Off = val ;}void 	nnato_Gun_Control 	(NNato *x, int val){	x->Gun_Control = val ;}void 	nnato_On_Orbit 		(NNato *x, int val){	x->On_Orbit = val ;}void 	nnato_Move_Enable 	(NNato *x, int val){	x->Move_Enable = val ;}void 	nnato_Move_Step 	(NNato *x, int val){	x->Move_Step = val ;}void 	nnato_Obs_Angle 	(NNato *x, float val){	x->Obs_Angle = val ;}void 	nnato_Obs_Height 	(NNato *x, float val){	x->Obs_Height = val ;}void 	nnato_Obs_Dist 		(NNato *x, float val){	x->Obs_Dist = val ;}void 	nnato_Decay_Factor 	(NNato *x, int val){	x->Decay_Factor = val ;}void 	nnato_Grav 			(NNato *x, float val){	x->Grav = 0.1*val ;}void nnato_klr(NNato *x, long red, long green, long blue, long alpha){   x->red   = (float)red   * 0.01;   x->green = (float)green * 0.01;   x->blue  = (float)blue  * 0.01;         x->alpha  = (float)alpha  * 0.01;      }  void nnato_texture(NNato *x, long flag){    x->texture = flag;}void nnato_revert(NNato *x){	    x->texture = true;    nnato_klr(x,50,50,50,50);//   ourInit(x);	//twice called}void 	nnato_sphere(NNato *x, float koordx, long koordy, long koordz){	x->srad = koordx ;	x->sx	= koordy ;	x->sy	= koordz ;}void nnato_init_globals (NNato *x){	x->Parts_Running=0;	x->Parts_Allocated=0;	x->Parts_LastUnused=1;	x->Parts_Num = 501;	x->Parts_Brightness = 0.35;	x->Draw_Axis = 1;	x->Draw_Vectors = 1;	x->Draw_Stars = 1;	x->Heads_Up = 1;	x->texture = 0;	x->Gun_PX = 0;	x->Gun_PY = 0;	x->Gun_PZ = 4;	x->Gun_VX =-0.135;	x->Gun_VY = 0.0125;	x->Gun_VZ = 0.0;	x->Gun_R = 0.005;	x->Gun_OffR = 0.050;	x->Gun_Back = 0.9, x->Gun_Off = 0.9;	x->Gun_Control = 1;	x->On_Orbit=1;	x->Move_Enable=1;	x->Move_Step=0;	x->Obs_Angle=114.0;	x->Obs_Height=.2;	x->Obs_Dist=4.6;	x->Obs[0] = 	x->Obs[1] = 	x->Obs[2] = 0.;	x->Decay_Factor = 6000;	x->Grav = 0.075;			x->srad = 0.02   ;	x->sx = x->sy = 8;}void 	nnato_doGunP(NNato *x, float gx, float gy, float gz){	x->Gun_PX = gx ;	x->Gun_PY = gy ;	x->Gun_PZ = gz ;}void 	nnato_doGunV(NNato *x, float gx, float gy, float gz){	x->Gun_VX = gx ;	x->Gun_VY = gy ;	x->Gun_VZ = gz ;}Particle *ourAllocParticles(NNato *x, int Num){   int i;   Particle *P;//   P = realloc(x->Parts, sizeof(Particle) * Num);//   P = realloc(x->Parts, sizeof(Particle) * Num);// 	x->Parts = (Particle *) n2newptrclear (Num * sizeof(Particle));//	if (!x->Parts) goto ikk;  P = (Particle *) n2newptrclear (Num * sizeof(Particle));	if (!P) goto ikk;	//   if (!P)//      return 0;//	if (x->Parts_Allocated < Num)//      memset(&P[x->Parts_Allocated],	\         0,sizeof(Particle) * (Num-x->Parts_Allocated));	//	ourAllocParticles(x,Num);				// cant find memset,,,   if (x->Parts_LastUnused > Num)      x->Parts_LastUnused = Num;   x->Parts_Running = 0;   for (i = 0; i < Num; i++)      if (P[i].Running)          x->Parts_Running++;   x->Parts_Allocated = Num;   x->Parts = P ; //  P = x->Parts;   return P;ikk://   return 0;   nnato_free(x);}// ------// Builds a Display List containing a random star field.//// Note: this could also be done by calculating the star points in this // routine, which would be faster than having OpenGL perform two // rotations (matrix multiplications) for each star.  However, this // technique is simpler and faster for the programmer, and demonstrates // how successive transformations can be a powerful tool.void ourBuildStarfield(NNato *x, int Stars){   int Cnt;   glNewList(STAR_FIELD, GL_COMPILE);   glMatrixMode(GL_MODELVIEW);   glPushMatrix();   for ( Cnt = 0; Cnt < Stars; Cnt++) {      // Vary the color for each star.      glColor4f(         0.8 + alea(0.,0.2),         0.8 + alea(0.,0.2),         0.8 + alea(0.,0.2),         .95);       // Vary the size.  Ensure integer sizes to avoid alias shimmering.//      glPointSize(alea(0.,2) > 1 ? 1.0 : 2.0);      glPointSize(alea(0.,8.));      // Spin your Universe, round and round....      glRotatef(alea(0.,100),0.0f,1.0f,0.0f);      glRotatef(alea(0.,100),1.0f,0.0f,0.0f);      glBegin(GL_POINTS);         glVertex3f(15.0, 0.0f, 0.0f);      glEnd();   }   glPopMatrix();   glEndList();}// ------// Fires the Particle Gun, or, sets up the passed Particle to be// placed at the Particle Gun location, and fired in a direction// specified in Gun_Va, with 'a' being "X", "Y", or "Z".//// The particles are normally fired with a randomness of Gun_R.// Occationally (by default 10%) a larger randomness of Gun_OffR is// added.  Also, 10% of the time, the particles are fired backwards.// This is used to introduce a bit of non-uniformity.  Gun_R and// Gun_OffR can be controled with the '3' and '6', and '/' and '*'// keys, respectively.  If set to zero, effects are removed.static void ourFireParticleGun(Particle *p, NNato *x){   float r;   int c;   int Dir = 1;   if (!p->Running) {      p->Running=1;      x->Parts_Running++;   }   if (p == x->Parts) {  // Root part.       ourVectInit(p->Color,1,1,0);                // Bright Yellow       ourVectInit(p->Pos,5.0,0,0);                // Location       ourVectInit(p->Vel,0,x->Gun_VY,-x->Gun_VX*0.95);  // Velocity       return;   }   // Regular particle.   ourVectInit(p->Pos,x->Gun_PX,x->Gun_PY,x->Gun_PZ);   r = x->Gun_R;// This creates a few a very unpredicatable trajectories.  It actually// works out to be much less than a full 10 percent, as many are eatten// or escape within a very short period of time.  Only a few enter a // stable orbit.    if (ran() > x->Gun_Off) r += x->Gun_OffR;    if (ran() > x->Gun_Back) Dir = -1;   ourVectInit(p->Vel,      (x->Gun_VX + r-alea(0.,2*r)) * Dir,      (x->Gun_VY + r-alea(0.,2*r)) * Dir,      (x->Gun_VZ + r-alea(0.,2*r)) * Dir);   c = (int)(alea(0.,5.) + 1.5); // Range of 1 to 6.   // The last set of numbers bias the colors to blue.  Red is nice too.   ourVectInit(p->Color,      (c & 0x01 ? 0.9 : 1.0) * 0.7,      (c & 0x02 ? 0.9 : 1.0) * 0.7,      (c & 0x04 ? 0.9 : 1.0) * 1.0      );}// ------// Calculates the next position based on the current velocity vector,// then calculates the new velocity vector based on the particle's // proximity to the black hole.//// We do the motion calculation before updating the velocity vector// (and calculating the acceleration-because-of-gravity vector) so // that our Vector Display option will be correct.  If we didn't do// this, the gravity vector would not point towards (0,0,0) when// we drew it, outside of this function.static void ourMoveParticle(Particle *p, NNato *x){   float dp2, dsx, dsy, dsz, G, d;   //  Used to randomly kill and re-create particles.   if (p != x->Parts)      if (ran() >  0.9998) {      ourFireParticleGun(p,x);      return;   }   // We're actually going to move this particle...   // We first move it based on the LAST iteration's    // calculation of the Velocity...   p->Pos[0] += p->Vel[0];   p->Pos[1] += p->Vel[1];   p->Pos[2] += p->Vel[2];   // ...and then proceed to calculate the force of gravity at the new    // position, and update our velocity vector.   dsx = p->Pos[0] * p->Pos[0];   dsy = p->Pos[1] * p->Pos[1];   dsz = p->Pos[2] * p->Pos[2];   // Calculate the square of the distance.   dp2 = dsx + dsy + dsz;   if (dp2) {      // May wish to scale dp2 (change 1.0); effects gravity gradiant.      G = x->Grav / (dp2 * 1.0);        d = sqrt(dp2);   }   // If the force of gravity is too strong, our algorithim breaks   // down and conservation of energy isn't maintained.  We consider    // this the event horizon, and recycle the particle.   if (G > EVENT_HORIZON_GRAV) {      ourFireParticleGun(p,x);      return;   }   if (dp2 > ESCAPE_HORIZON_SQR) {       // Particle escaped; lucky it.      ourFireParticleGun(p,x);      return;   }   // OK, this particle is staying in the system.  Calculate the    // vectors....   // We store the components of the force of gravity for    // our Vectors display.  Note the negative magnitude; the vector   // must point _from_ our particle _towards_ (0,0,0).   p->Grav[0] = - G * p->Pos[0] / d;   p->Grav[1] = - G * p->Pos[1] / d;   p->Grav[2] = - G * p->Pos[2] / d;   // Simply add the gravity vector to the current velocity vector.   p->Vel[0] += p->Grav[0];   p->Vel[1] += p->Grav[1];   p->Vel[2] += p->Grav[2];   if (p != x->Parts) {      // This handles orbit decay; not correctly, but well enough.      // (Decay should be a ratio to the vector length, applied to each       // vector component here, rather than each component being effected      // based on its individual size.  The effect is to circlurize the      // orbit, which we want anyway.)      p->Vel[0] -= p->Vel[0] / x->Decay_Factor;      p->Vel[1] -= p->Vel[1] / x->Decay_Factor;      p->Vel[2] -= p->Vel[2] / x->Decay_Factor;   }}// ------// Angle to Radian conversion.float ourA2R(float Angle){   return Angle * M_PI/180;}// ------// Calculates the observer's XYZ position from their Distance from // the origin, the angle and the height.static void ourCalcObs(NNato *x){  x->Obs[0]=x->Obs_Dist * sin(ourA2R(x->Obs_Angle));  x->Obs[1]=x->Obs_Height;  x->Obs[2]=x->Obs_Dist * cos(ourA2R(x->Obs_Angle));}// ------// Draws the X, Y, and Z axis lines.void ourRenderAxis(void){   glBegin(GL_LINES);   glColor4f(0.5,0.5,0.0,1.0);  // Mid-level yellow.   // Three primary axis lines.   glVertex3f(100,0,0);   glVertex3f(-100,0,0);   glVertex3f(0,100,0);   glVertex3f(0,-100,0);   glVertex3f(0,0,100);   glVertex3f(0,0,-100);   glColor4f(0.25,0.25,0.0,1.0);  // Low-level yellow.   // Two pairs of secondary lines for X and Z axis.   glVertex3f(100,1,0);   glVertex3f(-100,1,0);   glVertex3f(100,-1,0);   glVertex3f(-100,-1,0);   glVertex3f(0,1,100);   glVertex3f(0,1,-100);   glVertex3f(0,-1,100);   glVertex3f(0,-1,-100);   glColor4f(0.0,0.5,0.0,1.0); // Mid-level green.   // Lable the X axis.   glVertex3f(1.0,0.9,0);   glVertex3f(1.1,0.8,0);   glVertex3f(1.1,0.9,0);   glVertex3f(1.0,0.8,0);   // And the Z.   glVertex3f(0,0.9,1.0);   glVertex3f(0,0.9,1.1);   glVertex3f(0,0.9,1.1);   glVertex3f(0,0.8,1.0);   glVertex3f(0,0.8,1.0);   glVertex3f(0,0.8,1.1);   glEnd();}// ------// Draws the Gravity and Velocity Vectors for each active particle.void ourRenderVectors(NNato *x){   int i;   GLfloat red = x->red; GLfloat green = x->green;GLfloat blue=x->blue;GLfloat alpha = x->alpha;   glBegin(GL_LINES);   for (i=0; i < x->Parts_Num; i++) {      if (!x->Parts[i].Running) continue;      // Draw the velocity vector as green.//      glColor4f(0.0,1.0,0.0,x->Parts_Brightness + .5);      glColor4f(red, green, blue, alpha);      glVertex3f(         x->Parts[i].Pos[0],         x->Parts[i].Pos[1],         x->Parts[i].Pos[2]         );      glVertex3f(         x->Parts[i].Pos[0] + x->Parts[i].Vel[0] ,         x->Parts[i].Pos[1] + x->Parts[i].Vel[1] ,         x->Parts[i].Pos[2] + x->Parts[i].Vel[2]          );      // Draw the gravity vector as red.//      glColor4f(1.0,0.0,0.0,x->Parts_Brightness + .5);      glColor4f(1.0-red,1.0 - green,1.0 - blue, 1.0 -alpha);      glVertex3f(         x->Parts[i].Pos[0],         x->Parts[i].Pos[1],         x->Parts[i].Pos[2]         );      glVertex3f(         x->Parts[i].Pos[0] + x->Parts[i].Grav[0] ,         x->Parts[i].Pos[1] + x->Parts[i].Grav[1] ,         x->Parts[i].Pos[2] + x->Parts[i].Grav[2]       );    }    glEnd();}// ------// Draws the heads-up-display.void ourRenderHeadsUp(NNato *x){   char buf[80];   glLoadIdentity();     // We need to change the projection matrix for the text rendering.   glMatrixMode(GL_PROJECTION);   // But we like our current view too; so we save it here.   glPushMatrix();   // Now we set up a new projection for the text.   glLoadIdentity();   glOrtho(0,320,0, 240,-1.0,1.0);	//was width&height   // No need for textured text.   glDisable(GL_TEXTURE_2D);   // We don't want depth-testing either.   glDisable(GL_DEPTH_TEST);   // Draw various variables for the user.   glColor3f(1.0,1.0,0.0);   sprintf(buf,"Parts: %d / %d  Bright:%.2f",       x->Parts_Running, x->Parts_Allocated, x->Parts_Brightness);   glRasterPos2i(10,48);   ourPrintString(GLUT_BITMAP_HELVETICA_12,buf);   sprintf(buf,"Rnd - Normal:%.3f Extreme:%.3f",      x->Gun_R, x->Gun_OffR);   glRasterPos2i(10,6);   ourPrintString(GLUT_BITMAP_HELVETICA_12,buf);   if (x->Gun_Control)      glColor3f(1.0,1.0,0.0);   else      glColor3f(0.5,1.0,0.0);   sprintf(buf,"GunP: (%.3f,%.3f,%.3f)", x->Gun_PX, x->Gun_PY, x->Gun_PZ);   glRasterPos2i(10,34);   ourPrintString(GLUT_BITMAP_HELVETICA_12,buf);   if (!x->Gun_Control)      glColor3f(1.0,1.0,0.0);   else      glColor3f(0.5,1.0,0.0);   sprintf(buf,"GunV: (%.3f,%.3f,%.3f)",      x->Gun_VX, x->Gun_VY, x->Gun_VZ);   glRasterPos2i(10,20);   ourPrintString(GLUT_BITMAP_HELVETICA_12,buf);   // Now we want to render the calulated FPS at the top.     // To ease, simply translate up.  Note we're working in screen   // pixels in this projection.     glTranslatef(6.0f,240 - 14,0.0f);	//was window height   glColor4f(0.9,0.2,0.2,.95);//   sprintf(buf,"FPS: %f F: %2d", FrameRate, FrameCount);//   glRasterPos2i(6,0);//  ourPrintString(GLUT_BITMAP_HELVETICA_12,buf);   // Lets also show the current position of the Root Particle   sprintf(buf,"RootP: ( %-.4f, %-.4f, %-.4f)",       x->Parts->Pos[0], x->Parts->Pos[1],x->Parts->Pos[2]);   glRasterPos2i(6,-16);   ourPrintString(GLUT_BITMAP_HELVETICA_12,buf);   // And the Root Particle's velocity.   sprintf(buf,"RootV: ( %-.4f, %-.4f, %-.4f)",       x->Parts->Vel[0], x->Parts->Vel[1],x->Parts->Vel[2]);   glRasterPos2i(6,-32);   ourPrintString(GLUT_BITMAP_HELVETICA_12,buf);   // And the Root Particle's velocity.   sprintf(buf,"Grav: ( %-.4f)",       x->Grav);   glRasterPos2i(6,-48);   ourPrintString(GLUT_BITMAP_HELVETICA_12,buf);   // Done with this special projection matrix.  Throw it away.   glPopMatrix();}// ------// Does everything needed before losing control to the main// OpenGL event loopvoid ourInit(NNato *x){//   ourBuildTextures();   ourBuildStarfield(x, 500);   glEnable(GL_BLEND);   glDisable(GL_ALPHA_TEST);   // Enable flat shading -- no need for smooth.   glShadeModel(GL_FLAT);   // Blending mode used for fire, lit gas, etc.   glBlendFunc(GL_SRC_ALPHA,GL_ONE);   // Calculate the non-on-orbit observer's position.   ourCalcObs(x);   // Load up the correct perspective matrix; using a callback directly.//   cbResizeScene(Width, Height);   if (!(x->Black_Hole = gluNewQuadric()))      exit;   // Allocate our first block of particles.   ourAllocParticles(x,x->Parts_Num);			// x and nr partcls   // Fire off the first (Root) Particle.   ourFireParticleGun(x->Parts, x);				// Parts is our particle struct}void nnato_glfun(n2glatom glatom)				//{    NNato *x = (NNato *)n2getglatomobj(glatom);   	Particle *p; //our particle object    int i;             if (!x->on) return;   // For the first few objects, we want full depth-buffer testing.//   glEnable(GL_DEPTH_TEST);//   glDepthMask(GL_TRUE);/*   // Clear the screen.   glClearColor(0.00,0.00,0.00,1.0);   glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);*/   // Ensure we're working with the model matrix.   glMatrixMode(GL_MODELVIEW);   // Reset to 0,0,0; no rotation, no scaling.   glLoadIdentity();   // Are we on-orbit, or wandering around?   if (x->On_Orbit) {      gluLookAt(x->Parts->Pos[0],x->Parts->Pos[1],x->Parts->Pos[2],         0.0,0.0,0.0,         0.0,1.0,0.0);   } else {      gluLookAt(x->Obs[0],x->Obs[1],x->Obs[2],         0.0,0.0,0.0,         0.0,1.0,0.0);   }   // No texturing.   glDisable(GL_TEXTURE_2D);   // Black holes are BLACK!   glColor4f(x->red, x->green, x->blue, x->alpha);   gluSphere(x->Black_Hole,x->srad,x->sx,x->sy);   if (x->Draw_Stars)      glCallList(STAR_FIELD);   if (x->Draw_Vectors)      ourRenderVectors(x);   if (x->Draw_Axis)      ourRenderAxis();   if (x->Heads_Up)      ourRenderHeadsUp(x);             // We don't want any of the particles to obscure any others, but   // we DO want the black hole to block any particles behind it.   // Note that GL_DEPTH_TEST is still enabled.   glDepthMask(GL_FALSE);   // Enable the dot texture.  "Oh no!  Not THE DOT!"   if (x->texture)      glEnable(GL_TEXTURE_2D);   // Iterate through the array of particles, drawing all that are   // active.  For those that aren't active, 0.03% of the time, we    // introduce them into the system.   for(i=0; i < x->Parts_Num; i++) {      p = &x->Parts[i];      if (!p->Running) {         if (x->Move_Enable && ran() > 0.97)//x->firetresh)            ourFireParticleGun(p,x);      } else {               // Set the part's color.         glColor4f(p->Color[0],p->Color[1],p->Color[2],            x->Parts_Brightness);         // Draw two intersecting quads, along XY and ZY axis.         glBegin(GL_QUADS);         glTexCoord2f(0.0,0.0);         glVertex3f(p->Pos[0]-.00,p->Pos[1]-.10,p->Pos[2]-.10);         glTexCoord2f(1.0,0.0);         glVertex3f(p->Pos[0]-.00,p->Pos[1]+.10,p->Pos[2]-.10);         glTexCoord2f(1.0,1.0);         glVertex3f(p->Pos[0]-.00,p->Pos[1]+.10,p->Pos[2]+.10);         glTexCoord2f(0.0,1.0);         glVertex3f(p->Pos[0]-.00,p->Pos[1]-.10,p->Pos[2]+.10);         glTexCoord2f(0.0,0.0);         glVertex3f(p->Pos[0]-.10,p->Pos[1]-.10,p->Pos[2]-.00);         glTexCoord2f(1.0,0.0);         glVertex3f(p->Pos[0]-.10,p->Pos[1]+.10,p->Pos[2]-.00);         glTexCoord2f(1.0,1.0);         glVertex3f(p->Pos[0]+.10,p->Pos[1]+.10,p->Pos[2]+.00);         glTexCoord2f(0.0,1.0);         glVertex3f(p->Pos[0]+.10,p->Pos[1]-.10,p->Pos[2]+.00);         glEnd();         if (x->Move_Enable)            ourMoveParticle(p,x);      }   }   // All done drawing.  Let's show it.//   glutSwapBuffers();   // This handles our single-step function.   if (x->Move_Step)      x->Move_Step = x->Move_Enable = 0;}/*   // All done drawing.  Let's show it.   glutSwapBuffers();   // This handles our single-step function.   if (x->Move_Step)      x->Move_Step = x->Move_Enable = 0;*/void nnato_glregister(NNato *x, void *klientz){    n2glregisterx(x,n2objtype,x->glout,klientz);  // bkom 01 klient ov gl alimentari data}			    