/*   Copyright (C) 2000 Nate Miller nkmiller@calpoly.edu   This program is free software; you can redistribute it and/or   modify it under the terms of the GNU General Public License   as published by the Free Software Foundation; either version 2   of the License, or (at your option) any later version.   This program is distributed in the hope that it will be useful,   but WITHOUT ANY WARRANTY; without even the implied warranty of   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   GNU General Public License for more details.   You should have received a copy of the GNU General Public License   along with this program; if not, write to the Free Software   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.   See gpl.txt for more information regarding the GNU General Public License.*/#include "tga.h"#include "land.h"/*=============land_t::land_t=============   Sets everything to a default value, don't trust the compiler to do this. */land_t::land_t(){   ndx = 0;   verts = 0;   tex = 0;   norms = 0;   stride = 1;   scale = 1;   tile = 1;}/*=============land_t::Reset=============   Resets everything.  */void land_t::Reset(void){   stride = 1;   scale = 1;   tile = 1;   delete [] ndx;   delete [] verts;   delete [] tex;   delete [] norms;   ndx = 0;   verts = 0;   tex = 0;   norms = 0;   img.Release();   img.Reset();}/*=============land_t::SetupArrays=============   This function allocates memory for all of the arrays that the class will usewhile generating the terrain and everything that comes with it.  Take note thatvertex normal memory is *NOT* allocated here.  This is handled in GetNormals(). */void land_t::SetupArrays(void){   numTris = (w - 1) * (w - 1) * 2; // 2 tris for each square   verts = new vec3_t[w * w];   ndx = new uint[numTris * 3];   tex = new vec2_t[w * w]; }/*=============land_t::BuildTerrain=============   This is the function that generates the terrain based on the heightmap.  Thefunction also generates texture coordinates for each vertex.  The gist of what goes on is that rather than making all of the verticies come one after theother to form a solid line of points, I spread them apart which then forms agrid of points.  The distance from one point to the other is 'stride' which isset by the user.  Texture coordinates are generated by first figuring out howmuch we need to advance in the texture for each subdivision we make.  Thatvalue is stored in 'hop'.  As we move through the heightmap the texture coordinate's 'u' and 'v' have 'hop' added to them.  Finally I setup my triangleindices so that I can use vertex arrays.  Setting up these indices justinvolves filling in the array with the correct values for the current triangle.  Thats about it, this is really simple and works well for the most part.      */void land_t::BuildTerrain(void){   int size = w - 1;   int apos, anpos;   int tri = 0;   int andx[4];   float u = 0, v = 0;   float x = 0;   float z = ((size / 2.0f) * stride);   float hop = tile / size;   byte *buffer = img.GetData();      // build the terrain, gather the texture coords and setup the indices   for (int r = 0; r < h; r++, z -= stride, v += hop)   {      x = -((size / 2.0f) * stride);       u = 0;      for (int c = 0; c < w; c++, x += stride, u += hop)      {         apos = (r * h) + c;         verts[apos].Set(x, buffer[apos] * scale, z);         tex[apos][0] = u;         tex[apos][1] = v;                  if (r < h - 1 && c < w - 1)         {            anpos = tri * 3;            andx[0] = (r * h) + c;            andx[1] = (r * h) + (c + 1);            andx[2] = ((r + 1) * h) + (c + 1);            andx[3] = ((r + 1) * h) + c;            ndx[anpos + 0] = andx[0];            ndx[anpos + 1] = andx[1];            ndx[anpos + 2] = andx[2];            tri++;            anpos = tri * 3;            ndx[anpos + 0] = andx[2];            ndx[anpos + 1] = andx[3];            ndx[anpos + 2] = andx[0];            tri++;         }           }   }}/*=============land_t::GetNormals=============   This beast of a function calculates vertex normals for the terrain.  I just lifted the code from my ASE loader and dropped it in here since the dataformats are similar.  If you have questions about vertex normals I wrote up a little article about them located here :http://nate.scuzzy.net/normals/normals.html  This function uses the faceindices from BuildTerrain() to do everything.  */void land_t::GetNormals(void){   vec3_t *fNorms = 0;   vec3_t *vNorms = 0;   vec3_t a, b, c, p, q;   vec3_t sum(0, 0, 0);   float *pt1 = 0, *pt2 = 0, *pt3 = 0;   unsigned int *pFace;   int cnt, pos;   int incident = 0;   int apos;   fNorms = new vec3_t[numTris];   vNorms = new vec3_t[w * w];   // find face normals for our model, used to find vert normals   for (cnt = 0; cnt < numTris; cnt++)   {      apos = cnt * 3;      pt1 = verts[ndx[apos + 0]];      pt2 = verts[ndx[apos + 1]];      pt3 = verts[ndx[apos + 2]];      a.Set(pt1[0], pt1[1], pt1[2]);      b.Set(pt2[0], pt2[1], pt2[2]);      c.Set(pt3[0], pt3[1], pt3[2]);      p = b - a;      q = c - a;      fNorms[cnt].Cross(p, q);      fNorms[cnt].Normalize();   }      // find vertex normals   for (cnt = 0; cnt < w * w; cnt++)   {      for(pos = 0; pos < numTris; pos++)      {         pFace = ndx + pos * 3;         if(pFace[0] == (unsigned int) cnt || pFace[1] == (unsigned int) cnt ||          pFace[2] == (unsigned int) cnt)         {            incident++;            sum += fNorms[pos];         }      }      vNorms[cnt] = sum / (float) incident;      vNorms[cnt].Normalize();      sum.Clear();      incident = 0;   }      delete [] fNorms;      norms = (vec3_t *) vNorms;}/*=============land_t::Load=============   This function will load up a terrain from a heightmap, a 8-bit targa, andwill generate vertices, texture coordinates, normals and face indices for theterrain.  If 'reload' is 1 then the function will "rebuild" the terrain so to speak.  You would do this if you changed 'stride', 'scale' or 'tile'.  */bool land_t::Load(char *name, bool reload){   if (!reload)   {      // misc error checks so we don't go boom      if (stride == 0)         return 0;      if (img.Load(name) != 1)         return 0;      if ((w = img.GetWidth()) != (h = img.GetHeight()) || (w == 1 && h == 1)       || img.GetBits() != 8)          {         img.Release();         return 0;      }   }   else   {      delete [] ndx;      delete [] verts;      delete [] tex;        delete [] norms;   }   SetupArrays();   BuildTerrain();   GetNormals(); // slow   return 1;}