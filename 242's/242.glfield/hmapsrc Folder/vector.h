/*   Copyright (C) 2000 Nate Miller nkmiller@calpoly.edu   This program is free software; you can redistribute it and/or   modify it under the terms of the GNU General Public License   as published by the Free Software Foundation; either version 2   of the License, or (at your option) any later version.   This program is distributed in the hope that it will be useful,   but WITHOUT ANY WARRANTY; without even the implied warranty of   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   GNU General Public License for more details.   You should have received a copy of the GNU General Public License   along with this program; if not, write to the Free Software   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.   See gpl.txt for more information regarding the GNU General Public License.*//*   Need to format this to fit on 80 cols, but its a pain*/#ifndef __VEC3T__#define __VEC3T__#include <math.h>// i doubt i need anymore than thistypedef float vec2_t[2];struct vec3_t{   vec3_t() {v[0] = v[1] = v[2] = 0;}   vec3_t(float px, float py, float pz) {v[0] = px; v[1] = py; v[2] = pz;}   vec3_t(vec3_t &pVec) {v[0] = pVec.v[0]; v[1] = pVec.v[1]; v[2] = pVec.v[2];}   vec3_t(float *pVec) {v[0] = pVec[0]; v[1] = pVec[1]; v[2] = pVec[2];}   vec3_t operator=(vec3_t &pVec)    {return vec3_t(v[0] = pVec.v[0], v[1] = pVec.v[1], v[2] = pVec.v[2]);}   vec3_t operator=(float *ptr)    {return vec3_t(v[0] = ptr[0], v[1] = ptr[1], v[2] = ptr[2]);}   int operator==(vec3_t &pVec)    {return (v[0] == pVec.v[0] && v[1] == pVec.v[1] && v[2] == pVec.v[2]);}   int operator==(float *pVec)    {return (v[0] == pVec[0] && v[1] == pVec[1] && v[2] == pVec[2]);}   inline int operator!=(vec3_t &pVec)    {return !(pVec == (*this));}   inline int operator!=(float *pVec)    {return !(pVec == (*this));}   vec3_t operator+=(vec3_t &pVec);     vec3_t operator-=(vec3_t &pVec);   vec3_t operator*=(vec3_t &pVec);   vec3_t operator*=(float val);     vec3_t operator/=(vec3_t &pVec);   vec3_t operator/=(float val);   vec3_t operator+(vec3_t &pVec)    {return vec3_t(v[0] + pVec.v[0], v[1] + pVec.v[1], v[2] + pVec.v[2]);}   vec3_t operator-(vec3_t &pVec)    {return vec3_t(v[0] - pVec.v[0], v[1] - pVec.v[1], v[2] - pVec.v[2]);}   vec3_t operator*(vec3_t &pVec)    {return vec3_t(v[0] * pVec.v[0], v[1] * pVec.v[1], v[2] * pVec.v[2]);}   vec3_t operator*(float val)    {return vec3_t(v[0] * val, v[1] * val, v[2] * val);}   friend vec3_t operator*(float val, vec3_t v)    {return vec3_t(v[0] * val, v[1] * val, v[2] * val);}   vec3_t operator/(vec3_t &pVec)      {return vec3_t(v[0] / pVec.v[0], v[1] / pVec.v[1], v[2] / pVec.v[2]);}   vec3_t operator/(float val)    {return vec3_t(v[0] / val, v[1] / val, v[2] / val);}   void Clear(void) {v[0] = v[1] = v[2] = 0;}   void Normalize(void);   float Length(void);   float Dot(vec3_t &pVec)    {return v[0] * pVec.v[0] + v[1] * pVec.v[1] + v[2] * pVec.v[2];}   void Cross(vec3_t &p, vec3_t &q);   void Set(float x, float y, float z) {v[0] = x; v[1] = y; v[2] = z;}      float X(void) {return v[0];}   float Y(void) {return v[1];}   float Z(void) {return v[2];}   void X(float nx) {v[0] = nx;}   void Y(float ny) {v[1] = ny;}   void Z(float nz) {v[2] = nz;}   const float &operator[](int ndx) const {return v[ndx];}   float &operator[](int ndx) {return v[ndx];}   operator float*(void) {return v;}   void Clamp(float min, float max);   void RotateX(float amnt);   void RotateY(float amnt);   void RotateZ(float amnt);     // temp   inline float GetDistance(vec3_t &dest);protected:   float v[3];};inline vec3_t vec3_t::operator+=(vec3_t &pVec){   vec3_t ret;   ret = *this = *this + pVec;   return ret;}inline vec3_t vec3_t::operator-=(vec3_t &pVec){   vec3_t ret;   ret = *this = *this - pVec;   return ret;}inline vec3_t vec3_t::operator*=(vec3_t &pVec){   vec3_t ret;   ret = *this = *this * pVec;   return ret;}inline vec3_t vec3_t::operator*=(float val){   vec3_t ret;   ret = *this = *this * val;   return ret;}inline vec3_t vec3_t::operator/=(vec3_t &pVec){   vec3_t ret;   ret = *this = *this / pVec;   return ret;}inline vec3_t vec3_t::operator/=(float val){   vec3_t ret;   ret = *this = *this / val;   return ret;}inline void vec3_t::Normalize(void) {	float length, len = 0;	length = Length();	if (length == 0)		return;	len = 1.0f / length;	v[0] *= len;	v[1] *= len;	v[2] *= len;}inline float vec3_t::Length(void) {   double length = (v[0] * v[0]) + (v[1] * v[1]) + (v[2] * v[2]);		return (float) sqrt(length);}inline void vec3_t::Cross(vec3_t &p, vec3_t &q){	v[0] = (p.v[1] * q.v[2]) - (p.v[2] * q.v[1]);	v[1] = (p.v[2] * q.v[0]) - (p.v[0] * q.v[2]);	v[2] = (p.v[0] * q.v[1]) - (p.v[1] * q.v[0]);}inline void vec3_t::Clamp(float min, float max){   if (v[0] > max || v[0] < min)      v[0] = 0;   if (v[1] > max || v[1] < min)      v[1] = 0;   if (v[2] > max || v[2] < min)      v[2] = 0;   }inline void vec3_t::RotateX(float amnt){  float s = MySin(amnt);  float c = MyCos(amnt);  float y = v[1];  float z = v[2];    v[1] = (y * c) - (z * s);  v[2] = (y * s) + (z * c);}inline void vec3_t::RotateY(float amnt){  float s = MySin(amnt);  float c = MyCos(amnt);  float x = v[0];  float z = v[2];    v[0] = (x * c) + (z * s);  v[2] = (z * c) - (x * s);}inline void vec3_t::RotateZ(float amnt){  float s = MySin(amnt);  float c = MyCos(amnt);  float x = v[0];  float y = v[1];    v[0] = (x * c) - (y * s);  v[1] = (y * c) + (x * s);}// testinline float vec3_t::GetDistance(vec3_t &dest){   float d1 = dest[0] - v[0];   float d2 = dest[1] - v[1];   float d3 = dest[2] - v[2];      return (float) sqrt((d1 * d1) + (d2 * d2) + (d3 * d3));}// vec4_t // this is all temp, if it breaks and/or blows up thats whystruct vec4_t{   vec4_t() {v[0] = v[1] = v[2] = v[3] = 0;}   vec4_t(float px, float py, float pz, float pw) {v[0] = px; v[1] = py; v[2] = pz; v[3] = pw;}   vec4_t(vec4_t &pVec) {v[0] = pVec.v[0]; v[1] = pVec.v[1]; v[2] = pVec.v[2]; v[3] = pVec.v[3];}   vec4_t(float *pVec) {v[0] = pVec[0]; v[1] = pVec[1]; v[2] = pVec[2]; v[3] = pVec[3];}   vec4_t operator=(vec4_t &pVec)    {return vec4_t(v[0] = pVec.v[0], v[1] = pVec.v[1], v[2] = pVec.v[2], v[3] = pVec.v[3]);}   vec4_t operator=(float *ptr)    {return vec4_t(v[0] = ptr[0], v[1] = ptr[1], v[2] = ptr[2], v[3] = ptr[3]);}   int operator==(vec4_t &pVec)    {return (v[0] == pVec.v[0] && v[1] == pVec.v[1] && v[2] == pVec.v[2] && v[3] == pVec.v[3]);}   int operator==(float *pVec)    {return (v[0] == pVec[0] && v[1] == pVec[1] && v[2] == pVec[2] && v[3] == pVec[3]);}   inline int operator!=(vec4_t &pVec)    {return !(pVec == (*this));}   inline int operator!=(float *pVec)    {return !(pVec == (*this));}   vec4_t operator+=(vec4_t &pVec);     vec4_t operator-=(vec4_t &pVec);   vec4_t operator*=(vec4_t &pVec);   vec4_t operator*=(float val);     vec4_t operator/=(vec4_t &pVec);   vec4_t operator/=(float val);   vec4_t operator+(vec4_t &pVec)    {return vec4_t(v[0] + pVec.v[0], v[1] + pVec.v[1], v[2] + pVec.v[2], v[3] + pVec.v[3]);}   vec4_t operator-(vec4_t &pVec)    {return vec4_t(v[0] - pVec.v[0], v[1] - pVec.v[1], v[2] - pVec.v[2], v[3] - pVec.v[3]);}   vec4_t operator*(vec4_t &pVec)    {return vec4_t(v[0] * pVec.v[0], v[1] * pVec.v[1], v[2] * pVec.v[2], v[3] * pVec.v[3]);}   vec4_t operator*(float val)    {return vec4_t(v[0] * val, v[1] * val, v[2] * val, v[3] * val);}   vec4_t operator/(vec4_t &pVec)      {return vec4_t(v[0] / pVec.v[0], v[1] / pVec.v[1], v[2] / pVec.v[2], v[3] / pVec.v[3]);}   vec4_t operator/(float val)    {return vec4_t(v[0] / val, v[1] / val, v[2] / val, v[3] / val);}   void Clear(void) {v[0] = v[1] = v[2] = v[3] = 0;}   void Set(float x, float y, float z, float w)    {v[0] = x; v[1] = y; v[2] = z; v[3] = w;}      float X(void) {return v[0];}   float Y(void) {return v[1];}   float Z(void) {return v[2];}   float W(void) {return v[3];}   void X(float nx) {v[0] = nx;}   void Y(float ny) {v[1] = ny;}   void Z(float nz) {v[2] = nz;}   void W(float nw) {v[3] = nw;}   const float &operator[](int ndx) const {return v[ndx];}   float &operator[](int ndx) {return v[ndx];}   operator float*(void) {return v;}protected:   float v[4];};inline vec4_t vec4_t::operator+=(vec4_t &pVec){   vec4_t ret;   ret = *this = *this + pVec;   return ret;}inline vec4_t vec4_t::operator-=(vec4_t &pVec){   vec4_t ret;   ret = *this = *this - pVec;   return ret;}inline vec4_t vec4_t::operator*=(vec4_t &pVec){   vec4_t ret;   ret = *this = *this * pVec;   return ret;}inline vec4_t vec4_t::operator*=(float val){   vec4_t ret;   ret = *this = *this * val;   return ret;}inline vec4_t vec4_t::operator/=(vec4_t &pVec){   vec4_t ret;   ret = *this = *this / pVec;   return ret;}inline vec4_t vec4_t::operator/=(float val){   vec4_t ret;   ret = *this = *this / val;   return ret;}#endif