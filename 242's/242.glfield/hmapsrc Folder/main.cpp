/*=============OpenGL Heightmap DemoAuthor : Nate 'm|d' MillerDate   : 07/01/00Email  : nkmiller@calpoly.eduWeb    : http://nate.scuzzy.net=============   Here is a simple OpenGL Heightmap demo.  It is nothing amazing, but itshould help some people.  The meat of the demo is in land.cpp and land.h.  Itried to comment land.cpp and land,h as much as I could, most of the stuff isself explanatory.  The land_t class generates the points for the terrain, setsup triangle indices, generates texture coordinates and calculates vertexnormals.  With the demo being so simple there are bound to be problems with it,one being that too many triangles are drawn per frame.  If you up the maptexture size to 128x128 or 256x256 performance is terrible, especially on myold TNT.  This demo draws all of the triangles no matter what, even if no partof the landscape is visible.  I am no expert on outdoor landscape type engines,but ROAM seems to be the current craze in terrain LOD.  So if you want to speedthe demo up I suggest taking a look at ROAM.  Other neat additions to this demowould be the ability to walk around on the terrain or be able to deform it insome way.     A note about the heightmaps...The code only supports heightmaps that arehave the same width and height, taking any dimension heigtmap wouldn't be muchwork to do though.     Don't forget to link to opengl32.lib glu32.lib and glut32.lib.  You couldalso try pasting the following before the first #include and see if everythingwill link : #pragma comment(lib, "opengl32.lib")#pragma comment(lib, "glu32.lib")#pragma comment(lib, "glut32.lib")   Using those #pragma's works on MSVC, but I am unsure about other compilers so I left it out.  */ #include "text.h"#include "land.h"#define __GLUTMOUSE__ // !!important#include "mouse.h"#include <gl/glut.h>int winW = 640;int winH = 480;const char *appName = "OpenGL Heightmap Demo";vec3_t eye(0, 25, 0);vec3_t rot(0, 0, 0);land_t land; // the terrain classmouse_t mouse; text_t text; uint id; // land texture idbool ani = 0;     // animate?bool wire = 0;    // wireframe?bool texture = 1; // textures?bool light = 1;   // lighting?bool glcull = 0;  // gl culling?bool help = 0;    // help?/*   This is just a utility function I have so I don't need to cut and pastestuff all over.  When its called all modes are set based on their currentvalues.  This is really slow, but for our needs its fine.  */void SetRenderModes(void){   if (wire)      glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);   else      glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);      if (texture)      glEnable(GL_TEXTURE_2D);   else      glDisable(GL_TEXTURE_2D);   if (light)      glEnable(GL_LIGHTING);   else      glDisable(GL_LIGHTING);      if (glcull)   {      glEnable(GL_CULL_FACE);      glCullFace(GL_BACK);   }   else      glDisable(GL_CULL_FACE);}void DrawHelp(void){   int y = winH - 10;   int fsize = 14;   text.Size(fsize);   text.Draw(20, y -= fsize, "\\c(64 128 128)Keyboard Usage");   text.Draw(20, y -= fsize, "Q - Quits");   text.Draw(20, y -= fsize, "A - Animate        - \\c(255 255 0)%s",    ani ? "on" : "off");   text.Draw(20, y -= fsize, "T - Texture        - \\c(255 255 0)%s",    texture ? "on" : "off");   text.Draw(20, y -= fsize, "W - Wireframe      - \\c(255 255 0)%s",    wire ? "on" : "off");   text.Draw(20, y -= fsize, "L - Lighting       - \\c(255 255 0)%s",    light ? "on" : "off");   text.Draw(20, y -= fsize, "C - OpenGL culling - \\c(255 255 0)%s",    glcull ? "on" : "off");   text.Draw(20, y -= fsize, "H - This screen");      text.Draw(20, y -= (3 * fsize), "\\c(64 128 128)Mouse Usage");   text.Draw(20, y -= fsize, "Left Button  - Rotates");   text.Draw(20, y -= fsize, "Right Button - Rotates");   text.Draw(20, y -= fsize, "Both Buttons - Zoom In/Out");}void glutDisplay(void){   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);   glMatrixMode(GL_MODELVIEW);   glLoadIdentity();   glTranslatef(-eye[0], -eye[1], -eye[2]);   glRotatef(rot[0], 1.0f, 0.0f, 0.0f);   glRotatef(rot[1], 0.0f, 1.0f, 0.0f);   glRotatef(rot[2], 0.0f, 0.0f, 1.0f);   // draw the terrain, simple isn't it?   glBindTexture(GL_TEXTURE_2D, id);   glVertexPointer(3, GL_FLOAT, 0, land.GetVerts());    glTexCoordPointer(2, GL_FLOAT, 0, land.GetTexCoords());   glNormalPointer(GL_FLOAT, 0, land.GetVertNorms());   glDrawElements(GL_TRIANGLES, 3 * land.GetNumTris(), GL_UNSIGNED_INT,    land.GetTriIndex());   if (help)      DrawHelp();   glutSwapBuffers();}void glutResize(int w, int h){	   if (!h)      return;   winW = w;   winH = h;   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);   glViewport(0, 0, winW, winH);      glMatrixMode(GL_PROJECTION);   glLoadIdentity();   gluPerspective(90, (double) winW / winH, 1, 4096);   glutPostRedisplay();}void glutKeyboard(unsigned char key, int x, int y){   switch (key)   {      case 27:      case 'q':      case 'Q':         exit(1);      break;      case 'a':      case 'A':         ani = !ani;      break;      case 't':      case 'T':         texture = !texture;         SetRenderModes();      break;      case 'w':      case 'W':         wire = !wire;         SetRenderModes();      break;      case 'l':      case 'L':         light = !light;         SetRenderModes();      break;      case 'c':      case 'C':         glcull = !glcull;         SetRenderModes();      break;      case 'h':      case 'H':         help = !help;      break;   }   glutPostRedisplay();}void glutMouse(int button, int state, int x, int y){   mouse.SetState(button, state);   mouse.SetNewPos(x, y);}void glutMotion(int x, int y){   mouse.SetOldPos(mouse.GetX(), mouse.GetY());   mouse.SetNewPos(x, y);   if (mouse.IsLeft() && mouse.IsRight())      eye[2] += ((float) mouse.GetDiffY() / 2);   else if (mouse.IsLeft())      rot[0] += ((float) mouse.GetDiffY() / 2);   else if (mouse.IsRight())      rot[1] += ((float) mouse.GetDiffX() / 2);   glutPostRedisplay();}void glutIdle(void){   if (ani)   {      rot += vec3_t(0.0, 1.5, 0.0);      rot.Clamp(-360, 360);         glutPostRedisplay();   }}void glInit (void){   printf("Hit H for help...\n");   glClearColor(0.0f, 0.0f, 0.0f, 1.0f);   glEnable(GL_DEPTH_TEST);   glEnableClientState(GL_VERTEX_ARRAY);   glEnableClientState(GL_TEXTURE_COORD_ARRAY);   glEnableClientState(GL_NORMAL_ARRAY);   glEnable(GL_LIGHT0);   glLightfv(GL_LIGHT0, GL_POSITION, vec3_t(0, 500, 50));      SetRenderModes();    // setup and load the terrain   land.SetStride(10);   // how much to move between verts   land.SetTile(4);      // how many times to tile the texture   land.SetScale(1.1f);  // how much to scale heightmap values   land.Load("map.tga"); // load the heightmap   // load the terrain texture   glTga_t img;    img.GenId(1, &id);   img.SetMipMap(1);   img.Load("texture.tga", id);        img.Upload(1);   // load the font texture   text.Load("font.tga");   // place the viewer, sucks though   eye[2] = (((float) (land.GetWidth() - 1) / 2) * land.GetStride()) +    (land.GetStride() * 3);}void main (void){   glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_DEPTH);   glutInitWindowSize(winW, winH);   glutCreateWindow(appName);   glutDisplayFunc(glutDisplay);   glutReshapeFunc(glutResize);   glutKeyboardFunc(glutKeyboard);   glutMouseFunc(glutMouse);   glutMotionFunc(glutMotion);   glutIdleFunc(glutIdle);   glInit ();   glutMainLoop();}