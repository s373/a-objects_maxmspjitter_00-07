//////////////////   242.auh   \ probal cause for alteration//		 image distribution//		a image distribution//	      a ¿ö image distribution////								09/03/2001 / s//								12/03//	3 channel image distribution////		//   cauchy.  A * tan((rnd-.5)*pi)#include "Movies.h"#include "ext_common.h"#include "ext.h"#include "ext_user.h"#include <math.h>#include <stdlib.h>#include "n2.basicstrings.c"#include "n2.0000.h"     // nato.inkludes//object data structuretypedef struct zttz {	Object   n_ob;     // required max 	void     *n2hdr;   // required nato - position = important _ must b 2nd		void             *dataout;          // n2data outlet	n2imgptr         gvelt;             // img buffer		double		rlow, rhigh, ra, rb,rsigsqr, rmu;		double		glow, ghigh, ga, gb,gsigsqr, gmu;			double		blow, bhigh, ba, bb,bsigsqr, bmu;	long			divx, divy;	//    Boolean          mode;    Boolean          on,bypass,freeze,think,quarrel;  // nato.objstate flagz       } NNato;// prototypesvoid *nnato_new(double low, double high, double a, double b)		;			//argumentsvoid nnato_assist(NNato *x, void *b, long msg, long nr, char *s);void nnato_info(NNato *x, void *p, void *b);void nnato_free(NNato *x);void nnato_processimage(NNato *x, n2atom *data);void nnato_processimage2(NNato *x, n2atom *data);void nnato_processimage3(NNato *x, n2atom *data);void nnato_processimage4(NNato *x, n2atom *data);void nnato_processimage5(NNato *x, n2atom *data);void nnato_processimage6(NNato *x, n2atom *data);void nnato_processimage7(NNato *x, n2atom *data);void nnato_processimage8(NNato *x, n2atom *data);void nnato_on(NNato *x, long flag);void nnato_bypass(NNato *x, long flag);void nnato_freeze(NNato *x, long flag);void nnato_think(NNato *x, short val);void nnato_quarrel(NNato *x, short val);void nnato_bang(NNato *x);void nnato_int(NNato *x, long n);   void nnato_rlow(NNato *x, double val);void nnato_rhigh(NNato *x, double val);void nnato_ra(NNato *x, double val);void nnato_rb(NNato *x, double val);void nnato_rmu(NNato *x, double val);void nnato_rsigsqr(NNato *x, double val);void nnato_glow(NNato *x, double val);void nnato_ghigh(NNato *x, double val);void nnato_ga(NNato *x, double val);void nnato_gb(NNato *x, double val);void nnato_gmu(NNato *x, double val);void nnato_gsigsqr(NNato *x, double val);void nnato_blow(NNato *x, double val);void nnato_bhigh(NNato *x, double val);void nnato_ba(NNato *x, double val);void nnato_bb(NNato *x, double val);void nnato_bmu(NNato *x, double val);void nnato_bsigsqr(NNato *x, double val);void nnato_divx(NNato *x, long val);void nnato_divy(NNato *x, long val);//void nnato_offset(NNato *x, long val);void nnato_variant(NNato *x, short variant);double map_r(NNato *x);double map_g(NNato *x);double map_b(NNato *x);double map_beta(double low, double high, double a, double b, double mu, double sigsqr) ;double beta_value(double a, double b);double non_zero_random(void);double ran(void);double alea(double min, double max);double mapvalue(double x, double a, double b, double c, double d);void     *nnato_class;main(void){	setup(&nnato_class, nnato_new, (method)nnato_free, (short)sizeof(NNato), 0L, 	      A_DEFFLOAT,A_DEFFLOAT,A_DEFFLOAT,A_DEFFLOAT,0);    n2objaddimagecmd();    n2addstatecmd((method)nnato_int,(method)nnato_bang,                  (method)nnato_on,(method)nnato_freeze,(method)nnato_bypass,                  (method)nnato_think,(method)nnato_quarrel,(method)nnato_variant,0); 	addmess((method)nnato_assist,	                   "assist",    	A_CANT,0); 	addmess((method)nnato_info,	                       "info",		    A_CANT,0);    addmess((method)nnato_rlow,                    "rlow",           A_DEFFLOAT,0);				//mensagens    addmess((method)nnato_rhigh,                  "rhigh",         A_DEFFLOAT,0);    addmess((method)nnato_ra,                   "ra",          A_DEFFLOAT,0);     addmess((method)nnato_rb,                   "rb",          A_DEFFLOAT,0);    addmess((method)nnato_rmu,                   "rmu",          A_DEFFLOAT,0);     addmess((method)nnato_rsigsqr,                   "rsigsqr",          A_DEFFLOAT,0);    addmess((method)nnato_glow,                    "glow",           A_DEFFLOAT,0);				//mensagens    addmess((method)nnato_ghigh,                  "ghigh",         A_DEFFLOAT,0);    addmess((method)nnato_ga,                   "ga",          A_DEFFLOAT,0);     addmess((method)nnato_gb,                   "gb",          A_DEFFLOAT,0);    addmess((method)nnato_gmu,                   "gmu",          A_DEFFLOAT,0);     addmess((method)nnato_gsigsqr,                   "gsigsqr",          A_DEFFLOAT,0);    addmess((method)nnato_blow,                    "blow",           A_DEFFLOAT,0);				//mensagens    addmess((method)nnato_bhigh,                  "bhigh",         A_DEFFLOAT,0);    addmess((method)nnato_ba,                   "ba",          A_DEFFLOAT,0);     addmess((method)nnato_bb,                   "bb",          A_DEFFLOAT,0);    addmess((method)nnato_bmu,                   "bmu",          A_DEFFLOAT,0);     addmess((method)nnato_bsigsqr,                   "bsigsqr",          A_DEFFLOAT,0);           addmess((method)nnato_divx,                   "divx",          A_DEFLONG,0);     addmess((method)nnato_divy,                   "divy",          A_DEFLONG,0);//      addmess((method)nnato_offset,                   "offset",          A_DEFLONG,0); //   n2reklama();    n2addfklass("242.auh");    post("");    post("242.auh         -                         -- -  2001 - sier ; ");     post("");}void nnato_assist(NNato *x, void *b, long msg, long nr, char *s){	if (msg == 1)      // inlet			sprintf(s, "nato.imag   .var%ld", x->divx);    else       {	   if (msg == 2)   // outlet	      if (nr == 0)	      	if  (!x->quarrel)			      	sprintf(s, "no quarrel & high  %ld",x->divx);		        else  sprintf(s, " quarrelling & & high  %ld",x->rhigh);       }}void nnato_info(NNato *x, void *p, void *b){      n2info();}void *nnato_new(double low, double high, double a, double b){	NNato      *x;    short      err;    		x = (NNato *)newobject(nnato_class);    n2addoutlet(x,&x->dataout);        if (err = n2objinit(x))       { post("242.cauchy  :  n2initobjekt err = %ld",err); return;}            if ((err = n2inewimage(&x->gvelt,n2idefwidth,n2idefheight)))       { post("242.cauchy  :  n2inewimage err = %ld",err); goto ikk;}      n2objsetimagefun(x,(method)nnato_processimage); // double mu, sigsqr; x->rlow = low;  x->rhigh = high;		// limits for beta distribution x->ra = a;  x->rb = b;			// and corners for the dist. x->rmu = 0;  x->rsigsqr = 1;			// and corners for the dist. x->glow = low;  x->ghigh = high;		// limits for beta distribution x->ga = a;  x->gb = b;			// and corners for the dist. x->gmu = 0;  x->gsigsqr = 1;			// and corners for the dist. x->blow = low;  x->bhigh = high;		// limits for beta distribution x->ba = a;  x->bb = b;			// and corners for the dist. x->bmu = 0;  x->bsigsqr = 1;			// and corners for the dist.    	x->on = true; 	x->bypass = x->freeze = x->think = x->quarrel = false;           return (x);ikk:	nnato_free(x);}void nnato_free(NNato *x){    if (x->gvelt) { n2idisposeimage(x->gvelt); x->gvelt = 0;}    n2objfree(x);}void nnato_on(NNato *x, long flag){        x->on = flag;}    void nnato_bypass(NNato *x, long flag){        x->bypass = flag;}      void nnato_freeze(NNato *x, long flag){        x->freeze = flag;} void nnato_int(NNato *x, long n)    {								       n2defintstatefun(x,n);}void nnato_bang(NNato *x){   n2registerimage(x,n2objtype,x->dataout,0,x->gvelt);			// &what!?          ,&data,}void nnato_rlow(NNato *x, double val){        x->rlow=val;}void nnato_rhigh(NNato *x, double val){        x->rhigh=val;}void nnato_ra(NNato *x, double val){        if (x->ra <= 0. ) x->ra= 0.01001;				//crashing if not constranned        else x->ra=val;}									//this is not constrainnigvoid nnato_rb(NNato *x, double val){        if (x->rb <= 0. ) x->rb= 0.01001;        else x->rb=val;}void nnato_rmu(NNato *x, double val){        x->rmu=val;}void nnato_rsigsqr(NNato *x, double val){        x->rsigsqr=val;}void nnato_glow(NNato *x, double val){        x->glow=val;}void nnato_ghigh(NNato *x, double val){        x->ghigh=val;}void nnato_ga(NNato *x, double val){        if (x->ga <= 0. ) x->ga= 0.01001;				//crashing if not constranned        else x->ga=val;}									//this is not constrainnigvoid nnato_gb(NNato *x, double val){        if (x->gb <= 0. ) x->gb= 0.01001;        else x->gb=val;}void nnato_gmu(NNato *x, double val){        x->gmu=val;}void nnato_gsigsqr(NNato *x, double val){        x->gsigsqr=val;}void nnato_blow(NNato *x, double val){        x->blow=val;}void nnato_bhigh(NNato *x, double val){        x->bhigh=val;}void nnato_ba(NNato *x, double val){        if (x->ba <= 0. ) x->ba= 0.01001;				//crashing if not constranned        else x->ba=val;}									//this is not constrainnigvoid nnato_bb(NNato *x, double val){        if (x->bb <= 0. ) x->bb= 0.01001;        else x->bb=val;}void nnato_bmu(NNato *x, double val){        x->bmu=val;}void nnato_bsigsqr(NNato *x, double val){        x->bsigsqr=val;}void nnato_divx(NNato *x, long val){        x->divx=val;}void nnato_divy(NNato *x, long val){        x->divy=val;}double map_r(NNato *x){	double rlow, rhigh, ra , rb, rmu, rsigsqr;	rlow=x->rlow;rhigh=x->rhigh;ra=x->ra;rb=x->rb;rmu=x->rmu;rsigsqr=x->rsigsqr;	return(map_beta(rlow, rhigh, ra, rb, rmu, rsigsqr));	}double map_g(NNato *x){	double glow, ghigh, ga , gb, gmu, gsigsqr;	glow=x->glow;ghigh=x->ghigh;ga=x->ga;gb=x->gb;gmu=x->gmu;gsigsqr=x->gsigsqr;	return(map_beta(glow,ghigh, ga, gb, gmu, gsigsqr));	}double map_b(NNato *x){	double blow, bhigh, ba , bb, bmu, bsigsqr;	blow=x->blow;bhigh=x->bhigh;ba=x->ba;bb=x->bb;bmu=x->bmu;bsigsqr=x->bsigsqr;	return(map_beta(blow, bhigh, ba, bb, bmu, bsigsqr));	}	double map_beta(double low, double high, double a, double b, double mu, double sigsqr) 			//			cv  paul.d  randbeta.c{																		//     variated by sier.	return(mapvalue(beta_value(a, b), mu, sigsqr,low, high));}// // beta distribution algorithm derived from Dodge's FORTRAN example, some of // the same variable names are used a and b should be doubles 0-1 // value returned between 0 and 1 //double beta_value(double a, double b){		double y1, y2, sum, ainv, binv;		ainv = 1.0/a;	binv = 1.0/b;	do 	{	 	y1 = pow(non_zero_random(), ainv);	 	y2 = pow(non_zero_random(), binv);	 	sum = y1+y2;	}	while(sum  > 1.0);		return(y1 / sum);}// // returns a non-zero random number between 0 and 1 // double non_zero_random(void){	double value;	do 	{		value = ran();	}	   	while (value == 0.0);		return(value);}// // returns a random double between 0 and 1 //double ran(void){		return(alea(0.0, 1.0));}//// returns a random value as double between min and max value // ANSI says that RAND_MAX = 32767, pretty piss poor I say!//double alea(double min, double max){	if (max >= min)		return ((max-min)*((double)rand()/RAND_MAX) + min);	else		return ((min-max)*((double)rand()/RAND_MAX) + max);	}//// maps x in the range a-b to the range c-d  returns a double //	double mapvalue (double x, double a, double b, double c, double d) {		return((x - a) * (d-c)/(b-a) + c);}void nnato_variant(NNato *x, short variant){   if (!variant)       n2objsetimagefun(x,(method)nnato_processimage);    else if (variant == 1)       n2objsetimagefun(x,(method)nnato_processimage2);        else if (variant == 2)       n2objsetimagefun(x,(method)nnato_processimage3);          else if (variant == 3)       n2objsetimagefun(x,(method)nnato_processimage4);          else if (variant == 4)       n2objsetimagefun(x,(method)nnato_processimage5);              else if (variant == 5)       n2objsetimagefun(x,(method)nnato_processimage6);          else if (variant == 6)       n2objsetimagefun(x,(method)nnato_processimage7);          else if (variant == 7)       n2objsetimagefun(x,(method)nnato_processimage8);}void nnato_think(NNato *x, short val){   x->think = val;}void nnato_quarrel(NNato *x, short val){   x->quarrel = val;}void nnato_processimage(NNato *x, n2atom *data){                       long           i, j, roubitez, pix;                              short         width, height, err;     long 		mapr, mapg, mapb ;                    //does it wrk ?          long 		map = (long) map_beta(x->low, x->high, x->a, x->b)            Ptr            src, dst, srcadresz, dstadresz;          n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate,dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);         if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.auh  : n2iensureimagedimeq err = %ld", err);             return;           }                  if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;          dstpixmap   = n2igetpixmap(dstgvelt);                srcpixztate = n2igetpixstate(srcpixmap);        dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;                  if (!n2ilockpix(dstpixmap)) goto ikk;                        srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);        		              for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                      	mapr 		=	i * tan ((non_zero_random() - .5) * n2mathpi);      //   cauchy malemployed           	mapg 		=	i * tan ((non_zero_random() - .5) * n2mathpi);      //   cauchy malemployed           	mapb 		=	i * tan ((non_zero_random() - .5) * n2mathpi);      //   cauchy malemployed                                      for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp655(n2get32red(pix)   + mapr),					         n2klamp655(n2get32green(pix) + mapg),					         n2klamp655(n2get32blue(pix)  + mapb));									    src+=4;				    dst+=4;					                 }		     }				   	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}		void nnato_processimage2(NNato *x, n2atom *data){                       long           i, j, k,roubitez, pix;                              short         width, height, err;    long 		mapr,mapg,mapb ;                    //does it wrk ?          long 		map = (long) map_beta(x->low, x->high, x->a, x->b)            Ptr            src, dst, srcadresz, dstadresz;          n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate,dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);         if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.auh  : n2iensureimagedimeq err = %ld", err);             return;           }                  if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;          dstpixmap   = n2igetpixmap(dstgvelt);                srcpixztate = n2igetpixstate(srcpixmap);        dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;                  if (!n2ilockpix(dstpixmap)) goto ikk;                        srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);        //	map = (long) map_beta(x->low, x->high, x->a, x->b)  +.5;	              for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                            k = i % x->divx;            if (k==0){                      mapr 		=	i * tan ((map_r(x) - .5) * n2mathpi);    //restoring variabl control                      mapg 		=	i * tan ((map_g(x) - .5) * n2mathpi);    //restoring variabl control                      mapb 		=	i * tan ((map_b(x) - .5) * n2mathpi);    //restoring variabl control			}                                      for(j = 0; j < width; j++)                 {                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp655(n2get32red(pix)   + mapr),					         n2klamp655(n2get32green(pix) + mapg),					         n2klamp655(n2get32blue(pix)  + mapb));									    src+=4;				    dst+=4;					                 }		     }				   	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}		void nnato_processimage3(NNato *x, n2atom *data){                       long           i, j,k, roubitez, pix;                              short         width, height, err;    long 		mapr,mapg,mapb ;                    //does it wrk ?          long 		map = (long) map_beta(x->low, x->high, x->a, x->b)            Ptr            src, dst, srcadresz, dstadresz;          n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate,dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);         if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.auh  : n2iensureimagedimeq err = %ld", err);             return;           }                  if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;          dstpixmap   = n2igetpixmap(dstgvelt);                srcpixztate = n2igetpixstate(srcpixmap);        dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;                  if (!n2ilockpix(dstpixmap)) goto ikk;                        srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);        //	map = (long) map_beta(x->low, x->high, x->a, x->b)  +.5;	              for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                   //               	map = (long) map_beta(x->low, x->high, x->a, x->b)  +.5;                                      for(j = 0; j < width; j++)                 {                 k = i % x->divy;                 		if (k==0) {                 			  mapr 		=	j * tan ((map_r(x) - .5) * n2mathpi)      ;                     			  mapg 		=	j * tan ((map_g(x) - .5) * n2mathpi)      ;                     			  mapb 		=	j * tan ((map_b(x) - .5) * n2mathpi)      ;    				}                 			                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp655(n2get32red(pix)   + mapr),					         n2klamp655(n2get32green(pix) + mapg),					         n2klamp655(n2get32blue(pix)  + mapb));									    src+=4;				    dst+=4;					                 }		     }				   	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}		void nnato_processimage4(NNato *x, n2atom *data){                       long           i, j, k, l,roubitez, pix;                              short         width, height, err;    long 		mapr, mapg, mapb ;                    //does it wrk ?          long 		map = (long) map_beta(x->low, x->high, x->a, x->b)            Ptr            src, dst, srcadresz, dstadresz;          n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate,dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);         if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.auh  : n2iensureimagedimeq err = %ld", err);             return;           }                  if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;          dstpixmap   = n2igetpixmap(dstgvelt);                srcpixztate = n2igetpixstate(srcpixmap);        dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;                  if (!n2ilockpix(dstpixmap)) goto ikk;                        srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);        //	map = (long) map_beta(x->low, x->high, x->a, x->b)  +.5;	              for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;            k = i % x->divx;            if (k==0) {                      	  mapr 		=	i * tan ((map_r(x) - .5) * n2mathpi);                          	  mapg 		=	i * tan ((map_g(x) - .5) * n2mathpi);                          	  mapb 		=	i * tan ((map_b(x) - .5) * n2mathpi);                          }                for(j = 0; j < width; j++)                 {                 l = j % x->divy;                 if (l==0) {                      	  mapr 		=	j * tan ((map_r(x) - .5) * n2mathpi);                          	  mapg 		=	j * tan ((map_g(x) - .5) * n2mathpi);                          	  mapb 		=	j * tan ((map_b(x) - .5) * n2mathpi);                          }                    pix = n2get32(src);					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp655(n2get32red(pix)   + mapr),					         n2klamp655(n2get32green(pix) + mapg),					         n2klamp655(n2get32blue(pix)  + mapb));									    src+=4;				    dst+=4;					                 }		     }				   	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}		void nnato_processimage5(NNato *x, n2atom *data){                       long           i, j, k,l,roubitez, pix;                              short         width, height, err;    long 		mapr,mapg,mapb ;                    //does it wrk ?          long 		map = (long) map_beta(x->low, x->high, x->a, x->b)            Ptr            src, dst, srcadresz, dstadresz;          n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate,dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);         if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.auh  : n2iensureimagedimeq err = %ld", err);             return;           }                  if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;          dstpixmap   = n2igetpixmap(dstgvelt);                srcpixztate = n2igetpixstate(srcpixmap);        dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;                  if (!n2ilockpix(dstpixmap)) goto ikk;                        srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);i = 0;                	  mapr=mapg=mapb 		=	i * tan ((map_r(x) - .5) * n2mathpi);   	              for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                        k = i % x->divx;            if (k==0) {                      	  mapr 		=	i * tan ((map_r(x) - .5) * n2mathpi);                          	  mapg 		=	i * tan ((map_g(x) - .5) * n2mathpi);                          	  mapb 		=	i * tan ((map_b(x) - .5) * n2mathpi);                          }                                      for(j = 0; j < width; j++)                 {                 l = j % x->divy;                 if (l==0){     				mapr =  map_r(x) + .5;     				mapg =  map_g(x) + .5;     				mapb =  map_b(x) + .5;			}                    pix = n2get32(src);                    		n2set32m(dst,					         n2get32alpha(pix),					         n2klamp655(n2get32red(pix)   + mapr),					         n2klamp655(n2get32green(pix) + mapg),					         n2klamp655(n2get32blue(pix)  + mapb));									    src+=4;				    dst+=4;					                 }		     }				   	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}		void nnato_processimage6(NNato *x, n2atom *data){                       long           i, j, k, l,roubitez, pix;                              short         width, height, err;    long 		mapr,mapg,mapb ;                    //does it wrk ?          long 		map = (long) map_beta(x->low, x->high, x->a, x->b)            Ptr            src, dst, srcadresz, dstadresz;          n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate,dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);         if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.auh  : n2iensureimagedimeq err = %ld", err);             return;           }                  if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;          dstpixmap   = n2igetpixmap(dstgvelt);                srcpixztate = n2igetpixstate(srcpixmap);        dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;                  if (!n2ilockpix(dstpixmap)) goto ikk;                        srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);        //	map = (long) map_alpha(x) + .5;	              for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;/*                        k = j % x->divx;            if (k==0)                  	map = (long) map_alpha(x) + .5;    /*/                                  for(j = 0; j < width; j++)                 {     //           l = i % x->divy;         //       if (l==0)             //    				map 		=	i * tan ((map_alpha(x) - .5) * n2mathpi);  //                    pix = n2get32(src); //					n2set32m(dst,	//				         (n2get32alpha(pix) * tan((map_alpha(x) - .5) * n2mathpi)),       //alpha agitation ++	//				         n2klamp655(n2get32red(pix)  + tan((map_alpha(x) - .5) * n2mathpi)),	//				         n2klamp655(n2get32green(pix) + tan((map_alpha(x) - .5) * n2mathpi)),	//				         n2klamp655(n2get32blue(pix)  + tan((map_alpha(x) - .5) * n2mathpi)));	                 l = j % x->divy;                 if (l==0){ 				mapr =map_r(x) + .5; 				mapg =map_g(x) + .5; 				mapb =map_b(x) + .5;			}                    pix = n2get32(src);                    		n2set32m(dst,					         n2get32alpha(pix),					         n2klamp655(n2get32red(pix)   <<  (n2get32red(pix) -mapr)),					         n2klamp655(n2get32green(pix) << (n2get32green(pix) -mapg)),					         n2klamp655(n2get32blue(pix)  << (n2get32blue(pix) -mapb)));										    src+=4;				    dst+=4;					                 }		     }				   	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}		void nnato_processimage7(NNato *x, n2atom *data){                       long           i, j, k, l,roubitez, pix;                              short         width, height, err;    long 		mapr,mapg,mapb ;                    //does it wrk ?          long 		map = (long) map_beta(x->low, x->high, x->a, x->b)            Ptr            src, dst, srcadresz, dstadresz;          n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate,dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);         if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.auh  : n2iensureimagedimeq err = %ld", err);             return;           }                  if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;          dstpixmap   = n2igetpixmap(dstgvelt);                srcpixztate = n2igetpixstate(srcpixmap);        dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;                  if (!n2ilockpix(dstpixmap)) goto ikk;                        srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);        //	map = (long) map_alpha(x) + .5;	              for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;/*                        k = j % x->divx;            if (k==0)                  	map = (long) map_alpha(x) + .5;    /*/                                  for(j = 0; j < width; j++)                 {                l = i % x->divy;                if (l==0){     				mapr 		=	i * tan ((map_r(x) - .5) * n2mathpi);       				mapg 		=	i * tan ((map_g(x) - .5) * n2mathpi);       				mapb 		=	i * tan ((map_b(x) - .5) * n2mathpi);  			}                    pix = n2get32(src); 					n2set32m(dst,					         (n2get32alpha(pix) + mapr),       //alpha agitation ++					         n2klamp655(n2get32red(pix)   + mapr),					         n2klamp655(n2get32green(pix) + mapg),					         n2klamp655(n2get32blue(pix)  + mapb));									    src+=4;				    dst+=4;					                 }		     }				   	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}		void nnato_processimage8(NNato *x, n2atom *data){                       long           i, j, k, l,roubitez, pix;                              short         width, height, err;    long 		mapr,mapg,mapb ;                    //does it wrk ?          long 		map = (long) map_beta(x->low, x->high, x->a, x->b)            Ptr            src, dst, srcadresz, dstadresz;          n2pixmaphdl    srcpixmap, dstpixmap;    n2pixstate     srcpixztate,dstpixztate;    n2imgptr       dstgvelt, gveltptr = n2getatomimage(data);         if (!x->on || !gveltptr) return;        if (x->freeze)           {                 n2registerimage(x,n2objtype,x->dataout,data,x->gvelt);              return;           }                       if (x->bypass)           {              n2registerimage(x,n2objtype,x->dataout,data,gveltptr);              return;              }         if ((err = n2iensuredimeq(&gveltptr,&x->gvelt)))           {             post ("242.auh  : n2iensureimagedimeq err = %ld", err);             return;           }                  if (!x->think)                      srcpixmap   = n2igetpixmap(gveltptr);        else            srcpixmap   = n2igetpixmap(x->gvelt);               if (!x->quarrel)             dstgvelt = x->gvelt;        else            dstgvelt = gveltptr;          dstpixmap   = n2igetpixmap(dstgvelt);                srcpixztate = n2igetpixstate(srcpixmap);        dstpixztate = n2igetpixstate(dstpixmap);                if (!n2ilockpix(srcpixmap)) return;                  if (!n2ilockpix(dstpixmap)) goto ikk;                        srcadresz = n2igetpixaddr(srcpixmap);        dstadresz = n2igetpixaddr(dstpixmap);		roubitez  = n2igetpixrowbytes(srcpixmap);         n2igetdim(gveltptr,&width,&height);        //	map = (long) map_alpha(x) + .5;	              for(i = 0; i < height; i++)   				             {                src = srcadresz + i * roubitez;                            dst = dstadresz + i * roubitez;                        k = i % x->divx;            if (k==0){	              	mapr =map_r(x) + .5;	              	mapg = map_g(x) + .5;	              	mapb =map_b(x) + .5;                      }                for(j = 0; j < width; j++)                 {                 l = j % x->divy;                 if (l==0){	              	mapr =map_r(x) + .5;	              	mapg = map_g(x) + .5;	              	mapb =map_b(x) + .5;                      }                    pix = n2get32(src); 					n2set32m(dst,					         n2get32alpha(pix),					         n2klamp655(n2get32red(pix)   / mapr),					         n2klamp655(n2get32green(pix) / mapg),					         n2klamp655(n2get32blue(pix)  / mapb));									    src+=4;				    dst+=4;					                 }		     }				   	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);        n2registerimage(x,n2objtype,x->dataout,data,dstgvelt);        return;        ikk: 	    n2isetpixstate(srcpixmap,srcpixztate);        n2isetpixstate(dstpixmap,dstpixztate);}		