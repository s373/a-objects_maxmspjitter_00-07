/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑa-toquad - © andrŽ sier 2004				- converter um ponto 3d para coords de um quad, sem rota‹o		- adicionar 1 mŽtodo de ROTATE global		- adicionar 1 mŽtodo de ROTATE localÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*/#include "ext.h"#include "ext_common.h"#include "math.h"#define pi 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068#define divide_pi pi/180.#define two_pi 2.*pi#define divide_two_pi 1./two_pitypedef struct	_toquad{	t_object 	        c_ob;				void 		        *c_out;		// outlet		double w, h;	short fix, modo; //modo 0 int, 1 float	short om;	short r_om;	double in[3]; 		// 3 coords de entrada	double out[12]; 	// 4pt * 3 coords/ponto	double rotate[3];	// rotation vector	t_atom o[12];} toquad;void *toquad_new (Symbol *msg, short argc, Atom *argv);void toquad_calc (toquad *x); 	//exec calcsvoid toquad_dorotate (toquad *x); //exec rotationvoid toquad_setrot (toquad *x, Symbol *msg, short argc, Atom *argv); //set rotation argsvoid toquad_bang (toquad *x); //execvoid toquad_list (toquad *x, Symbol *msg, short argc, Atom *argv); //input the args void toquad_w (toquad *x, double max);void toquad_h (toquad *x, double max);void toquad_wh (toquad *x, Symbol *msg, short argc, Atom *argv);void toquad_fix (toquad *x, short max);void toquad_om (toquad *x, short max);void toquad_r_om (toquad *x, short max);void toquad_assist(toquad *x, void *b, long m, long a, char *s);void *toquad_class;//____imPORTANT myroundING FUNC fixed: fix HVlong myround (float tomyround);double piwrap(double f);//__void *toquad_new (Symbol *msg, short argc, Atom *argv) //input the args { toquad *x; int i;  x=(toquad *)newobject(toquad_class); x->c_out=listout(x); //init	x->w = 10.0f;	x->h = 10.0f;	x->fix = 1;	x->om = 0;	x->in[0] = 0.0f;	x->in[1] = 0.0f;	x->in[2] = 0.0f;		x->r_om = 0;	if (argc) {		if (argc==1) { //if 1 arg			if (argv[0].a_type == A_LONG){			x->w = x->h =  (double) argv[0].a_w.w_long; //important!> 0 is first!			x->modo = 0;			} else if (argv[0].a_type == A_FLOAT){			x->w = x->h = (double) argv[0].a_w.w_float;				x->modo = 1;     		  	}				} else if (argc==2) { //2 args			if (argv[0].a_type == A_LONG){ //if first arg == long				x->w =  (double) argv[0].a_w.w_long;				x->h = (double) argv[1].a_w.w_long;				x->modo = 0;					} else if (argv[0].a_type == A_FLOAT){ 				x->w =  (double) argv[0].a_w.w_float;				x->h = (double) argv[1].a_w.w_float;				x->modo = 1;			}				} else if (argc>2) { //3+ args			if (argv[0].a_type == A_LONG){ //if first arg == long				x->w =  (double) argv[0].a_w.w_long;				x->h = (double) argv[1].a_w.w_long;				x->modo = 0;				x->om = (short) argv[2].a_w.w_long;					} else if (argv[0].a_type == A_FLOAT){ 				x->w =  (double) argv[0].a_w.w_float;				x->h = (double) argv[1].a_w.w_float;				x->modo = 1;				x->om = (short) argv[2].a_w.w_float;			}				}	} //end if args return(x);	}void toquad_list (toquad *x, Symbol *msg, short argc, Atom *argv) //input the args {	if (argc) {			if (argc==1) { //if 1 arg: set X			if (argv[0].a_type == A_LONG){			x->in[0] = (double) argv[0].a_w.w_long; //important!> 0 is first!			x->modo = 0;			} else if (argv[0].a_type == A_FLOAT){			x->in[0] = (double) argv[0].a_w.w_float;				x->modo = 1;     		  	}				} else if (argc==2) { //2 args: IMPORTANT; SET X and Z only!			if (argv[0].a_type == A_LONG){ //if first arg == long				x->in[0] =  (double) argv[0].a_w.w_long;				x->in[2] =(double) argv[1].a_w.w_long;				x->modo = 0;					} else if (argv[0].a_type == A_FLOAT){ 				x->in[0] =  (double) argv[0].a_w.w_float;				x->in[2] = (double) argv[1].a_w.w_float;				x->modo = 1;								}				} else if (argc>=3) { //3+ args			if (argv[0].a_type == A_LONG){ //if first arg == long				x->in[0] =  (double) argv[0].a_w.w_long;				x->in[1] =(double) argv[1].a_w.w_long;				x->in[2] =(double) argv[2].a_w.w_long;				x->modo = 0;					} else if (argv[0].a_type == A_FLOAT){ 				x->in[0] =  (double) argv[0].a_w.w_float;				x->in[1] = (double) argv[1].a_w.w_float;				x->in[2] = (double) argv[2].a_w.w_float;				x->modo = 1;								}		}		 //end if args	toquad_calc(x);	}}void  toquad_calc (toquad *x){	double w, h, w2, h2, in[3], aminus, aplus, zminus, zplus, origin[3];	short modo = x->modo, i;	long	t[12];	t_atom *o;		o = x->o;		w = x->w;	h = x->h;	if(!x->r_om) {			in[0] = x->in[0];			in[1] = x->in[1];			in[2] = x->in[2];						if (x->fix) {				w2 = w/2;				h2 = h/2;								aminus = in[0]-w2;				aplus  = in[0]+w2;				zminus = in[2]-h2;				zplus  = in[2]+h2;					} else if (!x->fix) {				aminus = in[0];				aplus  = in[0]+w;				zminus = in[2];				zplus  = in[2]+w;					}			//ok, now set the outpoints based on the az coords			// right handed			//point 000			x->out[0] = aminus;			x->out[1] = in[1];			x->out[2] = zminus;			//point 100			x->out[3] = aplus;			x->out[4] = in[1];			x->out[5] = zminus;			//point 100			x->out[6] = aplus;			x->out[7] = in[1];			x->out[8] = zplus;			//point 001			x->out[9] = aminus;			x->out[10] = in[1];			x->out[11] = zplus;						//perform rotation		//	if(x->rotate[0]!=0. && x->rotate[1]!=0. && x->rotate[2]!=0.)						//but rotate about the center!, ie, the in[]vector!						toquad_dorotate(x);		//	toquad_bang(x);						if (x->modo) { //float				SETFLOAT(o+0, (float)x->out[0]);				SETFLOAT(o+1, (float)x->out[1]);				SETFLOAT(o+2, (float)x->out[2]);				SETFLOAT(o+3, (float)x->out[3]);				SETFLOAT(o+4, (float)x->out[4]);				SETFLOAT(o+5, (float)x->out[5]);				SETFLOAT(o+6, (float)x->out[6]);				SETFLOAT(o+7, (float)x->out[7]);				SETFLOAT(o+8, (float)x->out[8]);				SETFLOAT(o+9, (float)x->out[9]);				SETFLOAT(o+10, (float)x->out[10]);				SETFLOAT(o+11, (float)x->out[11]);			} else if(!x->modo) {				t[0] = (long) (myround(x->out[0]));				t[1] = (long) (myround(x->out[1]));				t[2] = (long) (myround(x->out[2]));				t[3] = (long) (myround(x->out[3]));				t[4] = (long) (myround(x->out[4]));				t[5] = (long) (myround(x->out[5]));				t[6] = (long) (myround(x->out[6]));				t[7] = (long) (myround(x->out[7]));				t[8] = (long) (myround(x->out[8]));				t[9] = (long) (myround(x->out[9]));				t[10] = (long) (myround(x->out[10]));				t[11] = (long) (myround(x->out[11]));				SETLONG(o+0, t[0]);				SETLONG(o+1, t[1]);				SETLONG(o+2, t[2]);				SETLONG(o+3, t[3]);				SETLONG(o+4, t[4]);				SETLONG(o+5, t[5]);				SETLONG(o+6, t[6]);				SETLONG(o+7, t[7]);				SETLONG(o+8, t[8]);				SETLONG(o+9, t[9]);				SETLONG(o+10, t[10]);				SETLONG(o+11, t[11]);			}			outlet_list (x->c_out, 0L, 12, o);	} else if (x->r_om) {					// neste modo temos de rodar primeiro em torno da origem			// e s— depois podemos por os pontos no s’tio...				origin[0]=0.;			origin[1]=0.;			origin[2]=0.;		/*		in[0] = x->in[0];			in[1] = x->in[1];			in[2] = x->in[2];*/						in[0] = origin[0];			in[1] = origin[1];			in[2] = origin[2];						if (x->fix) {				w2 = w/2;				h2 = h/2;								aminus = in[0]-w2;				aplus  = in[0]+w2;				zminus = in[2]-h2;				zplus  = in[2]+h2;					} else if (!x->fix) {				aminus = in[0];				aplus  = in[0]+w;				zminus = in[2];				zplus  = in[2]+w;					}			//ok, now set the outpoints based on the az coords			// right handed			//point 000			x->out[0] = aminus;			x->out[1] = in[1];			x->out[2] = zminus;			//point 100			x->out[3] = aplus;			x->out[4] = in[1];			x->out[5] = zminus;			//point 100			x->out[6] = aplus;			x->out[7] = in[1];			x->out[8] = zplus;			//point 001			x->out[9] = aminus;			x->out[10] = in[1];			x->out[11] = zplus;						//perform rotation			// de certeza que foi em torno do eixo de origem!									toquad_dorotate(x);			// agora falta, a cada ponto, adicionar o vector da localiza‹o!				in[0] = x->in[0];			in[1] = x->in[1];			in[2] = x->in[2];					for(i=0;i<12;i++)				x->out[i] = x->out[i] + in[i%3];		//	toquad_bang(x);						if (x->modo) { //float				SETFLOAT(o+0, (float)x->out[0]);				SETFLOAT(o+1, (float)x->out[1]);				SETFLOAT(o+2, (float)x->out[2]);				SETFLOAT(o+3, (float)x->out[3]);				SETFLOAT(o+4, (float)x->out[4]);				SETFLOAT(o+5, (float)x->out[5]);				SETFLOAT(o+6, (float)x->out[6]);				SETFLOAT(o+7, (float)x->out[7]);				SETFLOAT(o+8, (float)x->out[8]);				SETFLOAT(o+9, (float)x->out[9]);				SETFLOAT(o+10, (float)x->out[10]);				SETFLOAT(o+11, (float)x->out[11]);			} else if(!x->modo) {				t[0] = (long) (myround(x->out[0]));				t[1] = (long) (myround(x->out[1]));				t[2] = (long) (myround(x->out[2]));				t[3] = (long) (myround(x->out[3]));				t[4] = (long) (myround(x->out[4]));				t[5] = (long) (myround(x->out[5]));				t[6] = (long) (myround(x->out[6]));				t[7] = (long) (myround(x->out[7]));				t[8] = (long) (myround(x->out[8]));				t[9] = (long) (myround(x->out[9]));				t[10] = (long) (myround(x->out[10]));				t[11] = (long) (myround(x->out[11]));				SETLONG(o+0, t[0]);				SETLONG(o+1, t[1]);				SETLONG(o+2, t[2]);				SETLONG(o+3, t[3]);				SETLONG(o+4, t[4]);				SETLONG(o+5, t[5]);				SETLONG(o+6, t[6]);				SETLONG(o+7, t[7]);				SETLONG(o+8, t[8]);				SETLONG(o+9, t[9]);				SETLONG(o+10, t[10]);				SETLONG(o+11, t[11]);			}			outlet_list (x->c_out, 0L, 12, o);					}}void toquad_dorotate (toquad *x) //exec rotation{	double calc[11];   	short i,j;//	post("rotating");//roll, yaw, pitch		calc[0] = sin(x->rotate[2]);//sin(x->d_pitch); 		calc[1] = cos(x->rotate[2]);//cos(x->d_pitch);		calc[2] = sin(x->rotate[1]); 		calc[3] = cos(x->rotate[1]);		calc[4] = sin(x->rotate[0]); 		calc[5] = cos(x->rotate[0]);	for(j=0;j<4;j++) {													// 4 conjuntos de 3 pontos//		for(i=0;i<3;i++) { 												// de tres pontos cada 1			calc[6] = (double)(x->out[j*3+1]) * calc[5];			calc[7] = (double)(x->out[j*3+0]) * calc[4];			calc[8] = calc[5] * (double)(x->out[j*3+0]);			calc[9] = calc[4] *(double)(x->out[j*3+1]);			calc[10] = calc[3] * (double)(x->out[j*3+2]);			x->out[j*3+0] = (float)(calc[3]*(calc[8]-calc[9])+calc[2] * (double)(x->out[j*3+2]));			x->out[j*3+1] = (float)(calc[0]*(calc[2]*calc[8]-calc[2]*calc[9]-calc[10])+calc[1]*(calc[7]+calc[6]));			x->out[j*3+2] = (float)(calc[1]*(-calc[2]*calc[8]+calc[2]*calc[9]+calc[10])+calc[0]*(calc[7]+calc[6]));		}//	}}void toquad_setrot (toquad *x, Symbol *msg, short argc, Atom *argv){	float temp[3];	short j;	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}	x->rotate[0] = temp[0];	x->rotate[1] = temp[1];	x->rotate[2] = temp[2];//	post ("rotate  %f %f %f",x->rotate[0], x->rotate[1],x->rotate[2]);	if (x->om)			toquad_calc(x);}void toquad_bang (toquad *x){		toquad_calc(x);}void toquad_w (toquad *x, double max){	x->w = max;	if (x->om)	toquad_calc(x);}void toquad_h (toquad *x, double max){	x->h = max;	if (x->om)	toquad_calc(x);}void toquad_wh (toquad *x, Symbol *msg, short argc, Atom *argv){	short i;		if (argc) {		if (argc==1) { //if 1 arg			if (argv[0].a_type == A_LONG){				x->w = (double) argv[0].a_w.w_long; 				x->h = (double) argv[0].a_w.w_long; 				x->modo = 0;			} else if (argv[0].a_type == A_FLOAT){				x->w = (double) argv[0].a_w.w_float; 				x->h = (double) argv[0].a_w.w_float; 				x->modo = 1;     		  	}				} else if (argc>=2) { //2+ args			if (argv[0].a_type == A_LONG){ //if first arg == long				x->w = (double) argv[0].a_w.w_long; 				x->h = (double) argv[1].a_w.w_long; 				x->modo = 0;					} else if (argv[0].a_type == A_FLOAT){ 				x->w = (double) argv[0].a_w.w_float; 				x->h = (double) argv[1].a_w.w_float; 				x->modo = 1;			}				}	}	if (x->om)	toquad_calc(x);}void toquad_fix (toquad *x, short max){	x->fix = max;}void toquad_om (toquad *x, short max){	x->om = max;}void toquad_r_om (toquad *x, short max){	x->om = max;}void main(void){ long int tick = gettime(); setup((t_messlist**)&toquad_class,(method)toquad_new,0L,(short)sizeof(toquad),0L, A_GIMME,0);  addbang((method)toquad_bang); addmess((method)toquad_list, "list", A_GIMME, 0); addmess((method)toquad_w, "w", A_DEFFLOAT, 0); addmess((method)toquad_h, "h", A_DEFFLOAT, 0);addmess((method)toquad_wh, "wh", A_GIMME, 0);addmess((method)toquad_wh, "hv", A_GIMME, 0);addmess((method)toquad_fix, "fix", A_DEFLONG, 0);addmess((method)toquad_om, "om", A_DEFLONG, 0);addmess((method)toquad_r_om, "rot.om", A_DEFLONG, 0);addmess((method)toquad_setrot, "rot", A_GIMME, 0);addmess((method)toquad_setrot, "rotate", A_GIMME, 0); addmess((method)toquad_assist,"assist", A_CANT, 0); post(__DATE__" \t \a \t  "__TIME__"\t \a \t %08xd                                 a-2quad   ©   a n d r Ž s i e r   2 0 0 4   all rights reserved",tick, 0);}void toquad_assist(toquad *x, void *b, long m, long a, char *s){    if (m==1) { sprintf(s,"echo e   c  h   o"); }       else if (m==2&&a==0) { sprintf(s,"(list) 2quad     e         c            h              o"); } //   else if (m==2&&a==1) { sprintf(s,"(float) y       e             c                h                   o"); }}long myround (float tomyround){ long res; 	if (tomyround<0)	 	tomyround-=0.5;	else		tomyround+=0.5;	res = (long)tomyround;	 return res;}double piwrap(double f){	double op1, op3;	long op2;	if (f >= 0) {																op1 = f + pi;		}		else {		op1 = f - pi;		}		op2 = (long)(op1 * divide_two_pi);		op3 = (double)op2 * two_pi;		f -= op3;		return f;}