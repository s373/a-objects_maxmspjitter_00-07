/*1st person flying camerato do :	- circle apparatus	- bound mode		-none		-clip		-wrap		-foldtouching file 20040730 to calc using cheap norm.. eliminate call to sqrt.*//*20040830 | 20040901- added rotate around point (3rd person lookat)apropos	//dont forget to check validity of space	cam_boundpos(x);remember when bounc is detected to also bounce lookat*/#include "ext.h"#include "ext_common.h"#include <math.h>//#ifndef M_PI#define MyPI	3.1415926535897932384626433832795//#endif#ifndef M_PI#define M_PI		3.14159265358979323846f	// matches value in gcc v2 math.h#endif#define M_PI2		M_PI/2.0f	// matches value in gcc v2 math.h#define TREZ 65535	//tables resolution /2static long int shift; // the shifting according to the table size#define PIdiv180 (MyPI/180.)//#define NULL_VECTOR (0.,0.,0.)typedef struct	{	t_object 	        c_ob;				void 		        *c_out;		// outlet cam lookat			void				*c_out2;	// outlet position	void				*c_out3;	// outlet up vector	void				*c_out4;	// outlet cam lookat vector's	void				*c_out5;	// outlet cam pos vector's	void				*c_out6;	// outlet cam up vector's	short				boundmode[3];						// the limit points of a square/*	float				limit_left_back_down[3], limit_right_back_down[3],						limit_left_back_up[3], limit_right_back_up[3],						limit_left_front_down[3], limit_right_front_down[3],						limit_left_front_up[3], limit_right_front_up[3];*/		float				min[3], max[3];			float				pos[3], up[3], look[3], right[3]; // the needed vectors														// position, up, look and right		t_atom				out[3];		float cam_pos[3], cam_look[3], cam_up[3], cam_right[3];		short	ground;	} cam;void *cam_new (Symbol *msg, short argc, Atom *argv);void cam_bang (cam *x);// motion modesvoid cam_rotateX (cam *x, Symbol *msg, short argc, Atom *argv);void cam_rotateY (cam *x, Symbol *msg, short argc, Atom *argv);void cam_rotateZ (cam *x, Symbol *msg, short argc, Atom *argv);void cam_move (cam *x, Symbol *msg, short argc, Atom *argv);void cam_fwd (cam *x, Symbol *msg, short argc, Atom *argv);void cam_right (cam *x, Symbol *msg, short argc, Atom *argv);void cam_up (cam *x, Symbol *msg, short argc, Atom *argv); // metodo distancia ponto a planovoid cam_setpos (cam *x, Symbol *msg, short argc, Atom *argv);void cam_setup (cam *x, Symbol *msg, short argc, Atom *argv);void cam_setlook (cam *x, Symbol *msg, short argc, Atom *argv);void cam_setright (cam *x, Symbol *msg, short argc, Atom *argv);void cam_reset (cam *x, Symbol *msg, short argc, Atom *argv);void cam_circleup (cam *x, Symbol *msg, short argc, Atom *argv);void cam_circleright (cam *x, Symbol *msg, short argc, Atom *argv);void cam_boundmode (cam *x, Symbol *msg, short argc, Atom *argv);void cam_min (cam *x, Symbol *msg, short argc, Atom *argv);void cam_max (cam *x, Symbol *msg, short argc, Atom *argv);void cam_boundpos (cam *x);// tentar povvoid cam_pov (cam *x, Symbol *msg, short argc, Atom *argv);// tentar rotate around a pointvoid cam_rotate_around_point (cam *x, Symbol *msg, short argc, Atom *argv);void cam_rotate_around_lookat (cam *x, Symbol *msg, short argc, Atom *argv);void cam_assist(cam *x, void *b, long m, long a, char *s);void *cam_class;float wrap(float in, float min, float max);float fold(float in, float min, float max);float clip(float in, float min, float max);void wrap1(float in, float min, float max);void fold1(float in, float min, float max);void clip1(float in, float min, float max);void wrap3(float in[3], float min[3], float max[3]);void clip3(float in[3], float min[3], float max[3]);void fold3(float in[3], float min[3], float max[3]);//3d simple prototypesvoid copy(float vec0[3], float vec1[3]);void sub(float vec0[3], float vec1[3], float vec2[3]);void add(float vec0[3], float vec1[3], float vec2[3]);void scalDiv(float vec[3], float c);void cross(float vec0[3], float vec1[3], float vec2[3]);void norm(float vec[3]) ;void set(float vec[3], float x, float y, float z);void dot(float c, float vec1[3], float vec2[3]);	// not workingvoid mult1(float vec0[3], float vec1[3], float v2);void norm_full(float vec[3]) ;//sindouble ciel_sintable[TREZ];double ciel_math_sin(double x);double ciel_math_cos(double x);void ciel_make_tables();double ciel_math_sqrt( double x );void *cam_new (Symbol *msg, short argc, Atom *argv) //input the args {	 cam *x;	 int i,j;	 float temp[3];	 	 x=(cam *)newobject(cam_class);//	 x->c_out6=listout(x);//cam up//	 x->c_out5=listout(x);// cam pos//	 x->c_out4=listout(x);// cam look	 x->c_out3=listout(x);// up	 x->c_out2=listout(x);// pos	 x->c_out =listout(x);// look	 	ciel_make_tables();	//init	set(x->pos, 0., 0., 0.);	set(x->up, 0., 1., 0.);	set(x->look, 0., 0., -1.);	set(x->right, 1., 0., 0.);	//init	set(x->cam_pos, 0., 0., 0.);	set(x->cam_up, 0., 1., 0.);	set(x->cam_look, 0., 0., -1.);	set(x->cam_right, 1., 0., 0.);	set(x->min, -2., -2., -10.);	set(x->max, 2., 2., 10.);	x->boundmode[0] =  0;	x->boundmode[1] =  0;	x->boundmode[2] =  0;		x->ground = 1;	if (argc) { // 	 for(i=0;i<argc/2;i++){		if(argv->a_w.w_sym == gensym("@pos")){			argv++;			for(j=0;j<3;j++) {				if(argv->a_type == A_FLOAT) {					temp[j] = (float)argv->a_w.w_float;						argv++;				} else if(argv->a_type == A_LONG) {					temp[j] = (float)argv->a_w.w_long;						argv++;				}			}			copy(x->pos, temp);		}				if(argv->a_w.w_sym == gensym("@up")){			argv++;			for(j=0;j<3;j++) {				if(argv->a_type == A_FLOAT) {					temp[j] = (float)argv->a_w.w_float;						argv++;				} else if(argv->a_type == A_LONG) {					temp[j] = (float)argv->a_w.w_long;						argv++;				}			}			copy(x->pos, temp);		}		if(argv->a_w.w_sym == gensym("@look")){			argv++;			for(j=0;j<3;j++) {				if(argv->a_type == A_FLOAT) {					temp[j] = (float)argv->a_w.w_float;						argv++;				} else if(argv->a_type == A_LONG) {					temp[j] = (float)argv->a_w.w_long;						argv++;				}			}			copy(x->look, temp);		}		if(argv->a_w.w_sym == gensym("@right")){			argv++;			for(j=0;j<3;j++) {				if(argv->a_type == A_FLOAT) {					temp[j] = (float)argv->a_w.w_float;						argv++;				} else if(argv->a_type == A_LONG) {					temp[j] = (float)argv->a_w.w_long;						argv++;				}			}			copy(x->right, temp);		}		if(argv->a_w.w_sym == gensym("@min")){			argv++;			for(j=0;j<3;j++) {				if(argv->a_type == A_FLOAT) {					temp[j] = (float)argv->a_w.w_float;						argv++;				} else if(argv->a_type == A_LONG) {					temp[j] = (float)argv->a_w.w_long;						argv++;				}			}			copy(x->min, temp);		}				if(argv->a_w.w_sym == gensym("@max")){			argv++;			for(j=0;j<3;j++) {				if(argv->a_type == A_FLOAT) {					temp[j] = (float)argv->a_w.w_float;						argv++;				} else if(argv->a_type == A_LONG) {					temp[j] = (float)argv->a_w.w_long;						argv++;				}			}			copy(x->max, temp);		}/*		if(argv->a_w.w_sym == gensym("@boundmode")){			argv++;				if(argv->a_type == A_FLOAT) {					temp[0] = (long)argv->a_w.w_float;						argv++;				} else if(argv->a_type == A_LONG) {					temp[0] = (long)argv->a_w.w_long;						argv++;				}			x->boundmode = temp[0];			}*/			 } // end for	} // end argc	 return(x);	}void cam_boundmode (cam *x, Symbol *msg, short argc, Atom *argv){	short temp[3], j;		if(argc==1) {		for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (long)argv->a_w.w_float;			} else if(argv->a_type == A_LONG) {			temp[j] = (long)argv->a_w.w_long;			}	}		}else {	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (long)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (long)argv->a_w.w_long;				argv++;		}	}	}//	x->boundmode = temp[0];//	copy (x->boundmode, temp);	x->boundmode[0] =  temp[0];	x->boundmode[1] =  temp[1];	x->boundmode[2] =  temp[2];//	post("bound %i %i %i",x->boundmode[0], x->boundmode[1], x->boundmode[2]); 	/*	- bound mode		-none		-clip		-wrap		-fold*/}void cam_min (cam *x, Symbol *msg, short argc, Atom *argv){	float temp[3];	short j;	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}	copy(x->min, temp);}void cam_max (cam *x, Symbol *msg, short argc, Atom *argv){	float temp[3];	short j;	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}	copy(x->max, temp);}void cam_boundpos (cam *x){	float	view_point[3], t[3];	short b = x->boundmode[0], i;	// multi bound mode	for(i=0;i<3;i++) {		switch (x->boundmode[i]) {			case 3:				x->pos[i] = fold(x->pos[i], x->min[i], x->max[i]);				break;			case 2:				x->pos[i] = wrap(x->pos[i], x->min[i], x->max[i]);//				post("wrapin");				break;			case 1:				x->pos[i] = clip(x->pos[i], x->min[i], x->max[i]);				break;			case 0:			default:				break;			}			}}void cam_bang (cam *x){	short i;	t_atom * o;	float	view_point[3], t[3];	short b= x->boundmode[0];			o = x->out;	for(i=0;i<3;i++) {		SETFLOAT(o+i, x->up[i]);	}	outlet_list(x->c_out3, 0L, 3, o);	for(i=0;i<3;i++) {		SETFLOAT(o+i, x->pos[i]);	}	outlet_list(x->c_out2, 0L, 3, o);			// VERY IMPORTANT :: view_point =  LOOK+POS				add(view_point, x->look,x->pos);	for(i=0;i<3;i++) {		SETFLOAT(o+i, view_point[i]);	}	outlet_list(x->c_out, 0L, 3, o);	}void cam_move (cam *x, Symbol *msg, short argc, Atom *argv){	float temp[3];	short j;	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}	add(x->pos, x->pos, temp);		cam_boundpos(x);}void cam_rotateX (cam *x, Symbol *msg, short argc, Atom *argv){	float angle, temp[3], sin_calc, cos_calc;	if(argv->a_type == A_FLOAT) {		angle = (float)argv->a_w.w_float;		} else if(argv->a_type == A_LONG) {		angle = (float)argv->a_w.w_long;		}//	post("angle: %f", angle);//	sin_calc = sin((angle*MyPI)/180.);//	cos_calc = cos((angle*MyPI)/180.);	sin_calc = ciel_math_sin(angle*PIdiv180);	cos_calc = ciel_math_cos(angle*PIdiv180);	x->look[0] = x->look[0] * cos_calc + x->up[0] * sin_calc;	x->look[1] = x->look[1] * cos_calc + x->up[1] * sin_calc;	x->look[2] = x->look[2] * cos_calc + x->up[2] * sin_calc;	norm(x->look);	cross(temp, x->look, x->right);	mult1(x->up, temp, -1.);//	x->look = norm(x->look*cos(angle*PIdiv180) + x->up*sin(angle*PIdiv180));/*	//Rotate viewdir around the right vector:	ViewDir = Normalize3dVector(ViewDir*cos(Angle*PIdiv180)								+ UpVector*sin(Angle*PIdiv180));	//now compute the new UpVector (by cross product)	UpVector = CrossProduct(&ViewDir, &RightVector)*-1;*/}void cam_rotateY (cam *x, Symbol *msg, short argc, Atom *argv){	float angle, temp[3], cos_calc, sin_calc;	if(argv->a_type == A_FLOAT) {		angle = (float)argv->a_w.w_float;		} else if(argv->a_type == A_LONG) {		angle = (float)argv->a_w.w_long;		}	sin_calc = ciel_math_sin(angle*PIdiv180);	cos_calc = ciel_math_cos(angle*PIdiv180);	x->look[0] = x->look[0] * cos_calc - x->right[0] * sin_calc;	x->look[1] = x->look[1] * cos_calc - x->right[1] * sin_calc;	x->look[2] = x->look[2] * cos_calc - x->right[2] * sin_calc;	norm(x->look); 		cross(x->right, x->look, x->up);/*	//Rotate viewdir around the up vector:	ViewDir = Normalize3dVector(ViewDir*cos(Angle*PIdiv180)								- RightVector*sin(Angle*PIdiv180));	//now compute the new RightVector (by cross product)	RightVector = CrossProduct(&ViewDir, &UpVector);*/}void cam_rotateZ (cam *x, Symbol *msg, short argc, Atom *argv){	float angle, temp[3],  cos_calc, sin_calc;	if(argv->a_type == A_FLOAT) {		angle = (float)argv->a_w.w_float;		} else if(argv->a_type == A_LONG) {		angle = (float)argv->a_w.w_long;		}	sin_calc = ciel_math_sin(angle*PIdiv180);	cos_calc = ciel_math_cos(angle*PIdiv180);	x->right[0] = x->right[0] * cos_calc + x->up[0] * sin_calc;	x->right[1] = x->right[1] * cos_calc + x->up[1] * sin_calc;	x->right[2] = x->right[2] * cos_calc + x->up[2] * sin_calc;	norm(x->right); 	cross(x->up, x->look, x->right);	mult1(x->up, x->up, -1.);/*//Rotate viewdir around the right vector:	RightVector = Normalize3dVector(RightVector*cos(Angle*PIdiv180)								+ UpVector*sin(Angle*PIdiv180));	//now compute the new UpVector (by cross product)	UpVector = CrossProduct(&ViewDir, &RightVector)*-1;*/}void cam_circleup (cam *x, Symbol *msg, short argc, Atom *argv){	float temp[3];	short j;	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}//	SF3dVector ViewPoint = Position+ViewDir; // assim viewdir = viewpoint-position	// falta incrementar o circulo...	sub(x->look, temp, x->pos);}void cam_circleright (cam *x, Symbol *msg, short argc, Atom *argv){	float temp[3];	short j;	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}//	SF3dVector ViewPoint = Position+ViewDir; // assim viewdir = viewpoint-position	// falta incrementar o circulo...	sub(x->look, temp, x->pos);}void cam_fwd (cam *x, Symbol *msg, short argc, Atom *argv){	float distance, view[3];	if(argv->a_type == A_FLOAT) {		distance = (float)argv->a_w.w_float;		} else if(argv->a_type == A_LONG) {		distance = (float)argv->a_w.w_long;		}	distance = -distance;	mult1(view, x->look, distance);	if(!x->ground)		add(x->pos, x->pos, view);	else if(x->ground) {		x->pos[0] += view[0];		x->pos[2] += view[2];	}	cam_boundpos(x);}void cam_right (cam *x, Symbol *msg, short argc, Atom *argv){	float distance, right[3];	if(argv->a_type == A_FLOAT) {		distance = (float)argv->a_w.w_float;		} else if(argv->a_type == A_LONG) {		distance = (float)argv->a_w.w_long;		}	mult1(right, x->right, distance);	if(!x->ground)		add(x->pos, x->pos, right);	else if(x->ground) {		x->pos[0] += right[0];		x->pos[2] += right[2];	}		cam_boundpos(x);}void cam_up (cam *x, Symbol *msg, short argc, Atom *argv){	float distance, up[3];	if(argv->a_type == A_FLOAT) {		distance = (float)argv->a_w.w_float;		} else if(argv->a_type == A_LONG) {		distance = (float)argv->a_w.w_long;		}	mult1(up, x->up, distance);	if(!x->ground)		add(x->pos, x->pos, up);	else if(x->ground) {		x->pos[0] += up[0];		x->pos[2] += up[2];	}	cam_boundpos(x);}void cam_setpos (cam *x, Symbol *msg, short argc, Atom *argv){	float temp[3];	short j;	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}	copy(x->pos, temp);	cam_boundpos(x);}void cam_setup (cam *x, Symbol *msg, short argc, Atom *argv){	float temp[3];	short j;	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}	copy(x->up, temp);}void cam_setlook (cam *x, Symbol *msg, short argc, Atom *argv){	float temp[3];	short j;	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}	copy(x->look, temp);}void cam_setright (cam *x, Symbol *msg, short argc, Atom *argv){	float temp[3];	short j;	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}	copy(x->right, temp);}void cam_pov (cam *x, Symbol *msg, short argc, Atom *argv){	// pov touches postition and angle	float temp[6], pos[3], ang[3];	short i;		for(i=0;i<6;i++) {		if(argv->a_type == A_FLOAT) {			temp[i] = (float)argv->a_w.w_float;			} else if(argv->a_type == A_LONG) {			temp[i] = (float)argv->a_w.w_long;			}	}	pos[0] = temp[0];	pos[1] = temp[1];	pos[2] = temp[2];	ang[0] = temp[3];	ang[1] = temp[4];	ang[2] = temp[5];	set(x->pos, temp[0], temp[1], temp[2]);	cam_boundpos(x);}void cam_rotate_around_point (cam *x, Symbol *msg, short argc, Atom *argv){	// This rotates the camera around a point (I.E. your character).	// vCenter is the point that we want to rotate the position around.	// Like the other rotate function, the x, y and z is the axis to rotate around.		// We want to rotate around the Y axis so we pass in a positive Y speed		// g_Camera.RotateAroundPoint(g_Camera.m_vView, kSpeed, 0, 1, 0);		float temp[7];	short j;	float angle, rot[3];	float costheta, sintheta;	float newpos[3];	float vpos[3], center[3]; // the vector to the point		long i;	for(i=0;i<7;i++) {		if(argv->a_type == A_FLOAT) {			temp[i] = (float)argv->a_w.w_float;			} else if(argv->a_type == A_LONG) {			temp[i] = (float)argv->a_w.w_long;			}	}	// angle axis rotatio!		// set the input in local vars	set(center, temp[0], temp[1], temp[2]);	angle = temp[3];	set(rot, temp[4], temp[5], temp[6]); // the center position to rotate around	// To rotate our position around a point, what we need to do is find	// a vector from our position to the center point we will be rotating around.	// Once we get this vector, then we rotate it along the specified axis with	// the specified degree.  Finally the new vector is added center point that we	// rotated around (vCenter) to become our new position.  That's all it takes.	// Get the vVector from our position to the center we are rotating around	sub(vpos, x->pos, center); // set in vpos the vector from current postition to the desired rotate about point 	costheta = cos(angle);	sintheta = sin(angle);			newpos[0]  = (costheta + (1-costheta) *rot[0]*rot[0])		* vpos[0];	newpos[0] += ((1-costheta) *rot[0]*rot[1] -rot[2] * sintheta)* vpos[1];	newpos[0] += ((1-costheta) *rot[0]*rot[2] +rot[1] * sintheta)* vpos[2];	newpos[1]  = ((1-costheta) *rot[0]*rot[1] +rot[2] * sintheta)* vpos[0];	newpos[1] += (costheta + (1-costheta) *rot[1]*rot[1])	* vpos[1];	newpos[1] += ((1-costheta) *rot[1]*rot[2] -rot[0] * sintheta)* vpos[2];	newpos[2]  = ((1-costheta) *rot[0]*rot[2] -rot[1] * sintheta)	* vpos[0];	newpos[2] += ((1-costheta) *rot[1]*rot[2] +rot[0] * sintheta)* vpos[1];	newpos[2] += (costheta + (1-costheta) *rot[2]*rot[2])* vpos[2];	// Now we just add the newly rotated vector to our position to set	// our new rotated position of our camera.	// m_vPosition = vCenter + vNewPosition;		// pos updated	add(x->pos, center, newpos);	cam_boundpos(x);}void cam_rotate_around_lookat (cam *x, Symbol *msg, short argc, Atom *argv){	// This rotates the camera around a point (I.E. your character).	// vCenter is the point that we want to rotate the position around.	// Like the other rotate function, the x, y and z is the axis to rotate around.		// We want to rotate around the Y axis so we pass in a positive Y speed		// g_Camera.RotateAroundPoint(g_Camera.m_vView, kSpeed, 0, 1, 0);		// this is always about 3d person! x->lookat rotat!;)	float temp[4];	short j;	float angle, rot[3];	float costheta, sintheta;	float newpos[3];	float vpos[3], center[3]; // the vector to the point	long i;	for(i=0;i<4;i++) {		if(argv->a_type == A_FLOAT) {			temp[i] = (float)argv->a_w.w_float;			} else if(argv->a_type == A_LONG) {			temp[i] = (float)argv->a_w.w_long;			}	}	// angle axis rotatio!		// set the input in local vars	set(center, x->look[0], x->look[1], x->look[2]); // the center of rotation is the lookat	angle = temp[0];	set(rot, temp[1], temp[2], temp[3]); // the center position to rotate around	// To rotate our position around a point, what we need to do is find	// a vector from our position to the center point we will be rotating around.	// Once we get this vector, then we rotate it along the specified axis with	// the specified degree.  Finally the new vector is added center point that we	// rotated around (vCenter) to become our new position.  That's all it takes.	// Get the vVector from our position to the center we are rotating around	sub(vpos, x->pos, center); // set in vpos the vector from current postition to the desired rotate about point 	costheta = cos(angle);	sintheta = sin(angle);			newpos[0]  = (costheta + (1-costheta) *rot[0]*rot[0])		* vpos[0];	newpos[0] += ((1-costheta) *rot[0]*rot[1] -rot[2] * sintheta)* vpos[1];	newpos[0] += ((1-costheta) *rot[0]*rot[2] +rot[1] * sintheta)* vpos[2];	newpos[1]  = ((1-costheta) *rot[0]*rot[1] +rot[2] * sintheta)* vpos[0];	newpos[1] += (costheta + (1-costheta) *rot[1]*rot[1])		* vpos[1];	newpos[1] += ((1-costheta) *rot[1]*rot[2] -rot[0] * sintheta)* vpos[2];	newpos[2]  = ((1-costheta) *rot[0]*rot[2] -rot[1] * sintheta)	* vpos[0];	newpos[2] += ((1-costheta) *rot[1]*rot[2] +rot[0] * sintheta)* vpos[1];	newpos[2] += (costheta + (1-costheta) *rot[2]*rot[2])* vpos[2];	// Now we just add the newly rotated vector to our position to set	// our new rotated position of our camera.	// m_vPosition = vCenter + vNewPosition;		// pos updated	add(x->pos, center, newpos);	//dont forget to check validity of space	cam_boundpos(x);}void cam_rotX (cam *x, float look[3], float up[3]){	float angle, temp[3], sin_calc, cos_calc;		sin_calc = sin(angle*PIdiv180);	cos_calc = cos(angle*PIdiv180);	x->look[0] = x->look[0] * cos_calc + x->up[0] * sin_calc;	x->look[1] = x->look[1] * cos_calc + x->up[1] * sin_calc;	x->look[2] = x->look[2] * cos_calc + x->up[2] * sin_calc;	norm(x->look);	cross(temp, x->look, x->right);	mult1(x->up, temp, -1.);}void cam_rotY (cam *x, Symbol *msg, short argc, Atom *argv){	float angle, temp[3], cos_calc, sin_calc;	if(argv->a_type == A_FLOAT) {		angle = (float)argv->a_w.w_float;		} else if(argv->a_type == A_LONG) {		angle = (float)argv->a_w.w_long;		}	sin_calc = sin(angle*PIdiv180);	cos_calc = cos(angle*PIdiv180);	x->look[0] = x->look[0] * cos_calc - x->right[0] * sin_calc;	x->look[1] = x->look[1] * cos_calc - x->right[1] * sin_calc;	x->look[2] = x->look[2] * cos_calc - x->right[2] * sin_calc;	norm(x->look); 		cross(x->right, x->look, x->up);/*	//Rotate viewdir around the up vector:	ViewDir = Normalize3dVector(ViewDir*cos(Angle*PIdiv180)								- RightVector*sin(Angle*PIdiv180));	//now compute the new RightVector (by cross product)	RightVector = CrossProduct(&ViewDir, &UpVector);*/}void cam_rotZ (cam *x, Symbol *msg, short argc, Atom *argv){	float angle, temp[3],  cos_calc, sin_calc;	if(argv->a_type == A_FLOAT) {		angle = (float)argv->a_w.w_float;		} else if(argv->a_type == A_LONG) {		angle = (float)argv->a_w.w_long;		}	sin_calc = sin(angle*PIdiv180);	cos_calc = cos(angle*PIdiv180);	x->right[0] = x->right[0] * cos_calc + x->up[0] * sin_calc;	x->right[1] = x->right[1] * cos_calc + x->up[1] * sin_calc;	x->right[2] = x->right[2] * cos_calc + x->up[2] * sin_calc;	norm(x->right); 	cross(x->up, x->look, x->right);	mult1(x->up, x->up, -1.);/*//Rotate viewdir around the right vector:	RightVector = Normalize3dVector(RightVector*cos(Angle*PIdiv180)								+ UpVector*sin(Angle*PIdiv180));	//now compute the new UpVector (by cross product)	UpVector = CrossProduct(&ViewDir, &RightVector)*-1;*/}void cam_reset (cam *x, Symbol *msg, short argc, Atom *argv){	//init	set(x->pos, 0., 0., 0.);	set(x->up, 0., 1., 0.);	set(x->look, 0., 0., -1.);	set(x->right, 1., 0., 0.);}void main(void){ long int tick = gettime(); setup((t_messlist**)&cam_class,(method)cam_new,0L,(short)sizeof(cam),0L, A_GIMME,0); addbang((method)cam_bang); addmess((method)cam_move,"move",A_GIMME, 0); addmess((method)cam_circleup,"circle.up",A_GIMME, 0); addmess((method)cam_circleright,"circle.right",A_GIMME, 0); addmess((method)cam_rotateX,"rotate.x",A_GIMME, 0); addmess((method)cam_rotateY,"rotate.y",A_GIMME, 0); addmess((method)cam_rotateZ,"rotate.z",A_GIMME, 0); addmess((method)cam_fwd,"fwd",A_GIMME, 0); addmess((method)cam_right,"strafe",A_GIMME, 0); addmess((method)cam_up,"up",A_GIMME, 0); addmess((method)cam_setpos,"setpos",A_GIMME, 0); addmess((method)cam_setup,"setup",A_GIMME, 0); addmess((method)cam_setlook,"setlook",A_GIMME, 0); addmess((method)cam_setright,"setright",A_GIMME, 0); addmess((method)cam_reset,"reset",A_GIMME, 0); addmess((method)cam_boundmode,"boundmode",A_GIMME, 0); addmess((method)cam_min,"min",A_GIMME, 0); addmess((method)cam_max,"max",A_GIMME, 0); addmess((method)cam_pov,"pov",A_GIMME, 0); addmess((method)cam_rotate_around_point,"pointrotate",A_GIMME, 0); addmess((method)cam_rotate_around_lookat,"lookrotate",A_GIMME, 0); addmess((method)cam_assist,"assist", A_CANT, 0); post(__DATE__" \t \a \t  "__TIME__"\t \a \t %08xd                                                     a-cam   ©   a n d r Ž s i e r   2 0 0 4   all rights reserved",tick, 0);}void cam_assist(cam *x, void *b, long m, long a, char *s){    if (m==1) { sprintf(s,"echo e   c  h   o"); }       else if (m==2&&a==0) { sprintf(s,"(list) lookat     e         c            h              o"); }    else if (m==2&&a==1) { sprintf(s,"(list) pos    e         c            h              o"); }    else if (m==2&&a==2) { sprintf(s,"(list) up    e         c            h              o"); }}// CIEL funcs sin tables highrez 65535*2 sin slopevoid ciel_make_tables(){	long i;	/*	 * the sin table goes from 0.-1. with inputs from 0-¹/2	 * the actual resolution of this table is TREZ*2	 */	for(i=0;i<TREZ;i++)  // 0-¹/2	{		ciel_sintable[i]= sin( i * M_PI2 / TREZ);		}	// fix long structs		switch (TREZ) {	case 1024: shift = 10; break;	case 2048: shift = 11; break;	case 4096: shift = 12; break;	case 8192: shift = 13; break;	case 16384: shift = 14; break;	case 32768: shift = 15; break;	case 65535: shift = 16; break;	}}double ciel_math_sin(double x){	register int	index;	register int	quad;	index = TREZ * x / (M_PI * 0.5);	quad = ( index >> shift ) & 3;	index &= (TREZ-1);	switch ( quad ) {	case 0:		return ciel_sintable[index];	case 1:		return ciel_sintable[(TREZ-1)-index];	case 2:		return -ciel_sintable[index];	case 3:		return -ciel_sintable[(TREZ-1)-index];	}	return 0;}double ciel_math_cos(double x){	register int	index;	register int	quad;	index = TREZ * x / (M_PI2);	quad = ( index >> shift ) & 3;	index &= (TREZ-1);	switch ( quad ) {	case 3:		return ciel_sintable[index];	case 0:		return ciel_sintable[(TREZ-1)-index];	case 1:		return -ciel_sintable[index];	case 2:		return -ciel_sintable[(TREZ-1)-index];	}	return 0;}double ciel_math_sqrt( double x ) {	float	y;	float	delta;	float	maxError;	if ( x <= 0 ) {		return 0;	}	// initial guess	y = x / 2;	// refine	maxError = x * 0.001;	do {		delta = ( y * y ) - x;		y -= delta / ( 2 * y );	} while ( delta > maxError || delta < -maxError );	return y;}// ----------------------- boundmodesfloat wrap(float in, float min, float max){	if((in >= min) && (in <= max))		return in;			else if(in < min)		return((max + 1) - (min - in));	else		return((min - 1) + (in - max));	}float clip(float in, float min, float max){	if((in >= min) && (in <= max))		return in;			else if(in < min)		return(min);	else		return(max);	}float fold(float in, float min, float max){	float a, b, c;		if (min > max)	{		a = min;		min = max;		max = a;	}		if (in >= min && in <= max || min == max)		b = in;		else	{		c = fabs(max - min) * 2;		if (in < min)		{			a = min - fmod(in - min, c);			if (a >= min && a <= max)				b = a;			else				b = max + (max - a);		}		else		{			a = max - fmod(in - max, c);			if (a > (min - c / 2) && a <= min)				b = min + (min - a);			else				b = a;		}	}		return b;}void wrap1(float in, float min, float max){	float temp;		if((in >= min) && (in <= max))		temp = in;			else if(in < min)		temp = ((max + 1) - (min - in));	else		temp = ((min - 1) + (in - max));		in = temp;}void clip1(float in, float min, float max){	float temp;		if((in >= min) && (in <= max))		temp = in;			else if(in < min)		temp = min;	else		temp = max;		in = temp;}void fold1(float in, float min, float max){	float a, b, c;	float temp;		if (min > max)	{		a = min;		min = max;		max = a;	}		if (in >= min && in <= max || min == max)		b = in;		else	{		c = fabs(max - min) * 2;		if (in < min)		{			a = min - fmod(in - min, c);			if (a >= min && a <= max)				b = a;			else				b = max + (max - a);		}		else		{			a = max - fmod(in - max, c);			if (a > (min - c / 2) && a <= min)				b = min + (min - a);			else				b = a;		}	}		temp = b;		in = temp;}// ----------------------------3d versions boundmodesvoid wrap3(float in[3], float min[3], float max[3]){	float	temp[3];	int i;		for (i=0; i<3;i++) {		if((in[i] >= min[i]) && (in[i] <= max[i]))			temp[i] = in[i];				else if(in[i] < min[i])			temp[i] = ((max[i] + 1.) - (min[i] - in[i]));		else			temp[i] = ((min[i] - 1.) + (in[i] - max[i]));			}	copy(in, temp);}void clip3(float in[3], float min[3], float max[3]){	float	temp[3];	int i;		for (i=0; i<3;i++) {		if((in[i] >= min[i]) && (in[i] <= max[i]))			temp[i] = in[i];				else if(in[i] < min[i])			temp[i] = min[i];		else			temp[i] = max[i];	}		copy(in, temp);}void fold3(float in[3], float min[3], float max[3]){	float	temp[3];	int i;	float a, b, c;		for (i=0; i<3;i++) {		if (min[i] > max[i])		{			a = min[i];			min[i] = max[i];			max[i] = a;		}				if (in[i] >= min[i] && in[i] <= max[i] || min[i] == max[i])			b = in[i];				else		{			c = fabs(max[i] - min[i]) * 2;			if (in[i] < min[i])			{				a = min[i] - fmod(in[i] - min[i], c);				if (a >= min[i] && a <= max[i])					b = a;				else					b = max[i] + (max[i] - a);			}			else			{				a = max[i] - fmod(in[i] - max[i], c);				if (a > (min[i] - c / 2) && a <= min[i])					b = min[i] + (min[i] - a);				else					b = a;			}		}				temp[i] = b;	}	copy(in, temp);}// ---------------------- math -- VECTOR3 ops LIB  WITH DOT PRODUCTvoid copy(float vec0[3], float vec1[3]){    vec0[0] = vec1[0];    vec0[1] = vec1[1];    vec0[2] = vec1[2];}void mult1(float vec0[3], float vec1[3], float v2){    vec0[0] = vec1[0] * v2;    vec0[1] = vec1[1] * v2;    vec0[2] = vec1[2] * v2;}void sub(float vec0[3], float vec1[3], float vec2[3]){    vec0[0] = vec1[0] - vec2[0];    vec0[1] = vec1[1] - vec2[1];    vec0[2] = vec1[2] - vec2[2];}void add(float vec0[3], float vec1[3], float vec2[3]){    vec0[0] = vec1[0] + vec2[0];    vec0[1] = vec1[1] + vec2[1];    vec0[2] = vec1[2] + vec2[2];}void scalDiv(float vec[3], float c){    vec[0] /= c; vec[1] /= c; vec[2] /= c;}void cross(float vec0[3], float vec1[3], float vec2[3]){    vec0[0] = vec1[1] * vec2[2] - vec1[2] * vec2[1];    vec0[1] = vec1[2] * vec2[0] - vec1[0] * vec2[2];    vec0[2] = vec1[0] * vec2[1] - vec1[1] * vec2[0];}void norm(float vec[3]) {	    float c = ciel_math_sqrt((vec[0] * vec[0]) + (vec[1] * vec[1]) + (vec[2] * vec[2]));	if (c == 0.) {		set(vec, 0., 0., 0.);		return;	}    scalDiv(vec, c); }void norm_full(float vec[3]) {	    float c = sqrt((vec[0] * vec[0]) + (vec[1] * vec[1]) + (vec[2] * vec[2]));	if (c == 0.) {		set(vec, 0., 0., 0.);		return;	}    scalDiv(vec, c); }void set(float vec[3], float x, float y, float z){    vec[0] = x;    vec[1] = y;    vec[2] = z;}// n‹o funcionavoid dot(float d, float vec1[3], float vec2[3]) {    d = vec1[0] * vec2[0] + vec1[1] * vec2[1] + vec1[2] * vec2[2];}/*----------------------------------------------------------	EOF----------------------------------------------------------*/