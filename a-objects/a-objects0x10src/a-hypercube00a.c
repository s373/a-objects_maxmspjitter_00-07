/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑhypercube - © andrŽ sier 2002			retorna coordenadas de um hipercubo no espao 3d	after - Richard Asbury	draw a hypercube, screen saverÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*/#include "ext.h"#include "ext_common.h"#include "math.h"#include "stdlib.h"const double radconv = 0.0174533;const double origpt[16][4] = {	{1.0, 1.0, 1.0, 1.0},	{1.0, 1.0, 1.0, -1.0},	{1.0, 1.0, -1.0, 1.0},	{1.0, 1.0, -1.0, -1.0},	{1.0, -1.0, 1.0, 1.0},	{1.0, -1.0, 1.0, -1.0},	{1.0, -1.0, -1.0, 1.0},	{1.0, -1.0, -1.0, -1.0},	{-1.0, 1.0, 1.0, 1.0},	{-1.0, 1.0, 1.0, -1.0},	{-1.0, 1.0, -1.0, 1.0},	{-1.0, 1.0, -1.0, -1.0},	{-1.0, -1.0, 1.0, 1.0},	{-1.0, -1.0, 1.0, -1.0},	{-1.0, -1.0, -1.0, 1.0},	{-1.0, -1.0, -1.0, -1.0}};const int connect[16][4] = {	{1, 2, 4, 8},	{0, 3, 5, 9},	{0, 3, 6, 10},	{0, 0, 7, 11},	{0, 5, 6, 12},	{0, 0, 7, 13},	{0, 0, 7, 14},	{0, 0, 0, 15},	{0, 9, 10, 12},	{0, 0, 11, 13},	{0, 0, 11, 14},	{0, 0, 10, 15},	{0, 0, 13, 14},	{0, 0, 0, 15},	{0, 0, 0, 15},	{0, 0, 0, 0}};const int face[24][4] = {	{1, 0, 2, 3},	{5, 4, 6, 7},	{9, 8, 10, 11},	{13, 12, 14, 15},	{1, 0, 4, 5},	{3, 2, 6, 7},	{9, 8, 12, 13},	{11, 10, 14, 15},	{1, 0, 8, 9},	{3, 2, 10, 11},	{5, 4, 12, 13},	{7, 6, 14, 15},	{2, 0, 4, 6},	{3, 1, 5, 7},	{10, 8, 12, 14},	{11, 9, 13, 15},	{2, 0, 8, 10},	{3, 1, 9, 11},	{6, 4, 12, 14},	{7, 5, 13, 15},	{4, 0, 8, 12},	{5, 1, 9, 13},	{6, 2, 10, 14},	{7, 3, 11, 15}};typedef struct	{	t_object 	        c_ob;				void 		        *c_out;		// values @		double angle[3]; //radians 	double ang[3];   //regular angle	double calc_ang_cos[3];   //cos angle	double calc_ang_sin[3];   //sin angle	double in;	double scale;	Atom 	lista[256];//lista de saida} hypercube;void *hypercube_new (Symbol *msg, short argc, Atom *argv);void hypercube_bang (hypercube *x);void hypercube_calc (hypercube *x);void hypercube_calc_ang (hypercube *x);void hypercube_revert (hypercube *x);void hypercube_echo (hypercube *x, float echo);void hypercube_int(hypercube *x, int n);void hypercube_float(hypercube *x, float n);void hypercube_angle (hypercube *x, float a, float b, float c);void hypercube_rotatewx (hypercube *x, float a);void hypercube_rotatewy (hypercube *x, float a);void hypercube_rotatewz (hypercube *x, float a);void hypercube_scale (hypercube *x, float a);void hypercube_refr (hypercube *x);void hypercube_iterate (hypercube *x);void hypercube_assist(hypercube *x, void *b, long m, long a, char *s);void *hypercube_class;//globaisdouble currpt[16][4];double angle[6];double angvel[6];double angdest[6];double pos[3], vel[3], dest[3];const double angular_acc = 0.1;const double redirect_limit = 10.0;const double max_angular_vel = 3.0;const double scalar_acc = 0.005;const double max_scalar_vel = 0.15;const double alpha_wave_length = 20.0;//const double alpha_fade_val = alpha_wave_length * 159.15494309;const double alpha_fade_val = 20.0 * 159.15494309;const double edge_alpha = 1.0;const double face_alpha = 0.5;void *hypercube_new (Symbol *msg, short argc, Atom *argv) //input the args {	 hypercube *x;	 int i;	 	 x=(hypercube *)newobject(hypercube_class);	 x->c_out=listout(x);		hypercube_revert(x); 	if (argc) {	} else   {	}		 return(x);	}void  hypercube_calc (hypercube *x){	int i, j;	double temp; double s = x->scale;	double cosanga = cos(x->angle[0] * radconv); double sinanga = sin(x->angle[0] * radconv);	double cosangb = cos(x->angle[1] * radconv); double sinangb = sin(x->angle[1] * radconv);	double cosangc = cos(x->angle[2] * radconv); double sinangc = sin(x->angle[2] * radconv);	hypercube_refr(x);		//rotate wx	for (i = 0; i < 16; i++) {		temp = currpt[i][0];		currpt[i][0] = cosanga * temp - sinanga * currpt[i][3];		currpt[i][3] = sinanga * temp + cosanga * currpt[i][3];	}	//rotate wy	for (i = 0; i < 16; i++) {		temp = currpt[i][1];		currpt[i][1] = cosangb * temp - sinangb * currpt[i][3];		currpt[i][3] = sinangb * temp + cosangb * currpt[i][3];	}	//rotate wz	for (i = 0; i < 16; i++) {		temp = currpt[i][2];		currpt[i][2] = cosangc * temp - sinangc * currpt[i][3];		currpt[i][3] = sinangc * temp + cosangc * currpt[i][3];	}	//scale	if (s!=1.0) {		for ( i = 0; i < 16; i++) {			for ( j = 0; j < 3; j++) {				currpt[i][j] = currpt[i][j] * s;		}	  }	}}void hypercube_calc_ang (hypercube *x){	double cosang , sinang ;		cosang = cos(x->angle[0]);	x->calc_ang_cos[0] = cosang;	cosang = cos(x->angle[1]);	x->calc_ang_cos[1] = cosang;	cosang = cos(x->angle[2]);	x->calc_ang_cos[2] = cosang;	sinang = sin(x->angle[0]);	x->calc_ang_sin[0] = sinang;	sinang = sin(x->angle[1]);	x->calc_ang_sin[1] = sinang;	sinang = sin(x->angle[2]);	x->calc_ang_sin[2] = sinang;}void hypercube_revert (hypercube *x){	int i;    for (i=0; i<6;i++){    angvel[i]=0.2;	angdest[i]=0.1;	}    for (i=0; i<3;i++){	pos[i]=0.0; vel[i]=0.1; dest[i]=2.0;	}	x->scale = 1.0;}void hypercube_scale (hypercube *x, float a){/*	int i,j;	for ( i = 0; i < 16; i++) {		for ( j = 0; j < 3; j++) 			currpt[i][j] = currpt[i][j] * a;	}*/	x->scale = a;}void hypercube_refr (hypercube *x){	int i,j;	for (i = 0; i < 16; i++) {		for ( j = 0; j < 4; j++)			currpt[i][j] = origpt[i][j];	}}void hypercube_iterate (hypercube *x){	// angles	int i,j;		for (i = 0; i < 6; i++) {		angle[i] += angvel[i];		while (angle[i] > 360.0) angle[i] -= 360.0;		while (angle[i] < 0.0) angle[i] += 360.0;		if (fmod(angle[i] - angdest[i] + 360.0, 360.0) > fmod(angdest[i] - angle[i] + 360.0, 360.0)) 			angvel[i] += angular_acc;		else 			angvel[i] -= angular_acc;		if (fabs(angle[i] - angdest[i]) < redirect_limit) 			angdest[i] = rand() % 360;		if (angvel[i] > max_angular_vel) angvel[i] = max_angular_vel;		if (angvel[i] < -max_angular_vel) angvel[i] = -max_angular_vel;	}	// position	for (j = 0; j < 3; j++) {		pos[j] += vel[j];		if (fabs(pos[j] - dest[j]) < 1.0) 			dest[j] = (double) ((rand() % 20) - 10);		if (pos[j] > 10.0 && vel[j] > 0.0) vel[j] = -vel[j];		if (pos[j] < -10.0 && vel[j] < 0.0) vel[j] = -vel[j];		if (pos[j] < dest[j]) 			vel[j] += scalar_acc;		else 			vel[j] -= scalar_acc;		if (vel[j] > max_scalar_vel) vel[j] = max_scalar_vel;		if (vel[j] < -max_scalar_vel) vel[j] = -max_scalar_vel;	}}void hypercube_echo (hypercube *x, float echo){ 	x->in = echo; 	hypercube_bang(x);}void hypercube_int(hypercube *x, int n)     { hypercube_echo(x, n);}void hypercube_float(hypercube *x, float n) { hypercube_echo(x, n);}void hypercube_angle (hypercube *x, float a, float b, float c){	x->angle[0] = a;	x->angle[1] = b;	x->angle[2] = c;		angle[0] = x->angle[0];	angle[1] = x->angle[1];	angle[2] = x->angle[2];}void hypercube_rotatewx (hypercube *x, float a){	double temp;	double cosang = cos(a), sinang = sin(a);	int i;	for (i = 0; i < 16; i++) {		temp = currpt[i][0];		currpt[i][0] = cosang * temp - sinang * currpt[i][3];		currpt[i][3] = sinang * temp + cosang * currpt[i][3];	}}void hypercube_rotatewy (hypercube *x, float a){	double temp;	double cosang = cos(a), sinang = sin(a);	int i;	for (i = 0; i < 16; i++) {		temp = currpt[i][1];		currpt[i][1] = cosang * temp - sinang * currpt[i][3];		currpt[i][3] = sinang * temp + cosang * currpt[i][3];	}}void hypercube_rotatewz (hypercube *x, float a){	double temp;	double cosang = cos(a), sinang = sin(a);	int i;	for (i = 0; i < 16; i++) {		temp = currpt[i][2];		currpt[i][2] = cosang * temp - sinang * currpt[i][3];		currpt[i][3] = sinang * temp + cosang * currpt[i][3];	}}void hypercube_bang (hypercube *x){	t_atom *out;	int i,j,k, sum=0;		out = x->lista;    hypercube_calc(x);   //next    	SETSYM  	(out+0, gensym("translate"));	SETFLOAT  	(out+1, pos[0]);	SETFLOAT  	(out+2, pos[1]);	SETFLOAT  	(out+3, (-30. -pos[2]));	outlet_list	(x->c_out, 0L, 4, out);	SETSYM  	(out+0, gensym("angle"));	SETFLOAT  	(out+1, angle[0]);	SETFLOAT  	(out+2, angle[1]);	SETFLOAT  	(out+3, angle[2]);	outlet_list	(x->c_out, 0L, 4, out);		for (i = 0; i < 16; i++) {		for (j = 0; j < 4; j++) {			if (k = connect[i][j]) {				SETSYM  	(out+0, gensym("vertex"));				SETFLOAT  	(out+1, currpt[i][0]);				SETFLOAT  	(out+2, currpt[i][1]);				SETFLOAT  	(out+3, currpt[i][2]);				outlet_list	(x->c_out, 0L, 4, out);				SETSYM  	(out+0, gensym("vertex"));				SETFLOAT  	(out+1, currpt[k][0]);				SETFLOAT  	(out+2, currpt[k][1]);				SETFLOAT  	(out+3, currpt[k][2]);				outlet_list	(x->c_out, 0L, 4, out);				}			}		}}void main(void){ long int tick = gettime(); setup((t_messlist**)&hypercube_class,(method)hypercube_new,0L,(short)sizeof(hypercube),0L, A_GIMME,0); addbang((method)hypercube_bang);  addint((method)hypercube_int); addfloat((method)hypercube_float);  addmess((method)hypercube_angle,"angle",A_DEFFLOAT,A_DEFFLOAT,A_DEFFLOAT,0); addmess((method)hypercube_scale,"scale",A_DEFFLOAT,0); addmess((method)hypercube_assist,"assist", A_CANT, 0); post(__DATE__" \t \a \t  "__TIME__"\t \a \t %08xd                                                     a-hypercube   ©   a n d r Ž s i e r   2 0 0 4   all rights reserved",tick, 0);}void hypercube_assist(hypercube *x, void *b, long m, long a, char *s){    if (m==1) { sprintf(s,"echo e   c  h   o"); }       else if (m==2&&a==0) { sprintf(s,"(float)     e         c            h              o"); }    else if (m==2&&a==1) { sprintf(s,"(lisy)       e             c                h                   o"); }}